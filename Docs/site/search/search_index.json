{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"home/","text":"","title":"Home"},{"location":"md/derive/","text":"derive derive data from base data PnPSolver \u89e3PnP __init__ __init__ ( matrix_camera : Union [ np . ndarray , str , None ] = None , distortion_coeffs : Union [ np . ndarray , None ] = None ) -> None brief PnP\u6c42\u89e3\u5668\uff0c\u5185\u7f6e\u4e86\u5404\u4e2a\u7269\u4f53\u7684\u5173\u952e\u70b93D\u5750\u6807\u3001\u5305\u56f4\u76d23D\u5750\u6807 Parameters: image_resize \u2013 matrix_camera ( Union [ ndarray , str , None] , default: None ) \u2013 models_info_path \u2013 keypoint_info_path \u2013 calc_reproj calc_reproj ( points_3d : np . ndarray , vector_R : np . ndarray = None , vector_T : np . ndarray = None , posture : Posture = None , K : np . ndarray = None , D : np . ndarray = None ) -> np . ndarray points_3d: [N,3] vector_R: [3,1] or [3] vector_T: [3,1] or [3] posture: Posture K: [3,3] D: [5,1] return point2D: [N,2] get_zoomed_K staticmethod get_zoomed_K ( K : np . ndarray , image_resize : tuple [ tuple [ int , int ], tuple [ int , int ]]) -> np . ndarray K: np.ndarray, 3x3 image_resize: ((w, h), (w, h)), eg.((640, 480), (640, 480)) init_default_intr init_default_intr ( matrix_camera : Union [ np . ndarray , str , None ] = None ) init_distortion_coeffs init_distortion_coeffs ( distortion_coeffs : Union [ np . ndarray , None ] = None ) solvepnp solvepnp ( points : np . ndarray , points_3d : np . ndarray , points_visib : np . ndarray = None , K : Union [ np . ndarray , CameraIntr ] = None , D : np . ndarray = None , * , return_posture = False ) point_type: 'kp', 'bbox' calc_Z_rot_angle_to_horizontal calc_Z_rot_angle_to_horizontal ( T_ex ) -> np . ndarray calc_bbox_2d_proj calc_bbox_2d_proj ( mesh_meta : MeshMeta , postures : Posture , intrinsics : CameraIntr ) calc_bbox_3d_proj calc_bbox_3d_proj ( mesh_meta : MeshMeta , postures : Posture , intrinsics : CameraIntr ) calc_landmarks_proj calc_landmarks_proj ( mesh_meta : MeshMeta , postures : Posture , intrinsics : CameraIntr ) calc_masks calc_masks ( mesh_metas : list [ MeshMeta ], postures : list [ Posture ], intrinsics : CameraIntr , ignore_depth = False , tri_mode = True , reserve_empty = True ) Parameters: return \u2013 masks \u2013 visib_fracts \u2013 calc_viewmeta_by_base calc_viewmeta_by_base ( viewmeta : ViewMeta , mesh_dict : dict [ int , MeshMeta ], cover = False ) cvt_by_intr cvt_by_intr ( image : np . ndarray , cam_intr_1 : Union [ np . ndarray , CameraIntr ], cam_intr_2 : Union [ np . ndarray , CameraIntr ], new_image_shape : Iterable [ int ] = None ) new_image_shape: (w, h) inv_proj inv_proj ( intr_M : np . ndarray , pixels : np . ndarray , depth : float ) brief reproj 2d pixels to 3d sapce on a specified depth","title":"derive"},{"location":"md/derive/#derive_1","text":"derive data from base data","title":"derive"},{"location":"md/derive/#derive.PnPSolver","text":"\u89e3PnP","title":"PnPSolver"},{"location":"md/derive/#derive.PnPSolver.__init__","text":"__init__ ( matrix_camera : Union [ np . ndarray , str , None ] = None , distortion_coeffs : Union [ np . ndarray , None ] = None ) -> None","title":"__init__()"},{"location":"md/derive/#derive.PnPSolver.__init__--brief","text":"PnP\u6c42\u89e3\u5668\uff0c\u5185\u7f6e\u4e86\u5404\u4e2a\u7269\u4f53\u7684\u5173\u952e\u70b93D\u5750\u6807\u3001\u5305\u56f4\u76d23D\u5750\u6807 Parameters: image_resize \u2013 matrix_camera ( Union [ ndarray , str , None] , default: None ) \u2013 models_info_path \u2013 keypoint_info_path \u2013","title":"brief"},{"location":"md/derive/#derive.PnPSolver.calc_reproj","text":"calc_reproj ( points_3d : np . ndarray , vector_R : np . ndarray = None , vector_T : np . ndarray = None , posture : Posture = None , K : np . ndarray = None , D : np . ndarray = None ) -> np . ndarray points_3d: [N,3] vector_R: [3,1] or [3] vector_T: [3,1] or [3] posture: Posture K: [3,3] D: [5,1]","title":"calc_reproj()"},{"location":"md/derive/#derive.PnPSolver.calc_reproj--return","text":"point2D: [N,2]","title":"return"},{"location":"md/derive/#derive.PnPSolver.get_zoomed_K","text":"get_zoomed_K ( K : np . ndarray , image_resize : tuple [ tuple [ int , int ], tuple [ int , int ]]) -> np . ndarray K: np.ndarray, 3x3 image_resize: ((w, h), (w, h)), eg.((640, 480), (640, 480))","title":"get_zoomed_K()"},{"location":"md/derive/#derive.PnPSolver.init_default_intr","text":"init_default_intr ( matrix_camera : Union [ np . ndarray , str , None ] = None )","title":"init_default_intr()"},{"location":"md/derive/#derive.PnPSolver.init_distortion_coeffs","text":"init_distortion_coeffs ( distortion_coeffs : Union [ np . ndarray , None ] = None )","title":"init_distortion_coeffs()"},{"location":"md/derive/#derive.PnPSolver.solvepnp","text":"solvepnp ( points : np . ndarray , points_3d : np . ndarray , points_visib : np . ndarray = None , K : Union [ np . ndarray , CameraIntr ] = None , D : np . ndarray = None , * , return_posture = False ) point_type: 'kp', 'bbox'","title":"solvepnp()"},{"location":"md/derive/#derive.calc_Z_rot_angle_to_horizontal","text":"calc_Z_rot_angle_to_horizontal ( T_ex ) -> np . ndarray","title":"calc_Z_rot_angle_to_horizontal()"},{"location":"md/derive/#derive.calc_bbox_2d_proj","text":"calc_bbox_2d_proj ( mesh_meta : MeshMeta , postures : Posture , intrinsics : CameraIntr )","title":"calc_bbox_2d_proj()"},{"location":"md/derive/#derive.calc_bbox_3d_proj","text":"calc_bbox_3d_proj ( mesh_meta : MeshMeta , postures : Posture , intrinsics : CameraIntr )","title":"calc_bbox_3d_proj()"},{"location":"md/derive/#derive.calc_landmarks_proj","text":"calc_landmarks_proj ( mesh_meta : MeshMeta , postures : Posture , intrinsics : CameraIntr )","title":"calc_landmarks_proj()"},{"location":"md/derive/#derive.calc_masks","text":"calc_masks ( mesh_metas : list [ MeshMeta ], postures : list [ Posture ], intrinsics : CameraIntr , ignore_depth = False , tri_mode = True , reserve_empty = True ) Parameters: return \u2013 masks \u2013 visib_fracts \u2013","title":"calc_masks()"},{"location":"md/derive/#derive.calc_viewmeta_by_base","text":"calc_viewmeta_by_base ( viewmeta : ViewMeta , mesh_dict : dict [ int , MeshMeta ], cover = False )","title":"calc_viewmeta_by_base()"},{"location":"md/derive/#derive.cvt_by_intr","text":"cvt_by_intr ( image : np . ndarray , cam_intr_1 : Union [ np . ndarray , CameraIntr ], cam_intr_2 : Union [ np . ndarray , CameraIntr ], new_image_shape : Iterable [ int ] = None ) new_image_shape: (w, h)","title":"cvt_by_intr()"},{"location":"md/derive/#derive.inv_proj","text":"inv_proj ( intr_M : np . ndarray , pixels : np . ndarray , depth : float )","title":"inv_proj()"},{"location":"md/derive/#derive.inv_proj--brief","text":"reproj 2d pixels to 3d sapce on a specified depth","title":"brief"},{"location":"md/metric/","text":"metric MetricCalculator ADD class-attribute instance-attribute ADD = 2 ALL class-attribute instance-attribute ALL = 0 REPROJ class-attribute instance-attribute REPROJ = 1 _5CM5D class-attribute instance-attribute _5CM5D = 3 class_num property class_num mesh_manager property writable mesh_manager pnpsolver instance-attribute pnpsolver : PnPSolver = pnpsolver _5cm5d_metric _5cm5d_metric ( class_id , pred_posture : Posture , gt_posture : Posture ) -> tuple [ bool , float ] 5cm5\u00b0 metric Parameters: class_id \u2013 pred_posture ( Posture ) \u2013 gt_posture ( Posture ) \u2013 Returns: rlt ( bool, if 5cm5d metric is satisfied ) \u2013 rotation_angle_deg ( float, rotation angle error in degree ) \u2013 __init__ __init__ ( pnpsolver : PnPSolver , mesh_manager : MeshManager ) -> None class_num: \u5305\u542b\u80cc\u666f\u5728\u5185\u7684\u7c7b\u6570 _add_metric _add_metric ( class_id , pred_posture : Posture , gt_posture : Posture ) -> tuple [ bool , float ] add metric return rlt: bool, whether the prediction is correct error: float, the error _reprojection_metric _reprojection_metric ( class_id , pred_posture : Posture , gt_posture : Posture ) -> tuple [ bool , float ] reprojection metric Parameters: class_id \u2013 pred_posture ( Posture ) \u2013 gt_posture ( Posture ) \u2013 return rlt: bool, whether the error is less than 5 error: float, the mean error of all points calc_one_error calc_one_error ( class_id : int , pred_posture : Posture , gt_posture : Posture , selected_metrics : Union [ int , Iterable [ int ]] = ALL ) -> tuple [ MetricResult ] clear clear () print_result print_result ( rate = False ) print the result of all classes record record ( error_result : list [ MetricResult ], class_id ) select_metrics select_metrics ( type : int = 0 ) MetricResult error instance-attribute error = error passed instance-attribute passed = bool ( passed ) type instance-attribute type = type type_name property type_name __init__ __init__ ( type : int , passed : bool , error : float ) -> None __str__ __str__ () -> str print print ()","title":"metric"},{"location":"md/metric/#metric_1","text":"","title":"metric"},{"location":"md/metric/#metric.MetricCalculator","text":"","title":"MetricCalculator"},{"location":"md/metric/#metric.MetricCalculator.ADD","text":"ADD = 2","title":"ADD"},{"location":"md/metric/#metric.MetricCalculator.ALL","text":"ALL = 0","title":"ALL"},{"location":"md/metric/#metric.MetricCalculator.REPROJ","text":"REPROJ = 1","title":"REPROJ"},{"location":"md/metric/#metric.MetricCalculator._5CM5D","text":"_5CM5D = 3","title":"_5CM5D"},{"location":"md/metric/#metric.MetricCalculator.class_num","text":"class_num","title":"class_num"},{"location":"md/metric/#metric.MetricCalculator.mesh_manager","text":"mesh_manager","title":"mesh_manager"},{"location":"md/metric/#metric.MetricCalculator.pnpsolver","text":"pnpsolver : PnPSolver = pnpsolver","title":"pnpsolver"},{"location":"md/metric/#metric.MetricCalculator._5cm5d_metric","text":"_5cm5d_metric ( class_id , pred_posture : Posture , gt_posture : Posture ) -> tuple [ bool , float ] 5cm5\u00b0 metric Parameters: class_id \u2013 pred_posture ( Posture ) \u2013 gt_posture ( Posture ) \u2013 Returns: rlt ( bool, if 5cm5d metric is satisfied ) \u2013 rotation_angle_deg ( float, rotation angle error in degree ) \u2013","title":"_5cm5d_metric()"},{"location":"md/metric/#metric.MetricCalculator.__init__","text":"__init__ ( pnpsolver : PnPSolver , mesh_manager : MeshManager ) -> None class_num: \u5305\u542b\u80cc\u666f\u5728\u5185\u7684\u7c7b\u6570","title":"__init__()"},{"location":"md/metric/#metric.MetricCalculator._add_metric","text":"_add_metric ( class_id , pred_posture : Posture , gt_posture : Posture ) -> tuple [ bool , float ] add metric","title":"_add_metric()"},{"location":"md/metric/#metric.MetricCalculator._add_metric--return","text":"rlt: bool, whether the prediction is correct error: float, the error","title":"return"},{"location":"md/metric/#metric.MetricCalculator._reprojection_metric","text":"_reprojection_metric ( class_id , pred_posture : Posture , gt_posture : Posture ) -> tuple [ bool , float ] reprojection metric Parameters: class_id \u2013 pred_posture ( Posture ) \u2013 gt_posture ( Posture ) \u2013","title":"_reprojection_metric()"},{"location":"md/metric/#metric.MetricCalculator._reprojection_metric--return","text":"rlt: bool, whether the error is less than 5 error: float, the mean error of all points","title":"return"},{"location":"md/metric/#metric.MetricCalculator.calc_one_error","text":"calc_one_error ( class_id : int , pred_posture : Posture , gt_posture : Posture , selected_metrics : Union [ int , Iterable [ int ]] = ALL ) -> tuple [ MetricResult ]","title":"calc_one_error()"},{"location":"md/metric/#metric.MetricCalculator.clear","text":"clear ()","title":"clear()"},{"location":"md/metric/#metric.MetricCalculator.print_result","text":"print_result ( rate = False ) print the result of all classes","title":"print_result()"},{"location":"md/metric/#metric.MetricCalculator.record","text":"record ( error_result : list [ MetricResult ], class_id )","title":"record()"},{"location":"md/metric/#metric.MetricCalculator.select_metrics","text":"select_metrics ( type : int = 0 )","title":"select_metrics()"},{"location":"md/metric/#metric.MetricResult","text":"","title":"MetricResult"},{"location":"md/metric/#metric.MetricResult.error","text":"error = error","title":"error"},{"location":"md/metric/#metric.MetricResult.passed","text":"passed = bool ( passed )","title":"passed"},{"location":"md/metric/#metric.MetricResult.type","text":"type = type","title":"type"},{"location":"md/metric/#metric.MetricResult.type_name","text":"type_name","title":"type_name"},{"location":"md/metric/#metric.MetricResult.__init__","text":"__init__ ( type : int , passed : bool , error : float ) -> None","title":"__init__()"},{"location":"md/metric/#metric.MetricResult.__str__","text":"__str__ () -> str","title":"__str__()"},{"location":"md/metric/#metric.MetricResult.print","text":"print ()","title":"print()"},{"location":"md/core/intr/","text":"intr CameraIntr CAM_CX class-attribute instance-attribute CAM_CX = 'cam_cx' CAM_CY class-attribute instance-attribute CAM_CY = 'cam_cy' CAM_FX class-attribute instance-attribute CAM_FX = 'cam_fx' CAM_FY class-attribute instance-attribute CAM_FY = 'cam_fy' CAM_HGT class-attribute instance-attribute CAM_HGT = 'cam_hgt' CAM_WID class-attribute instance-attribute CAM_WID = 'cam_wid' DEPTH_SCALE class-attribute instance-attribute DEPTH_SCALE = 'depth_scale' EPS class-attribute instance-attribute EPS = 'eps' INTR_M class-attribute instance-attribute INTR_M = 'intr_M' MAX_DEPTH class-attribute instance-attribute MAX_DEPTH = 'max_depth' depth_scale instance-attribute depth_scale = depth_scale eps instance-attribute eps = eps intr_M instance-attribute intr_M = intr_M max_depth instance-attribute max_depth = max_depth __init__ __init__ ( intr_M , cam_wid = 0 , cam_hgt = 0 , depth_scale = 0.0 , eps = 1e-06 , max_depth = 4000.0 ) -> None __mul__ __mul__ ( points : np . ndarray ) points: [N, (x,y,z)] return pixels: [N, (x,y)] filter_in_view filter_in_view ( pixels : np . ndarray ) pixels: ndarray [N, (x,y)] from_json staticmethod from_json ( path : Union [ str , dict ]) parse_intr_matrix staticmethod parse_intr_matrix ( intr_M ) return CAM_FX, CAM_FY, CAM_CX, CAM_CY save_as_json save_as_json ( path )","title":"intr"},{"location":"md/core/intr/#intr","text":"","title":"intr"},{"location":"md/core/intr/#core.intr.CameraIntr","text":"","title":"CameraIntr"},{"location":"md/core/intr/#core.intr.CameraIntr.CAM_CX","text":"CAM_CX = 'cam_cx'","title":"CAM_CX"},{"location":"md/core/intr/#core.intr.CameraIntr.CAM_CY","text":"CAM_CY = 'cam_cy'","title":"CAM_CY"},{"location":"md/core/intr/#core.intr.CameraIntr.CAM_FX","text":"CAM_FX = 'cam_fx'","title":"CAM_FX"},{"location":"md/core/intr/#core.intr.CameraIntr.CAM_FY","text":"CAM_FY = 'cam_fy'","title":"CAM_FY"},{"location":"md/core/intr/#core.intr.CameraIntr.CAM_HGT","text":"CAM_HGT = 'cam_hgt'","title":"CAM_HGT"},{"location":"md/core/intr/#core.intr.CameraIntr.CAM_WID","text":"CAM_WID = 'cam_wid'","title":"CAM_WID"},{"location":"md/core/intr/#core.intr.CameraIntr.DEPTH_SCALE","text":"DEPTH_SCALE = 'depth_scale'","title":"DEPTH_SCALE"},{"location":"md/core/intr/#core.intr.CameraIntr.EPS","text":"EPS = 'eps'","title":"EPS"},{"location":"md/core/intr/#core.intr.CameraIntr.INTR_M","text":"INTR_M = 'intr_M'","title":"INTR_M"},{"location":"md/core/intr/#core.intr.CameraIntr.MAX_DEPTH","text":"MAX_DEPTH = 'max_depth'","title":"MAX_DEPTH"},{"location":"md/core/intr/#core.intr.CameraIntr.depth_scale","text":"depth_scale = depth_scale","title":"depth_scale"},{"location":"md/core/intr/#core.intr.CameraIntr.eps","text":"eps = eps","title":"eps"},{"location":"md/core/intr/#core.intr.CameraIntr.intr_M","text":"intr_M = intr_M","title":"intr_M"},{"location":"md/core/intr/#core.intr.CameraIntr.max_depth","text":"max_depth = max_depth","title":"max_depth"},{"location":"md/core/intr/#core.intr.CameraIntr.__init__","text":"__init__ ( intr_M , cam_wid = 0 , cam_hgt = 0 , depth_scale = 0.0 , eps = 1e-06 , max_depth = 4000.0 ) -> None","title":"__init__()"},{"location":"md/core/intr/#core.intr.CameraIntr.__mul__","text":"__mul__ ( points : np . ndarray ) points: [N, (x,y,z)]","title":"__mul__()"},{"location":"md/core/intr/#core.intr.CameraIntr.__mul__--return","text":"pixels: [N, (x,y)]","title":"return"},{"location":"md/core/intr/#core.intr.CameraIntr.filter_in_view","text":"filter_in_view ( pixels : np . ndarray ) pixels: ndarray [N, (x,y)]","title":"filter_in_view()"},{"location":"md/core/intr/#core.intr.CameraIntr.from_json","text":"from_json ( path : Union [ str , dict ])","title":"from_json()"},{"location":"md/core/intr/#core.intr.CameraIntr.parse_intr_matrix","text":"parse_intr_matrix ( intr_M ) return CAM_FX, CAM_FY, CAM_CX, CAM_CY","title":"parse_intr_matrix()"},{"location":"md/core/intr/#core.intr.CameraIntr.save_as_json","text":"save_as_json ( path )","title":"save_as_json()"},{"location":"md/core/posture/","text":"posture T module-attribute T = TypeVar ( 'T' , 'Posture' , npt . NDArray ) Icosahedron Bases: Rotation vecs instance-attribute vecs = vecs __init__ __init__ () -> None Posture \u59ff\u6001\u7c7b\uff0c\u63a5\u6536\u5404\u79cd\u7c7b\u578b\u7684\u59ff\u6001\u7684\u8f93\u5165\uff0c\u5e76\u8f6c\u6362\u4e3a\u77e9\u9635 POSTURE_EULARZYX class-attribute instance-attribute POSTURE_EULARZYX = 3 POSTURE_HOMOMAT class-attribute instance-attribute POSTURE_HOMOMAT = 2 POSTURE_MAT class-attribute instance-attribute POSTURE_MAT = 1 POSTURE_VEC class-attribute instance-attribute POSTURE_VEC = 0 eularZYX property eularZYX inv_transmat property inv_transmat : np . ndarray rmat property rmat : np . ndarray rvec property rvec : np . ndarray trans_mat instance-attribute trans_mat : np . ndarray = np . eye ( 4 ) tvec property tvec : np . ndarray __div__ __div__ ( obj ) __init__ __init__ ( * , rvec : np . ndarray = None , tvec : np . ndarray = None , rmat : np . ndarray = None , homomat : np . ndarray = None , ** Eular ) -> None __mul__ __mul__ ( obj : T ) -> T from_vecs classmethod from_vecs ( src_vec : np . ndarray , dst_vec : np . ndarray ) get_NED get_NED ( degrees = False ) get_eular get_eular ( seq , degrees = False ) inv inv () set_homomat set_homomat ( homomat ) set_rmat set_rmat ( rmat ) set_rvec set_rvec ( rvec ) set_tvec set_tvec ( tvec ) Rotation vecs instance-attribute vecs = np . array ([]) __init__ __init__ () -> None __iter__ __iter__ () get_rvec get_rvec () get_rvec_from_destination staticmethod get_rvec_from_destination ( dest : np . ndarray , base : Union [ np . ndarray , list ] = [ 0 , 0 , 1 ]) plot_destination plot_destination ( ax ) SphereAngle Bases: Rotation vecs instance-attribute vecs = loc __init__ __init__ ( nums_points = 500 ) -> None","title":"posture"},{"location":"md/core/posture/#posture","text":"","title":"posture"},{"location":"md/core/posture/#core.posture.T","text":"T = TypeVar ( 'T' , 'Posture' , npt . NDArray )","title":"T"},{"location":"md/core/posture/#core.posture.Icosahedron","text":"Bases: Rotation","title":"Icosahedron"},{"location":"md/core/posture/#core.posture.Icosahedron.vecs","text":"vecs = vecs","title":"vecs"},{"location":"md/core/posture/#core.posture.Icosahedron.__init__","text":"__init__ () -> None","title":"__init__()"},{"location":"md/core/posture/#core.posture.Posture","text":"\u59ff\u6001\u7c7b\uff0c\u63a5\u6536\u5404\u79cd\u7c7b\u578b\u7684\u59ff\u6001\u7684\u8f93\u5165\uff0c\u5e76\u8f6c\u6362\u4e3a\u77e9\u9635","title":"Posture"},{"location":"md/core/posture/#core.posture.Posture.POSTURE_EULARZYX","text":"POSTURE_EULARZYX = 3","title":"POSTURE_EULARZYX"},{"location":"md/core/posture/#core.posture.Posture.POSTURE_HOMOMAT","text":"POSTURE_HOMOMAT = 2","title":"POSTURE_HOMOMAT"},{"location":"md/core/posture/#core.posture.Posture.POSTURE_MAT","text":"POSTURE_MAT = 1","title":"POSTURE_MAT"},{"location":"md/core/posture/#core.posture.Posture.POSTURE_VEC","text":"POSTURE_VEC = 0","title":"POSTURE_VEC"},{"location":"md/core/posture/#core.posture.Posture.eularZYX","text":"eularZYX","title":"eularZYX"},{"location":"md/core/posture/#core.posture.Posture.inv_transmat","text":"inv_transmat : np . ndarray","title":"inv_transmat"},{"location":"md/core/posture/#core.posture.Posture.rmat","text":"rmat : np . ndarray","title":"rmat"},{"location":"md/core/posture/#core.posture.Posture.rvec","text":"rvec : np . ndarray","title":"rvec"},{"location":"md/core/posture/#core.posture.Posture.trans_mat","text":"trans_mat : np . ndarray = np . eye ( 4 )","title":"trans_mat"},{"location":"md/core/posture/#core.posture.Posture.tvec","text":"tvec : np . ndarray","title":"tvec"},{"location":"md/core/posture/#core.posture.Posture.__div__","text":"__div__ ( obj )","title":"__div__()"},{"location":"md/core/posture/#core.posture.Posture.__init__","text":"__init__ ( * , rvec : np . ndarray = None , tvec : np . ndarray = None , rmat : np . ndarray = None , homomat : np . ndarray = None , ** Eular ) -> None","title":"__init__()"},{"location":"md/core/posture/#core.posture.Posture.__mul__","text":"__mul__ ( obj : T ) -> T","title":"__mul__()"},{"location":"md/core/posture/#core.posture.Posture.from_vecs","text":"from_vecs ( src_vec : np . ndarray , dst_vec : np . ndarray )","title":"from_vecs()"},{"location":"md/core/posture/#core.posture.Posture.get_NED","text":"get_NED ( degrees = False )","title":"get_NED()"},{"location":"md/core/posture/#core.posture.Posture.get_eular","text":"get_eular ( seq , degrees = False )","title":"get_eular()"},{"location":"md/core/posture/#core.posture.Posture.inv","text":"inv ()","title":"inv()"},{"location":"md/core/posture/#core.posture.Posture.set_homomat","text":"set_homomat ( homomat )","title":"set_homomat()"},{"location":"md/core/posture/#core.posture.Posture.set_rmat","text":"set_rmat ( rmat )","title":"set_rmat()"},{"location":"md/core/posture/#core.posture.Posture.set_rvec","text":"set_rvec ( rvec )","title":"set_rvec()"},{"location":"md/core/posture/#core.posture.Posture.set_tvec","text":"set_tvec ( tvec )","title":"set_tvec()"},{"location":"md/core/posture/#core.posture.Rotation","text":"","title":"Rotation"},{"location":"md/core/posture/#core.posture.Rotation.vecs","text":"vecs = np . array ([])","title":"vecs"},{"location":"md/core/posture/#core.posture.Rotation.__init__","text":"__init__ () -> None","title":"__init__()"},{"location":"md/core/posture/#core.posture.Rotation.__iter__","text":"__iter__ ()","title":"__iter__()"},{"location":"md/core/posture/#core.posture.Rotation.get_rvec","text":"get_rvec ()","title":"get_rvec()"},{"location":"md/core/posture/#core.posture.Rotation.get_rvec_from_destination","text":"get_rvec_from_destination ( dest : np . ndarray , base : Union [ np . ndarray , list ] = [ 0 , 0 , 1 ])","title":"get_rvec_from_destination()"},{"location":"md/core/posture/#core.posture.Rotation.plot_destination","text":"plot_destination ( ax )","title":"plot_destination()"},{"location":"md/core/posture/#core.posture.SphereAngle","text":"Bases: Rotation","title":"SphereAngle"},{"location":"md/core/posture/#core.posture.SphereAngle.vecs","text":"vecs = loc","title":"vecs"},{"location":"md/core/posture/#core.posture.SphereAngle.__init__","text":"__init__ ( nums_points = 500 ) -> None","title":"__init__()"},{"location":"md/core/utils/","text":"utils COLKETT module-attribute COLKETT = TypeVar ( 'COLKETT' , int , str ) ITEM module-attribute ITEM = TypeVar ( 'ITEM' ) KT module-attribute KT = TypeVar ( 'KT' ) ROWKEYT module-attribute ROWKEYT = TypeVar ( 'ROWKEYT' , int , str ) VT module-attribute VT = TypeVar ( 'VT' ) JsonIO Stream _closed instance-attribute _closed = True buffer instance-attribute buffer = '' buffer_length instance-attribute buffer_length = buffer_length closed property writable closed path instance-attribute path = path __del__ __del__ () __init__ __init__ ( path , open = False , buffer_length = 100000 ) -> None close close () open open () save_buffer save_buffer () write write ( to_dump_dict ) _MyEncoder Bases: JSONEncoder FORMAT_SPEC class-attribute instance-attribute FORMAT_SPEC = '@@ {} @@' regex class-attribute instance-attribute regex = re . compile ( FORMAT_SPEC . format ( '( \\\\ d+)' )) __init__ __init__ ( ** kwargs ) default default ( obj ) encode encode ( obj ) _NoIndent Bases: object Value wrapper. value instance-attribute value = value __init__ __init__ ( value ) _dumps staticmethod _dumps ( to_dump_dict , regard_list_as_array = False ) create_stream staticmethod create_stream ( path ) dump_json staticmethod dump_json ( path , to_dump_dict , regard_list_as_array = False ) load_json staticmethod load_json ( path , format = True , cvt_list_to_array = True ) Table Bases: Generic [ ROWKEYT , COLKETT , ITEM ] \u4f7f\u7528\u793a\u4f8b table = Table() table.add_column(\"Name\") table.add_column(\"Age\") table.add_row(\"Row1\") table.add_row(\"Row2\") \u589e\u52a0\u6570\u636e table[\"Row1\", \"Name\"] = \"Alice\" table[\"Row1\", \"Age\"] = 25 table[\"Row2\", \"Name\"] = \"Bob\" table[\"Row2\", \"Age\"] = 30 print(table.get_row(\"Row1\")) # \u8f93\u51fa: {'Name': ['Alice'], 'Age': [25]} print(table.get_column(\"Age\")) # \u8f93\u51fa: {'Row1': [25], 'Row2': [30]} \u5220\u9664\u6570\u636e del table[\"Row1\", \"Age\"] print(table.get_row(\"Row1\")) # \u8f93\u51fa: {'Name': ['Alice'], 'Age': []} KW_EMPTY class-attribute instance-attribute KW_EMPTY = 'empty' KW_col_name_type class-attribute instance-attribute KW_col_name_type = 'col_name_type' KW_col_names class-attribute instance-attribute KW_col_names = 'col_names' KW_data class-attribute instance-attribute KW_data = 'data' KW_default_value_type class-attribute instance-attribute KW_default_value_type = 'default_value_type' KW_row_name_type class-attribute instance-attribute KW_row_name_type = 'row_name_type' KW_row_names class-attribute instance-attribute KW_row_names = 'row_names' col_name_type property writable col_name_type col_names property col_names data property data default_value_type property writable default_value_type empty property empty row_name_type property writable row_name_type row_names property row_names __contains__ __contains__ ( item ) __getitem__ __getitem__ ( keys : Union [ int , str , tuple [ Union [ int , str ]]]) __init__ __init__ ( data : dict = None , * , row_names : list [ ROWKEYT ] = None , col_names : list [ COLKETT ] = None , default_value_type : type [ ITEM ] = None , row_name_type = str , col_name_type = str ) __iter__ __iter__ () __len__ __len__ () __setitem__ __setitem__ ( keys : tuple [ Union [ int , str ]], value : Union [ ITEM , dict [ ROWKEYT , dict [ COLKETT , ITEM ]], Table [ ROWKEYT , COLKETT , ITEM ]] = None ) __str__ __str__ () -> str _col_name_filter _col_name_filter ( col_name : COLKETT ) -> COLKETT _row_name_filter _row_name_filter ( row_name : ROWKEYT ) -> ROWKEYT add_column add_column ( col_name : COLKETT , exist_ok = False ) add_row add_row ( row_name : ROWKEYT , exist_ok = False ) assert_default_value_type assert_default_value_type ( value ) clean_invalid clean_invalid ( judge_invalid_func : Callable ) clear clear () from_dict classmethod from_dict ( dict_ : dict ) from_json classmethod from_json ( path ) gen_default_value gen_default_value () -> ITEM get_column get_column ( col_name : Union [ int , str ]) -> dict [ ROWKEYT , ITEM ] get_row get_row ( row_name : Union [ int , str ]) -> dict [ COLKETT , ITEM ] get_type staticmethod get_type ( table_dict , default_row_type = str , default_col_type = str ) items items () keys keys () merge merge ( other : dict [ str , dict [ str , ITEM ]], merge_func : Callable = None ) move_column move_column ( col_name : Union [ int , str ], new_name : Union [ int , str ]) move_row move_row ( row_name : Union [ int , str ], new_name : Union [ int , str ]) remove_column remove_column ( col_name : Union [ int , str ], not_exist_ok = False ) remove_row remove_row ( row_name : Union [ int , str ], not_exist_ok = False ) resort_column resort_column ( new_col_names : list [ Union [ int , str ]]) resort_row resort_row ( new_row_names : list [ Union [ int , str ]]) save save ( path ) set_column set_column ( col_name : Union [ int , str ], col : dict [ ROWKEYT , ITEM ]) set_row set_row ( row_name : Union [ int , str ], row : dict [ COLKETT , ITEM ]) sort sort ( key : Callable = None , reverse : bool = False ) to_dict to_dict () to_json classmethod to_json ( path , table : Table ) tranverse tranverse ( with_key = False ) update update ( other : Union [ dict [ ROWKEYT , dict [ COLKETT , ITEM ]], Table [ ROWKEYT , COLKETT , ITEM ]]) values values () _ignore_warning _ignore_warning ( func , category = Warning ) deserialize_object deserialize_object ( serialized_file_path ) extract_doc extract_doc ( doc : str , title : str ) get_bbox_connections get_bbox_connections ( bbox_3d_proj : np . ndarray ) bbox_3d_proj: [..., B, (x,y)] return lines: [..., ((x1,x2), (y1,y2)), 12] get_meta_dict get_meta_dict ( obj ) int_str_cocvt int_str_cocvt ( ref_iterable : Iterable [ str ], query : Union [ int , str ], return_index = False , process_func : Callable = None ) is_image is_image ( array ) modify_class_id modify_class_id ( dict_list : list [ dict [ int , Any ]], modify_class_id_pairs : list [ tuple [ int ]]) read_file_as_str read_file_as_str ( file_path ) rebind_methods rebind_methods ( obj , method_name : Union [ str , Callable ], new_func : Callable ) search_in_dict search_in_dict ( _dict : dict [ KT , VT ], key : Union [ int , str ], process_func : Callable = None ) serialize_object serialize_object ( file_path , obj ) test_pickleable test_pickleable ( obj ) write_str_to_file write_str_to_file ( file_path , string )","title":"utils"},{"location":"md/core/utils/#utils","text":"","title":"utils"},{"location":"md/core/utils/#core.utils.COLKETT","text":"COLKETT = TypeVar ( 'COLKETT' , int , str )","title":"COLKETT"},{"location":"md/core/utils/#core.utils.ITEM","text":"ITEM = TypeVar ( 'ITEM' )","title":"ITEM"},{"location":"md/core/utils/#core.utils.KT","text":"KT = TypeVar ( 'KT' )","title":"KT"},{"location":"md/core/utils/#core.utils.ROWKEYT","text":"ROWKEYT = TypeVar ( 'ROWKEYT' , int , str )","title":"ROWKEYT"},{"location":"md/core/utils/#core.utils.VT","text":"VT = TypeVar ( 'VT' )","title":"VT"},{"location":"md/core/utils/#core.utils.JsonIO","text":"","title":"JsonIO"},{"location":"md/core/utils/#core.utils.JsonIO.Stream","text":"","title":"Stream"},{"location":"md/core/utils/#core.utils.JsonIO.Stream._closed","text":"_closed = True","title":"_closed"},{"location":"md/core/utils/#core.utils.JsonIO.Stream.buffer","text":"buffer = ''","title":"buffer"},{"location":"md/core/utils/#core.utils.JsonIO.Stream.buffer_length","text":"buffer_length = buffer_length","title":"buffer_length"},{"location":"md/core/utils/#core.utils.JsonIO.Stream.closed","text":"closed","title":"closed"},{"location":"md/core/utils/#core.utils.JsonIO.Stream.path","text":"path = path","title":"path"},{"location":"md/core/utils/#core.utils.JsonIO.Stream.__del__","text":"__del__ ()","title":"__del__()"},{"location":"md/core/utils/#core.utils.JsonIO.Stream.__init__","text":"__init__ ( path , open = False , buffer_length = 100000 ) -> None","title":"__init__()"},{"location":"md/core/utils/#core.utils.JsonIO.Stream.close","text":"close ()","title":"close()"},{"location":"md/core/utils/#core.utils.JsonIO.Stream.open","text":"open ()","title":"open()"},{"location":"md/core/utils/#core.utils.JsonIO.Stream.save_buffer","text":"save_buffer ()","title":"save_buffer()"},{"location":"md/core/utils/#core.utils.JsonIO.Stream.write","text":"write ( to_dump_dict )","title":"write()"},{"location":"md/core/utils/#core.utils.JsonIO._MyEncoder","text":"Bases: JSONEncoder","title":"_MyEncoder"},{"location":"md/core/utils/#core.utils.JsonIO._MyEncoder.FORMAT_SPEC","text":"FORMAT_SPEC = '@@ {} @@'","title":"FORMAT_SPEC"},{"location":"md/core/utils/#core.utils.JsonIO._MyEncoder.regex","text":"regex = re . compile ( FORMAT_SPEC . format ( '( \\\\ d+)' ))","title":"regex"},{"location":"md/core/utils/#core.utils.JsonIO._MyEncoder.__init__","text":"__init__ ( ** kwargs )","title":"__init__()"},{"location":"md/core/utils/#core.utils.JsonIO._MyEncoder.default","text":"default ( obj )","title":"default()"},{"location":"md/core/utils/#core.utils.JsonIO._MyEncoder.encode","text":"encode ( obj )","title":"encode()"},{"location":"md/core/utils/#core.utils.JsonIO._NoIndent","text":"Bases: object Value wrapper.","title":"_NoIndent"},{"location":"md/core/utils/#core.utils.JsonIO._NoIndent.value","text":"value = value","title":"value"},{"location":"md/core/utils/#core.utils.JsonIO._NoIndent.__init__","text":"__init__ ( value )","title":"__init__()"},{"location":"md/core/utils/#core.utils.JsonIO._dumps","text":"_dumps ( to_dump_dict , regard_list_as_array = False )","title":"_dumps()"},{"location":"md/core/utils/#core.utils.JsonIO.create_stream","text":"create_stream ( path )","title":"create_stream()"},{"location":"md/core/utils/#core.utils.JsonIO.dump_json","text":"dump_json ( path , to_dump_dict , regard_list_as_array = False )","title":"dump_json()"},{"location":"md/core/utils/#core.utils.JsonIO.load_json","text":"load_json ( path , format = True , cvt_list_to_array = True )","title":"load_json()"},{"location":"md/core/utils/#core.utils.Table","text":"Bases: Generic [ ROWKEYT , COLKETT , ITEM ]","title":"Table"},{"location":"md/core/utils/#core.utils.Table--_1","text":"table = Table() table.add_column(\"Name\") table.add_column(\"Age\") table.add_row(\"Row1\") table.add_row(\"Row2\")","title":"\u4f7f\u7528\u793a\u4f8b"},{"location":"md/core/utils/#core.utils.Table--_2","text":"table[\"Row1\", \"Name\"] = \"Alice\" table[\"Row1\", \"Age\"] = 25 table[\"Row2\", \"Name\"] = \"Bob\" table[\"Row2\", \"Age\"] = 30 print(table.get_row(\"Row1\")) # \u8f93\u51fa: {'Name': ['Alice'], 'Age': [25]} print(table.get_column(\"Age\")) # \u8f93\u51fa: {'Row1': [25], 'Row2': [30]}","title":"\u589e\u52a0\u6570\u636e"},{"location":"md/core/utils/#core.utils.Table--_3","text":"del table[\"Row1\", \"Age\"] print(table.get_row(\"Row1\")) # \u8f93\u51fa: {'Name': ['Alice'], 'Age': []}","title":"\u5220\u9664\u6570\u636e"},{"location":"md/core/utils/#core.utils.Table.KW_EMPTY","text":"KW_EMPTY = 'empty'","title":"KW_EMPTY"},{"location":"md/core/utils/#core.utils.Table.KW_col_name_type","text":"KW_col_name_type = 'col_name_type'","title":"KW_col_name_type"},{"location":"md/core/utils/#core.utils.Table.KW_col_names","text":"KW_col_names = 'col_names'","title":"KW_col_names"},{"location":"md/core/utils/#core.utils.Table.KW_data","text":"KW_data = 'data'","title":"KW_data"},{"location":"md/core/utils/#core.utils.Table.KW_default_value_type","text":"KW_default_value_type = 'default_value_type'","title":"KW_default_value_type"},{"location":"md/core/utils/#core.utils.Table.KW_row_name_type","text":"KW_row_name_type = 'row_name_type'","title":"KW_row_name_type"},{"location":"md/core/utils/#core.utils.Table.KW_row_names","text":"KW_row_names = 'row_names'","title":"KW_row_names"},{"location":"md/core/utils/#core.utils.Table.col_name_type","text":"col_name_type","title":"col_name_type"},{"location":"md/core/utils/#core.utils.Table.col_names","text":"col_names","title":"col_names"},{"location":"md/core/utils/#core.utils.Table.data","text":"data","title":"data"},{"location":"md/core/utils/#core.utils.Table.default_value_type","text":"default_value_type","title":"default_value_type"},{"location":"md/core/utils/#core.utils.Table.empty","text":"empty","title":"empty"},{"location":"md/core/utils/#core.utils.Table.row_name_type","text":"row_name_type","title":"row_name_type"},{"location":"md/core/utils/#core.utils.Table.row_names","text":"row_names","title":"row_names"},{"location":"md/core/utils/#core.utils.Table.__contains__","text":"__contains__ ( item )","title":"__contains__()"},{"location":"md/core/utils/#core.utils.Table.__getitem__","text":"__getitem__ ( keys : Union [ int , str , tuple [ Union [ int , str ]]])","title":"__getitem__()"},{"location":"md/core/utils/#core.utils.Table.__init__","text":"__init__ ( data : dict = None , * , row_names : list [ ROWKEYT ] = None , col_names : list [ COLKETT ] = None , default_value_type : type [ ITEM ] = None , row_name_type = str , col_name_type = str )","title":"__init__()"},{"location":"md/core/utils/#core.utils.Table.__iter__","text":"__iter__ ()","title":"__iter__()"},{"location":"md/core/utils/#core.utils.Table.__len__","text":"__len__ ()","title":"__len__()"},{"location":"md/core/utils/#core.utils.Table.__setitem__","text":"__setitem__ ( keys : tuple [ Union [ int , str ]], value : Union [ ITEM , dict [ ROWKEYT , dict [ COLKETT , ITEM ]], Table [ ROWKEYT , COLKETT , ITEM ]] = None )","title":"__setitem__()"},{"location":"md/core/utils/#core.utils.Table.__str__","text":"__str__ () -> str","title":"__str__()"},{"location":"md/core/utils/#core.utils.Table._col_name_filter","text":"_col_name_filter ( col_name : COLKETT ) -> COLKETT","title":"_col_name_filter()"},{"location":"md/core/utils/#core.utils.Table._row_name_filter","text":"_row_name_filter ( row_name : ROWKEYT ) -> ROWKEYT","title":"_row_name_filter()"},{"location":"md/core/utils/#core.utils.Table.add_column","text":"add_column ( col_name : COLKETT , exist_ok = False )","title":"add_column()"},{"location":"md/core/utils/#core.utils.Table.add_row","text":"add_row ( row_name : ROWKEYT , exist_ok = False )","title":"add_row()"},{"location":"md/core/utils/#core.utils.Table.assert_default_value_type","text":"assert_default_value_type ( value )","title":"assert_default_value_type()"},{"location":"md/core/utils/#core.utils.Table.clean_invalid","text":"clean_invalid ( judge_invalid_func : Callable )","title":"clean_invalid()"},{"location":"md/core/utils/#core.utils.Table.clear","text":"clear ()","title":"clear()"},{"location":"md/core/utils/#core.utils.Table.from_dict","text":"from_dict ( dict_ : dict )","title":"from_dict()"},{"location":"md/core/utils/#core.utils.Table.from_json","text":"from_json ( path )","title":"from_json()"},{"location":"md/core/utils/#core.utils.Table.gen_default_value","text":"gen_default_value () -> ITEM","title":"gen_default_value()"},{"location":"md/core/utils/#core.utils.Table.get_column","text":"get_column ( col_name : Union [ int , str ]) -> dict [ ROWKEYT , ITEM ]","title":"get_column()"},{"location":"md/core/utils/#core.utils.Table.get_row","text":"get_row ( row_name : Union [ int , str ]) -> dict [ COLKETT , ITEM ]","title":"get_row()"},{"location":"md/core/utils/#core.utils.Table.get_type","text":"get_type ( table_dict , default_row_type = str , default_col_type = str )","title":"get_type()"},{"location":"md/core/utils/#core.utils.Table.items","text":"items ()","title":"items()"},{"location":"md/core/utils/#core.utils.Table.keys","text":"keys ()","title":"keys()"},{"location":"md/core/utils/#core.utils.Table.merge","text":"merge ( other : dict [ str , dict [ str , ITEM ]], merge_func : Callable = None )","title":"merge()"},{"location":"md/core/utils/#core.utils.Table.move_column","text":"move_column ( col_name : Union [ int , str ], new_name : Union [ int , str ])","title":"move_column()"},{"location":"md/core/utils/#core.utils.Table.move_row","text":"move_row ( row_name : Union [ int , str ], new_name : Union [ int , str ])","title":"move_row()"},{"location":"md/core/utils/#core.utils.Table.remove_column","text":"remove_column ( col_name : Union [ int , str ], not_exist_ok = False )","title":"remove_column()"},{"location":"md/core/utils/#core.utils.Table.remove_row","text":"remove_row ( row_name : Union [ int , str ], not_exist_ok = False )","title":"remove_row()"},{"location":"md/core/utils/#core.utils.Table.resort_column","text":"resort_column ( new_col_names : list [ Union [ int , str ]])","title":"resort_column()"},{"location":"md/core/utils/#core.utils.Table.resort_row","text":"resort_row ( new_row_names : list [ Union [ int , str ]])","title":"resort_row()"},{"location":"md/core/utils/#core.utils.Table.save","text":"save ( path )","title":"save()"},{"location":"md/core/utils/#core.utils.Table.set_column","text":"set_column ( col_name : Union [ int , str ], col : dict [ ROWKEYT , ITEM ])","title":"set_column()"},{"location":"md/core/utils/#core.utils.Table.set_row","text":"set_row ( row_name : Union [ int , str ], row : dict [ COLKETT , ITEM ])","title":"set_row()"},{"location":"md/core/utils/#core.utils.Table.sort","text":"sort ( key : Callable = None , reverse : bool = False )","title":"sort()"},{"location":"md/core/utils/#core.utils.Table.to_dict","text":"to_dict ()","title":"to_dict()"},{"location":"md/core/utils/#core.utils.Table.to_json","text":"to_json ( path , table : Table )","title":"to_json()"},{"location":"md/core/utils/#core.utils.Table.tranverse","text":"tranverse ( with_key = False )","title":"tranverse()"},{"location":"md/core/utils/#core.utils.Table.update","text":"update ( other : Union [ dict [ ROWKEYT , dict [ COLKETT , ITEM ]], Table [ ROWKEYT , COLKETT , ITEM ]])","title":"update()"},{"location":"md/core/utils/#core.utils.Table.values","text":"values ()","title":"values()"},{"location":"md/core/utils/#core.utils._ignore_warning","text":"_ignore_warning ( func , category = Warning )","title":"_ignore_warning()"},{"location":"md/core/utils/#core.utils.deserialize_object","text":"deserialize_object ( serialized_file_path )","title":"deserialize_object()"},{"location":"md/core/utils/#core.utils.extract_doc","text":"extract_doc ( doc : str , title : str )","title":"extract_doc()"},{"location":"md/core/utils/#core.utils.get_bbox_connections","text":"get_bbox_connections ( bbox_3d_proj : np . ndarray ) bbox_3d_proj: [..., B, (x,y)] return lines: [..., ((x1,x2), (y1,y2)), 12]","title":"get_bbox_connections()"},{"location":"md/core/utils/#core.utils.get_meta_dict","text":"get_meta_dict ( obj )","title":"get_meta_dict()"},{"location":"md/core/utils/#core.utils.int_str_cocvt","text":"int_str_cocvt ( ref_iterable : Iterable [ str ], query : Union [ int , str ], return_index = False , process_func : Callable = None )","title":"int_str_cocvt()"},{"location":"md/core/utils/#core.utils.is_image","text":"is_image ( array )","title":"is_image()"},{"location":"md/core/utils/#core.utils.modify_class_id","text":"modify_class_id ( dict_list : list [ dict [ int , Any ]], modify_class_id_pairs : list [ tuple [ int ]])","title":"modify_class_id()"},{"location":"md/core/utils/#core.utils.read_file_as_str","text":"read_file_as_str ( file_path )","title":"read_file_as_str()"},{"location":"md/core/utils/#core.utils.rebind_methods","text":"rebind_methods ( obj , method_name : Union [ str , Callable ], new_func : Callable )","title":"rebind_methods()"},{"location":"md/core/utils/#core.utils.search_in_dict","text":"search_in_dict ( _dict : dict [ KT , VT ], key : Union [ int , str ], process_func : Callable = None )","title":"search_in_dict()"},{"location":"md/core/utils/#core.utils.serialize_object","text":"serialize_object ( file_path , obj )","title":"serialize_object()"},{"location":"md/core/utils/#core.utils.test_pickleable","text":"test_pickleable ( obj )","title":"test_pickleable()"},{"location":"md/core/utils/#core.utils.write_str_to_file","text":"write_str_to_file ( file_path , string )","title":"write_str_to_file()"},{"location":"md/create_6d_posture_dataset/capturing/","text":"capturing record2.py Main Function for recording a video sequence into cad (color-aligned-to-depth) images and depth images Using librealsense SDK 2.0 with pyrealsense2 for SR300 and D series cameras BASE_FRAME_ARUCO_NUM module-attribute BASE_FRAME_ARUCO_NUM = 8 BUFFER_MAX_LENGTH module-attribute BUFFER_MAX_LENGTH = 9 DELTA_THRESHOLD module-attribute DELTA_THRESHOLD = 15 FIRST_FRAME_ARUCO_NUM module-attribute FIRST_FRAME_ARUCO_NUM = 12 LPLC_THRESHOLD module-attribute LPLC_THRESHOLD = 0.0012 NEW_FRAME_MUL module-attribute NEW_FRAME_MUL = 2.0 RECORD_LENGTH module-attribute RECORD_LENGTH = 80 SINGLE_BASE_FRAME_ARUCO_NUM module-attribute SINGLE_BASE_FRAME_ARUCO_NUM = 3 STOP_BLACK_TIME module-attribute STOP_BLACK_TIME = 3 STOP_COLOR_THRESHOLD module-attribute STOP_COLOR_THRESHOLD = 25 TEST module-attribute TEST = False WAIT_LENGTH module-attribute WAIT_LENGTH = 5 Capturing aruco_detector instance-attribute aruco_detector = aruco_detector aruco_dict_list instance-attribute aruco_dict_list = [] color_image_list instance-attribute color_image_list = [] data_recorder instance-attribute data_recorder = data_recorder depth_frame_list instance-attribute depth_frame_list = [] ignore_stable instance-attribute ignore_stable = False info_txt instance-attribute info_txt : str = '' is_waiting property is_waiting keep_at_last_position instance-attribute keep_at_last_position = True model_manager instance-attribute model_manager = model_manager obj_exanple_img_dict instance-attribute obj_exanple_img_dict = {} record_pos_image instance-attribute record_pos_image = None record_pos_list instance-attribute record_pos_list = [] record_pos_list_updated instance-attribute record_pos_list_updated = True rs_camera property writable rs_camera this_color instance-attribute this_color : np . ndarray = None this_depth_frame instance-attribute this_depth_frame : np . ndarray = None this_floor_aruco_corners property this_floor_aruco_corners this_floor_aruco_dict instance-attribute this_floor_aruco_dict : dict [ int , np . ndarray ] = None this_other_aruco_corners property this_other_aruco_corners this_other_aruco_dict instance-attribute this_other_aruco_dict : dict [ int , np . ndarray ] = None trans_mat_list instance-attribute trans_mat_list = [] __init__ __init__ ( data_recorder : DataRecorder , aruco_detector : ArucoDetector , model_manager : ModelManager , rs_camera : RsCamera = None ) -> None process_buffer process_buffer () \u6dfb\u52a0\u5230\u7f13\u51b2\u533a process_one_frame process_one_frame ( color , depth_frame ) return color_image, depth_frame, info_txt pushback_to_record_pos_list pushback_to_record_pos_list ( record_pos ) read_trans_mats read_trans_mats () start start ( break_callback , record_gate = True ) update_record_pos_image update_record_pos_image ( H , W ) visualise visualise () Motion angular_position instance-attribute angular_position = np . zeros ( 3 ) angular_velocity instance-attribute angular_velocity = np . zeros ( 3 ) g instance-attribute g = 9.798 imu_sensor instance-attribute imu_sensor = None imu_start_loop_time instance-attribute imu_start_loop_time = time . time () is_stable property is_stable \u662f\u5426\u662f\u7a33\u5b9a\u72b6\u6001 last_a_time instance-attribute last_a_time = 0 last_g_time instance-attribute last_g_time = 0 last_moving_time instance-attribute last_moving_time = 0 position instance-attribute position = np . zeros ( 3 ) stable_gyro_threshold instance-attribute stable_gyro_threshold = 0.1 stable_time_threshold instance-attribute stable_time_threshold = 500 this_time instance-attribute this_time = 0 velocity instance-attribute velocity = np . zeros ( 3 ) __init__ __init__ ( sensor , imu_calibration : Union [ str , dict ] = None ) -> None cal_position cal_position ( frame ) imu_callback imu_callback ( frame ) \u56de\u8c03\u51fd\u6570 read_calibrate read_calibrate ( path ) \u8bfb\u53d6\u6821\u51c6\u77e9\u9635 RsCamera MODE_CALI class-attribute instance-attribute MODE_CALI = 0 MODE_DATA class-attribute instance-attribute MODE_DATA = 1 align instance-attribute align = rs . align ( align_to ) call_num instance-attribute call_num = 0 color_frame instance-attribute color_frame = None color_sensor instance-attribute color_sensor = rs . color_sensor ( sensors [ 1 ]) config instance-attribute config = rs . config () decimation instance-attribute decimation = rs . decimation_filter () depth_frame instance-attribute depth_frame = None depth_sensor instance-attribute depth_sensor = rs . depth_sensor ( sensors [ 0 ]) device instance-attribute device = self . pipeline_profile . get_device () fwd_disparity instance-attribute fwd_disparity = rs . disparity_transform ( True ) hole_filling instance-attribute hole_filling = rs . hole_filling_filter () intr instance-attribute intr = CameraIntr . from_json ( camera_parameters ) inv_disparity instance-attribute inv_disparity = rs . disparity_transform ( False ) mode instance-attribute mode = mode motion_module instance-attribute motion_module = Motion ( sensors [ 2 ], imu_calibration ) pipeline instance-attribute pipeline = rs . pipeline () pipeline_profile instance-attribute pipeline_profile = self . config . resolve ( self . pipeline ) profile instance-attribute profile = self . pipeline . start ( self . config ) spatial instance-attribute spatial = rs . spatial_filter () start_time instance-attribute start_time = 0 temporal instance-attribute temporal = rs . temporal_filter () __init__ __init__ ( mode , imu_calibration = None ) -> None get_frames get_frames () get_corner_dict get_corner_dict ( img : np . ndarray ) -> tuple [ dict [ int , np . ndarray ], np . ndarray , bool ] multiframe_distortion_correction multiframe_distortion_correction ( color_list : list [ np . ndarray ], image_size ) -> np . ndarray correct distortion of multiframe color_list: list of color image image_size: size of image","title":"capturing"},{"location":"md/create_6d_posture_dataset/capturing/#capturing","text":"","title":"capturing"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing--record2py","text":"Main Function for recording a video sequence into cad (color-aligned-to-depth) images and depth images Using librealsense SDK 2.0 with pyrealsense2 for SR300 and D series cameras","title":"record2.py"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.BASE_FRAME_ARUCO_NUM","text":"BASE_FRAME_ARUCO_NUM = 8","title":"BASE_FRAME_ARUCO_NUM"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.BUFFER_MAX_LENGTH","text":"BUFFER_MAX_LENGTH = 9","title":"BUFFER_MAX_LENGTH"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.DELTA_THRESHOLD","text":"DELTA_THRESHOLD = 15","title":"DELTA_THRESHOLD"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.FIRST_FRAME_ARUCO_NUM","text":"FIRST_FRAME_ARUCO_NUM = 12","title":"FIRST_FRAME_ARUCO_NUM"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.LPLC_THRESHOLD","text":"LPLC_THRESHOLD = 0.0012","title":"LPLC_THRESHOLD"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.NEW_FRAME_MUL","text":"NEW_FRAME_MUL = 2.0","title":"NEW_FRAME_MUL"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.RECORD_LENGTH","text":"RECORD_LENGTH = 80","title":"RECORD_LENGTH"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.SINGLE_BASE_FRAME_ARUCO_NUM","text":"SINGLE_BASE_FRAME_ARUCO_NUM = 3","title":"SINGLE_BASE_FRAME_ARUCO_NUM"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.STOP_BLACK_TIME","text":"STOP_BLACK_TIME = 3","title":"STOP_BLACK_TIME"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.STOP_COLOR_THRESHOLD","text":"STOP_COLOR_THRESHOLD = 25","title":"STOP_COLOR_THRESHOLD"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.TEST","text":"TEST = False","title":"TEST"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.WAIT_LENGTH","text":"WAIT_LENGTH = 5","title":"WAIT_LENGTH"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing","text":"","title":"Capturing"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.aruco_detector","text":"aruco_detector = aruco_detector","title":"aruco_detector"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.aruco_dict_list","text":"aruco_dict_list = []","title":"aruco_dict_list"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.color_image_list","text":"color_image_list = []","title":"color_image_list"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.data_recorder","text":"data_recorder = data_recorder","title":"data_recorder"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.depth_frame_list","text":"depth_frame_list = []","title":"depth_frame_list"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.ignore_stable","text":"ignore_stable = False","title":"ignore_stable"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.info_txt","text":"info_txt : str = ''","title":"info_txt"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.is_waiting","text":"is_waiting","title":"is_waiting"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.keep_at_last_position","text":"keep_at_last_position = True","title":"keep_at_last_position"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.model_manager","text":"model_manager = model_manager","title":"model_manager"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.obj_exanple_img_dict","text":"obj_exanple_img_dict = {}","title":"obj_exanple_img_dict"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.record_pos_image","text":"record_pos_image = None","title":"record_pos_image"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.record_pos_list","text":"record_pos_list = []","title":"record_pos_list"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.record_pos_list_updated","text":"record_pos_list_updated = True","title":"record_pos_list_updated"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.rs_camera","text":"rs_camera","title":"rs_camera"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.this_color","text":"this_color : np . ndarray = None","title":"this_color"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.this_depth_frame","text":"this_depth_frame : np . ndarray = None","title":"this_depth_frame"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.this_floor_aruco_corners","text":"this_floor_aruco_corners","title":"this_floor_aruco_corners"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.this_floor_aruco_dict","text":"this_floor_aruco_dict : dict [ int , np . ndarray ] = None","title":"this_floor_aruco_dict"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.this_other_aruco_corners","text":"this_other_aruco_corners","title":"this_other_aruco_corners"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.this_other_aruco_dict","text":"this_other_aruco_dict : dict [ int , np . ndarray ] = None","title":"this_other_aruco_dict"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.trans_mat_list","text":"trans_mat_list = []","title":"trans_mat_list"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.__init__","text":"__init__ ( data_recorder : DataRecorder , aruco_detector : ArucoDetector , model_manager : ModelManager , rs_camera : RsCamera = None ) -> None","title":"__init__()"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.process_buffer","text":"process_buffer () \u6dfb\u52a0\u5230\u7f13\u51b2\u533a","title":"process_buffer()"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.process_one_frame","text":"process_one_frame ( color , depth_frame )","title":"process_one_frame()"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.process_one_frame--return","text":"color_image, depth_frame, info_txt","title":"return"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.pushback_to_record_pos_list","text":"pushback_to_record_pos_list ( record_pos )","title":"pushback_to_record_pos_list()"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.read_trans_mats","text":"read_trans_mats ()","title":"read_trans_mats()"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.start","text":"start ( break_callback , record_gate = True )","title":"start()"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.update_record_pos_image","text":"update_record_pos_image ( H , W )","title":"update_record_pos_image()"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Capturing.visualise","text":"visualise ()","title":"visualise()"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Motion","text":"","title":"Motion"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Motion.angular_position","text":"angular_position = np . zeros ( 3 )","title":"angular_position"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Motion.angular_velocity","text":"angular_velocity = np . zeros ( 3 )","title":"angular_velocity"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Motion.g","text":"g = 9.798","title":"g"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Motion.imu_sensor","text":"imu_sensor = None","title":"imu_sensor"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Motion.imu_start_loop_time","text":"imu_start_loop_time = time . time ()","title":"imu_start_loop_time"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Motion.is_stable","text":"is_stable \u662f\u5426\u662f\u7a33\u5b9a\u72b6\u6001","title":"is_stable"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Motion.last_a_time","text":"last_a_time = 0","title":"last_a_time"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Motion.last_g_time","text":"last_g_time = 0","title":"last_g_time"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Motion.last_moving_time","text":"last_moving_time = 0","title":"last_moving_time"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Motion.position","text":"position = np . zeros ( 3 )","title":"position"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Motion.stable_gyro_threshold","text":"stable_gyro_threshold = 0.1","title":"stable_gyro_threshold"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Motion.stable_time_threshold","text":"stable_time_threshold = 500","title":"stable_time_threshold"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Motion.this_time","text":"this_time = 0","title":"this_time"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Motion.velocity","text":"velocity = np . zeros ( 3 )","title":"velocity"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Motion.__init__","text":"__init__ ( sensor , imu_calibration : Union [ str , dict ] = None ) -> None","title":"__init__()"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Motion.cal_position","text":"cal_position ( frame )","title":"cal_position()"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Motion.imu_callback","text":"imu_callback ( frame ) \u56de\u8c03\u51fd\u6570","title":"imu_callback()"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.Motion.read_calibrate","text":"read_calibrate ( path ) \u8bfb\u53d6\u6821\u51c6\u77e9\u9635","title":"read_calibrate()"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.RsCamera","text":"","title":"RsCamera"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.RsCamera.MODE_CALI","text":"MODE_CALI = 0","title":"MODE_CALI"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.RsCamera.MODE_DATA","text":"MODE_DATA = 1","title":"MODE_DATA"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.RsCamera.align","text":"align = rs . align ( align_to )","title":"align"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.RsCamera.call_num","text":"call_num = 0","title":"call_num"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.RsCamera.color_frame","text":"color_frame = None","title":"color_frame"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.RsCamera.color_sensor","text":"color_sensor = rs . color_sensor ( sensors [ 1 ])","title":"color_sensor"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.RsCamera.config","text":"config = rs . config ()","title":"config"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.RsCamera.decimation","text":"decimation = rs . decimation_filter ()","title":"decimation"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.RsCamera.depth_frame","text":"depth_frame = None","title":"depth_frame"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.RsCamera.depth_sensor","text":"depth_sensor = rs . depth_sensor ( sensors [ 0 ])","title":"depth_sensor"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.RsCamera.device","text":"device = self . pipeline_profile . get_device ()","title":"device"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.RsCamera.fwd_disparity","text":"fwd_disparity = rs . disparity_transform ( True )","title":"fwd_disparity"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.RsCamera.hole_filling","text":"hole_filling = rs . hole_filling_filter ()","title":"hole_filling"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.RsCamera.intr","text":"intr = CameraIntr . from_json ( camera_parameters )","title":"intr"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.RsCamera.inv_disparity","text":"inv_disparity = rs . disparity_transform ( False )","title":"inv_disparity"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.RsCamera.mode","text":"mode = mode","title":"mode"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.RsCamera.motion_module","text":"motion_module = Motion ( sensors [ 2 ], imu_calibration )","title":"motion_module"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.RsCamera.pipeline","text":"pipeline = rs . pipeline ()","title":"pipeline"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.RsCamera.pipeline_profile","text":"pipeline_profile = self . config . resolve ( self . pipeline )","title":"pipeline_profile"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.RsCamera.profile","text":"profile = self . pipeline . start ( self . config )","title":"profile"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.RsCamera.spatial","text":"spatial = rs . spatial_filter ()","title":"spatial"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.RsCamera.start_time","text":"start_time = 0","title":"start_time"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.RsCamera.temporal","text":"temporal = rs . temporal_filter ()","title":"temporal"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.RsCamera.__init__","text":"__init__ ( mode , imu_calibration = None ) -> None","title":"__init__()"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.RsCamera.get_frames","text":"get_frames ()","title":"get_frames()"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.get_corner_dict","text":"get_corner_dict ( img : np . ndarray ) -> tuple [ dict [ int , np . ndarray ], np . ndarray , bool ]","title":"get_corner_dict()"},{"location":"md/create_6d_posture_dataset/capturing/#create_6d_posture_dataset.capturing.multiframe_distortion_correction","text":"multiframe_distortion_correction ( color_list : list [ np . ndarray ], image_size ) -> np . ndarray correct distortion of multiframe color_list: list of color image image_size: size of image","title":"multiframe_distortion_correction()"},{"location":"md/create_6d_posture_dataset/data_manager/","text":"data_manager VDMT module-attribute VDMT = TypeVar ( 'VDMT' , bound = Any ) CommonData Bases: DatasetNode [ FilesCluster , 'CommonData', VDMT ] , Generic [ VDMT ] init_clusters_hook init_clusters_hook () DataRecorder Bases: CommonData [ FrameMeta ] , Dataset SPLIT_PARA class-attribute instance-attribute SPLIT_PARA = { 'default' : []} category_idx_range property category_idx_range current_category_index property current_category_index current_category_name property current_category_name current_categroy_num property current_categroy_num is_all_recorded property is_all_recorded add_skip_seg add_skip_seg ( seg ) clear_skip_segs clear_skip_segs () dec_idx dec_idx () get_category_idx get_category_idx ( data_i ) inc_idx inc_idx () init_clusters_hook init_clusters_hook () init_dataset_attr_hook init_dataset_attr_hook () read read ( data_i , * , force = False , ** other_paras ) -> FrameMeta read_in_category_range read_in_category_range ( start , end ) rebuild rebuild ( force = False ) save_frames save_frames ( c , d , t ) skip_to_seg skip_to_seg () \u8df3\u8fc7\uff0c\u76f4\u5230\u5206\u6bb5\u70b9 update_overview update_overview ( log_type , src , dst , value , cluster ) write write ( dst : int , value : FrameMeta , * , force = False , ** other_paras ) -> None ElementsWithCategory Bases: UnifiedFileCluster [ UnifiedFilesHandle , 'ElementsWithCategory', DataRecorder , ndarray ] current_category_range property current_category_range in_current_category in_current_category () EnumElements Bases: UnifiedFileCluster [ UnifiedFilesHandle , 'EnumElements', 'ModelManager', VDMT ] enums property enums cvt_key cvt_key ( key ) deformat_corename deformat_corename ( corename : str ) -> int dulmap_id_name dulmap_id_name ( enum : Union [ str , int ]) format_corename format_corename ( data_i : int ) FrameMeta color instance-attribute color : np . ndarray = rgb depth instance-attribute depth : np . ndarray = depth intr_M instance-attribute intr_M : np . ndarray = intr_M trans_mat_Cn2C0 instance-attribute trans_mat_Cn2C0 : np . ndarray = trans_mat_Cn2C0 __init__ __init__ ( trans_mat_Cn2C0 , rgb = None , depth = None , intr_M = None ) -> None ModelManager Bases: CommonData ARUCO_CENTERS class-attribute instance-attribute ARUCO_CENTERS = 'aruco_centers' ARUCO_USED_TIMES class-attribute instance-attribute ARUCO_USED_TIMES = 'aruco_used_times' FLOOR_COLOR class-attribute instance-attribute FLOOR_COLOR = 'floor_color' PLANE_EQUATION class-attribute instance-attribute PLANE_EQUATION = 'plane_equation' TRANS_MAT_C0_2_SCS class-attribute instance-attribute TRANS_MAT_C0_2_SCS = 'trans_mat_C0_2_SCS' VOR_POLYS_COORD class-attribute instance-attribute VOR_POLYS_COORD = 'vor_polys_coord' std_meshes_dir property std_meshes_dir std_meshes_enums property std_meshes_enums std_meshes_names property std_meshes_names : tuple [ str ] init_clusters_hook init_clusters_hook () ProcessData Bases: DictFile [ DisunifiedFilesHandle , 'ProcessData', ModelManager ] ARUCO_CENTERS class-attribute instance-attribute ARUCO_CENTERS = 'aruco_centers' ARUCO_USED_TIMES class-attribute instance-attribute ARUCO_USED_TIMES = 'aruco_used_times' FLOOR_COLOR class-attribute instance-attribute FLOOR_COLOR = 'floor_color' PLANE_EQUATION class-attribute instance-attribute PLANE_EQUATION = 'plane_equation' TRANS_MAT_C0_2_SCS class-attribute instance-attribute TRANS_MAT_C0_2_SCS = 'trans_mat_C0_2_SCS' VOR_POLYS_COORD class-attribute instance-attribute VOR_POLYS_COORD = 'vor_polys_coord'","title":"data_manager"},{"location":"md/create_6d_posture_dataset/data_manager/#data_manager","text":"","title":"data_manager"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.VDMT","text":"VDMT = TypeVar ( 'VDMT' , bound = Any )","title":"VDMT"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.CommonData","text":"Bases: DatasetNode [ FilesCluster , 'CommonData', VDMT ] , Generic [ VDMT ]","title":"CommonData"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.CommonData.init_clusters_hook","text":"init_clusters_hook ()","title":"init_clusters_hook()"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.DataRecorder","text":"Bases: CommonData [ FrameMeta ] , Dataset","title":"DataRecorder"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.DataRecorder.SPLIT_PARA","text":"SPLIT_PARA = { 'default' : []}","title":"SPLIT_PARA"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.DataRecorder.category_idx_range","text":"category_idx_range","title":"category_idx_range"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.DataRecorder.current_category_index","text":"current_category_index","title":"current_category_index"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.DataRecorder.current_category_name","text":"current_category_name","title":"current_category_name"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.DataRecorder.current_categroy_num","text":"current_categroy_num","title":"current_categroy_num"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.DataRecorder.is_all_recorded","text":"is_all_recorded","title":"is_all_recorded"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.DataRecorder.add_skip_seg","text":"add_skip_seg ( seg )","title":"add_skip_seg()"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.DataRecorder.clear_skip_segs","text":"clear_skip_segs ()","title":"clear_skip_segs()"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.DataRecorder.dec_idx","text":"dec_idx ()","title":"dec_idx()"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.DataRecorder.get_category_idx","text":"get_category_idx ( data_i )","title":"get_category_idx()"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.DataRecorder.inc_idx","text":"inc_idx ()","title":"inc_idx()"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.DataRecorder.init_clusters_hook","text":"init_clusters_hook ()","title":"init_clusters_hook()"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.DataRecorder.init_dataset_attr_hook","text":"init_dataset_attr_hook ()","title":"init_dataset_attr_hook()"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.DataRecorder.read","text":"read ( data_i , * , force = False , ** other_paras ) -> FrameMeta","title":"read()"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.DataRecorder.read_in_category_range","text":"read_in_category_range ( start , end )","title":"read_in_category_range()"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.DataRecorder.rebuild","text":"rebuild ( force = False )","title":"rebuild()"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.DataRecorder.save_frames","text":"save_frames ( c , d , t )","title":"save_frames()"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.DataRecorder.skip_to_seg","text":"skip_to_seg () \u8df3\u8fc7\uff0c\u76f4\u5230\u5206\u6bb5\u70b9","title":"skip_to_seg()"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.DataRecorder.update_overview","text":"update_overview ( log_type , src , dst , value , cluster )","title":"update_overview()"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.DataRecorder.write","text":"write ( dst : int , value : FrameMeta , * , force = False , ** other_paras ) -> None","title":"write()"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.ElementsWithCategory","text":"Bases: UnifiedFileCluster [ UnifiedFilesHandle , 'ElementsWithCategory', DataRecorder , ndarray ]","title":"ElementsWithCategory"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.ElementsWithCategory.current_category_range","text":"current_category_range","title":"current_category_range"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.ElementsWithCategory.in_current_category","text":"in_current_category ()","title":"in_current_category()"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.EnumElements","text":"Bases: UnifiedFileCluster [ UnifiedFilesHandle , 'EnumElements', 'ModelManager', VDMT ]","title":"EnumElements"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.EnumElements.enums","text":"enums","title":"enums"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.EnumElements.cvt_key","text":"cvt_key ( key )","title":"cvt_key()"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.EnumElements.deformat_corename","text":"deformat_corename ( corename : str ) -> int","title":"deformat_corename()"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.EnumElements.dulmap_id_name","text":"dulmap_id_name ( enum : Union [ str , int ])","title":"dulmap_id_name()"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.EnumElements.format_corename","text":"format_corename ( data_i : int )","title":"format_corename()"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.FrameMeta","text":"","title":"FrameMeta"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.FrameMeta.color","text":"color : np . ndarray = rgb","title":"color"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.FrameMeta.depth","text":"depth : np . ndarray = depth","title":"depth"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.FrameMeta.intr_M","text":"intr_M : np . ndarray = intr_M","title":"intr_M"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.FrameMeta.trans_mat_Cn2C0","text":"trans_mat_Cn2C0 : np . ndarray = trans_mat_Cn2C0","title":"trans_mat_Cn2C0"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.FrameMeta.__init__","text":"__init__ ( trans_mat_Cn2C0 , rgb = None , depth = None , intr_M = None ) -> None","title":"__init__()"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.ModelManager","text":"Bases: CommonData","title":"ModelManager"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.ModelManager.ARUCO_CENTERS","text":"ARUCO_CENTERS = 'aruco_centers'","title":"ARUCO_CENTERS"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.ModelManager.ARUCO_USED_TIMES","text":"ARUCO_USED_TIMES = 'aruco_used_times'","title":"ARUCO_USED_TIMES"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.ModelManager.FLOOR_COLOR","text":"FLOOR_COLOR = 'floor_color'","title":"FLOOR_COLOR"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.ModelManager.PLANE_EQUATION","text":"PLANE_EQUATION = 'plane_equation'","title":"PLANE_EQUATION"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.ModelManager.TRANS_MAT_C0_2_SCS","text":"TRANS_MAT_C0_2_SCS = 'trans_mat_C0_2_SCS'","title":"TRANS_MAT_C0_2_SCS"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.ModelManager.VOR_POLYS_COORD","text":"VOR_POLYS_COORD = 'vor_polys_coord'","title":"VOR_POLYS_COORD"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.ModelManager.std_meshes_dir","text":"std_meshes_dir","title":"std_meshes_dir"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.ModelManager.std_meshes_enums","text":"std_meshes_enums","title":"std_meshes_enums"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.ModelManager.std_meshes_names","text":"std_meshes_names : tuple [ str ]","title":"std_meshes_names"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.ModelManager.init_clusters_hook","text":"init_clusters_hook ()","title":"init_clusters_hook()"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.ProcessData","text":"Bases: DictFile [ DisunifiedFilesHandle , 'ProcessData', ModelManager ]","title":"ProcessData"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.ProcessData.ARUCO_CENTERS","text":"ARUCO_CENTERS = 'aruco_centers'","title":"ARUCO_CENTERS"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.ProcessData.ARUCO_USED_TIMES","text":"ARUCO_USED_TIMES = 'aruco_used_times'","title":"ARUCO_USED_TIMES"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.ProcessData.FLOOR_COLOR","text":"FLOOR_COLOR = 'floor_color'","title":"FLOOR_COLOR"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.ProcessData.PLANE_EQUATION","text":"PLANE_EQUATION = 'plane_equation'","title":"PLANE_EQUATION"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.ProcessData.TRANS_MAT_C0_2_SCS","text":"TRANS_MAT_C0_2_SCS = 'trans_mat_C0_2_SCS'","title":"TRANS_MAT_C0_2_SCS"},{"location":"md/create_6d_posture_dataset/data_manager/#create_6d_posture_dataset.data_manager.ProcessData.VOR_POLYS_COORD","text":"VOR_POLYS_COORD = 'vor_polys_coord'","title":"VOR_POLYS_COORD"},{"location":"md/create_6d_posture_dataset/interact_icp/","text":"interact_icp InteractIcp baryline_visible instance-attribute baryline_visible = False ckt instance-attribute ckt = None color_g instance-attribute color_g = InteractIcp . color_generator () contact_pcd instance-attribute contact_pcd = o3d . geometry . PointCloud () cover_data_confirm instance-attribute cover_data_confirm = False current_index instance-attribute current_index = 0 current_pcd property current_pcd current_std_mi property current_std_mi : ModelInfo data_recorder instance-attribute data_recorder = data_recorder icp_trans_dir instance-attribute icp_trans_dir = self . model_manager . icp_trans . data_path icp_unf_pcd_dir instance-attribute icp_unf_pcd_dir = self . model_manager . icp_unf_pcd . data_path is_camera_mode instance-attribute is_camera_mode = False is_mask_visible instance-attribute is_mask_visible = True is_refine_mode instance-attribute is_refine_mode = True model_manager instance-attribute model_manager = model_manager modelbalenceposture instance-attribute modelbalenceposture = ModelBalencePosture () pcd_visible instance-attribute pcd_visible = True place_gen instance-attribute place_gen = None std_meshes_dir instance-attribute std_meshes_dir = self . model_manager . std_meshes_dir std_meshes_enums instance-attribute std_meshes_enums = self . model_manager . std_meshes_enums std_model_baryline instance-attribute std_model_baryline = o3d . geometry . TriangleMesh . create_arrow ( cylinder_radius = 0.002 , cone_radius = 0.004 , cylinder_height = 0.1 , cone_height = 0.02 ) . transform ( Posture ( rvec = np . array ([ 0 , np . pi , 0 ])) . trans_mat ) std_model_frame instance-attribute std_model_frame = o3d . geometry . TriangleMesh . create_coordinate_frame ( size = 40 , origin = [ 0 , 0 , 0 ]) step instance-attribute step = 1.0 trans_with_CCS instance-attribute trans_with_CCS = False view_directions instance-attribute view_directions = [(( 1 , 0 , 0 ), ( 0 , 0 , 1 )), (( - 1 , 0 , 0 ), ( 0 , 0 , 1 )), (( 0 , 1 , 0 ), ( 0 , 0 , 1 )), (( 0 , - 1 , 0 ), ( 0 , 0 , 1 )), (( 0 , 0 , 1 ), ( 1 , 0 , 0 )), (( 0 , 0 , - 1 ), ( 1 , 0 , 0 ))] view_switch instance-attribute view_switch : int = 0 GA_registration GA_registration ( vis ) __init__ __init__ ( data_recorder : DataRecorder , model_manager : ModelManager ) -> None auto_icp auto_icp ( vis ) \u6839\u636e\u7528\u6237\u5b9a\u4e49\u521d\u59cb\u59ff\u6001\u8fdb\u884c\u914d\u51c6 change_background_color change_background_color ( vis ) color_generator staticmethod color_generator () confirm confirm ( vis ) current_std_mi_transform current_std_mi_transform ( vis , T ) gen_cur_std_model_meta gen_cur_std_model_meta () get_O2C0 get_O2C0 () load_data load_data () nearest_points_mean_d nearest_points_mean_d () next_view next_view ( vis ) place_step place_step ( vis ) post_progress post_progress () \u5b8c\u6210\u914d\u51c6\u540e\u7684\u540e\u5904\u7406 pre_progress pre_progress () \u9884\u5904\u7406: 1) \u4fee\u6539\u4e3a\u5e73\u8861\u59ff\u6001 2) \u5e73\u79fb\u5230\u4e2d\u5fc3 print_nearest_points_mean_d print_nearest_points_mean_d ( vis ) refine_mode refine_mode ( vis ) rotate_X_dec rotate_X_dec ( vis ) rotate_X_inc rotate_X_inc ( vis ) rotate_Y_dec rotate_Y_dec ( vis ) rotate_Y_inc rotate_Y_inc ( vis ) rotate_Z_dec rotate_Z_dec ( vis ) rotate_Z_inc rotate_Z_inc ( vis ) set_is_mask_visible set_is_mask_visible ( vis ) set_unfpcd_visible set_unfpcd_visible ( vis ) show_bary_arrow show_bary_arrow ( vis ) show_contact show_contact ( vis ) skip skip ( vis ) start start () switch_to_camera_view_mode switch_to_camera_view_mode ( vis ) switch_to_trans_with_CCS switch_to_trans_with_CCS ( vis ) trans_with_obj_center trans_with_obj_center ( T_center : Posture , vis ) \u4ee5\u7269\u4f53\u4e2d\u5fc3\u7684\u65cb\u8f6c translate_X_dec translate_X_dec ( vis ) translate_X_inc translate_X_inc ( vis ) translate_Y_dec translate_Y_dec ( vis ) translate_Y_inc translate_Y_inc ( vis ) translate_Z_dec translate_Z_dec ( vis ) translate_Z_inc translate_Z_inc ( vis ) MaskBilter SHOW_NUM class-attribute instance-attribute SHOW_NUM = 6 camera_intr instance-attribute camera_intr = CameraIntr . from_json ( os . path . join ( self . data_path , CALI_INTR_FILE )) cur_range property cur_range \u5f53\u524d\u7684\u5e27\u8303\u56f4 data_path instance-attribute data_path = data_recorder . data_path data_recorder instance-attribute data_recorder = data_recorder model_index_range instance-attribute model_index_range = self . data_recorder . category_idx_range selected_depth_masks instance-attribute selected_depth_masks = [] selected_frame_indecies instance-attribute selected_frame_indecies = [] selected_rgbs instance-attribute selected_rgbs = [] selected_view_trans_mats instance-attribute selected_view_trans_mats = [] this_frame_rgb property this_frame_rgb this_view_trans_mat property this_view_trans_mat __init__ __init__ ( data_recorder : DataRecorder ) -> None farthest_point_sample_angle staticmethod farthest_point_sample_angle ( xyz , npoint ) Input: xyz: pointcloud data, [N, 3] npoint: number of samples Return: centroids: sampled pointcloud index, [B, npoint] next_view next_view () \u4e0b\u4e00\u4e2a\u89c6\u89d2 read_rgbs read_rgbs () select_views select_views ( num ) \u9009\u62e9\u89c6\u89d2 set_current_name set_current_name ( name ) show show ( std_model_meta : ModelInfo , is_mask_visible ) ModelBalencePosture POINT_BALENCE_TOL class-attribute instance-attribute POINT_BALENCE_TOL = 0.5 * np . pi / 180 POINT_STABLE_TOL class-attribute instance-attribute POINT_STABLE_TOL = 0.1 * np . pi / 180 current_mi instance-attribute current_mi : ModelInfo = None __init__ __init__ () -> None _angle staticmethod _angle ( vce1 , vec2 ) fall fall ( mi : ModelInfo , contact_dict : dict , step = 1.0 / 180 * np . pi ) step \u6b65\u957f find_all_connected staticmethod find_all_connected ( tri , seed_idx , valid_idx_array ) get_bary_vec get_bary_vec ( mi : ModelInfo , index ) get_contact_point get_contact_point ( mi : ModelInfo ) get_drop_foot staticmethod get_drop_foot ( point , line_p1 , line_p2 ) get_neighbors get_neighbors ( point : np . ndarray , point_list : np . ndarray , r ) get_normal get_normal ( mi : ModelInfo , index ) if_point_stable if_point_stable ( mi : ModelInfo , contact_dict : dict ) \u70b9\u662f\u5426\u7a33\u5b9a\uff0c\u8ba1\u7b97\u8be5\u70b9\u7684\u5939\u89d2\u3001\u9644\u8fd1\u70b9\u7684\u5939\u89d2 place place ( mi : ModelInfo ) point_distance_line staticmethod point_distance_line ( points , lines_point1 , lines_point2 ) points : [P, 3] -> [P, L, 3] lines_point1: [L, 3] -> [P, L, 3] proj_vec staticmethod proj_vec ( vec , n , normal = True ) ModelInfo Bases: MeshMeta avg_dist instance-attribute avg_dist = np . mean ( distances ) barycenter instance-attribute barycenter = self . calc_barycenter ( self . avg_dist * 3 ) pcd instance-attribute pcd = o3d . geometry . PointCloud () __init__ __init__ ( mesh , name = '' , class_id =- 1 , barycenter : np . ndarray = None ) -> None calc_barycenter calc_barycenter ( voxel_size ) transform transform ( posture : Union [ Posture , np . ndarray ], copy = True ) MyGA Bases: GA fit class-attribute instance-attribute fit = run result_precision instance-attribute result_precision = result_precision __init__ __init__ ( func , n_dim , size_pop = 50 , max_iter = 200 , prob_mut = 1 , lb =- 1 , ub = 1 , constraint_eq = [], constraint_ueq = [], precision = 1e-07 , early_stop = None , result_precision = 0.01 ) run run ( max_iter = None )","title":"interact_icp"},{"location":"md/create_6d_posture_dataset/interact_icp/#interact_icp","text":"","title":"interact_icp"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp","text":"","title":"InteractIcp"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.baryline_visible","text":"baryline_visible = False","title":"baryline_visible"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.ckt","text":"ckt = None","title":"ckt"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.color_g","text":"color_g = InteractIcp . color_generator ()","title":"color_g"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.contact_pcd","text":"contact_pcd = o3d . geometry . PointCloud ()","title":"contact_pcd"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.cover_data_confirm","text":"cover_data_confirm = False","title":"cover_data_confirm"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.current_index","text":"current_index = 0","title":"current_index"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.current_pcd","text":"current_pcd","title":"current_pcd"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.current_std_mi","text":"current_std_mi : ModelInfo","title":"current_std_mi"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.data_recorder","text":"data_recorder = data_recorder","title":"data_recorder"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.icp_trans_dir","text":"icp_trans_dir = self . model_manager . icp_trans . data_path","title":"icp_trans_dir"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.icp_unf_pcd_dir","text":"icp_unf_pcd_dir = self . model_manager . icp_unf_pcd . data_path","title":"icp_unf_pcd_dir"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.is_camera_mode","text":"is_camera_mode = False","title":"is_camera_mode"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.is_mask_visible","text":"is_mask_visible = True","title":"is_mask_visible"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.is_refine_mode","text":"is_refine_mode = True","title":"is_refine_mode"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.model_manager","text":"model_manager = model_manager","title":"model_manager"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.modelbalenceposture","text":"modelbalenceposture = ModelBalencePosture ()","title":"modelbalenceposture"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.pcd_visible","text":"pcd_visible = True","title":"pcd_visible"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.place_gen","text":"place_gen = None","title":"place_gen"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.std_meshes_dir","text":"std_meshes_dir = self . model_manager . std_meshes_dir","title":"std_meshes_dir"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.std_meshes_enums","text":"std_meshes_enums = self . model_manager . std_meshes_enums","title":"std_meshes_enums"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.std_model_baryline","text":"std_model_baryline = o3d . geometry . TriangleMesh . create_arrow ( cylinder_radius = 0.002 , cone_radius = 0.004 , cylinder_height = 0.1 , cone_height = 0.02 ) . transform ( Posture ( rvec = np . array ([ 0 , np . pi , 0 ])) . trans_mat )","title":"std_model_baryline"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.std_model_frame","text":"std_model_frame = o3d . geometry . TriangleMesh . create_coordinate_frame ( size = 40 , origin = [ 0 , 0 , 0 ])","title":"std_model_frame"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.step","text":"step = 1.0","title":"step"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.trans_with_CCS","text":"trans_with_CCS = False","title":"trans_with_CCS"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.view_directions","text":"view_directions = [(( 1 , 0 , 0 ), ( 0 , 0 , 1 )), (( - 1 , 0 , 0 ), ( 0 , 0 , 1 )), (( 0 , 1 , 0 ), ( 0 , 0 , 1 )), (( 0 , - 1 , 0 ), ( 0 , 0 , 1 )), (( 0 , 0 , 1 ), ( 1 , 0 , 0 )), (( 0 , 0 , - 1 ), ( 1 , 0 , 0 ))]","title":"view_directions"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.view_switch","text":"view_switch : int = 0","title":"view_switch"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.GA_registration","text":"GA_registration ( vis )","title":"GA_registration()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.__init__","text":"__init__ ( data_recorder : DataRecorder , model_manager : ModelManager ) -> None","title":"__init__()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.auto_icp","text":"auto_icp ( vis ) \u6839\u636e\u7528\u6237\u5b9a\u4e49\u521d\u59cb\u59ff\u6001\u8fdb\u884c\u914d\u51c6","title":"auto_icp()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.change_background_color","text":"change_background_color ( vis )","title":"change_background_color()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.color_generator","text":"color_generator ()","title":"color_generator()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.confirm","text":"confirm ( vis )","title":"confirm()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.current_std_mi_transform","text":"current_std_mi_transform ( vis , T )","title":"current_std_mi_transform()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.gen_cur_std_model_meta","text":"gen_cur_std_model_meta ()","title":"gen_cur_std_model_meta()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.get_O2C0","text":"get_O2C0 ()","title":"get_O2C0()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.load_data","text":"load_data ()","title":"load_data()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.nearest_points_mean_d","text":"nearest_points_mean_d ()","title":"nearest_points_mean_d()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.next_view","text":"next_view ( vis )","title":"next_view()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.place_step","text":"place_step ( vis )","title":"place_step()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.post_progress","text":"post_progress () \u5b8c\u6210\u914d\u51c6\u540e\u7684\u540e\u5904\u7406","title":"post_progress()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.pre_progress","text":"pre_progress () \u9884\u5904\u7406: 1) \u4fee\u6539\u4e3a\u5e73\u8861\u59ff\u6001 2) \u5e73\u79fb\u5230\u4e2d\u5fc3","title":"pre_progress()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.print_nearest_points_mean_d","text":"print_nearest_points_mean_d ( vis )","title":"print_nearest_points_mean_d()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.refine_mode","text":"refine_mode ( vis )","title":"refine_mode()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.rotate_X_dec","text":"rotate_X_dec ( vis )","title":"rotate_X_dec()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.rotate_X_inc","text":"rotate_X_inc ( vis )","title":"rotate_X_inc()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.rotate_Y_dec","text":"rotate_Y_dec ( vis )","title":"rotate_Y_dec()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.rotate_Y_inc","text":"rotate_Y_inc ( vis )","title":"rotate_Y_inc()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.rotate_Z_dec","text":"rotate_Z_dec ( vis )","title":"rotate_Z_dec()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.rotate_Z_inc","text":"rotate_Z_inc ( vis )","title":"rotate_Z_inc()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.set_is_mask_visible","text":"set_is_mask_visible ( vis )","title":"set_is_mask_visible()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.set_unfpcd_visible","text":"set_unfpcd_visible ( vis )","title":"set_unfpcd_visible()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.show_bary_arrow","text":"show_bary_arrow ( vis )","title":"show_bary_arrow()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.show_contact","text":"show_contact ( vis )","title":"show_contact()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.skip","text":"skip ( vis )","title":"skip()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.start","text":"start ()","title":"start()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.switch_to_camera_view_mode","text":"switch_to_camera_view_mode ( vis )","title":"switch_to_camera_view_mode()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.switch_to_trans_with_CCS","text":"switch_to_trans_with_CCS ( vis )","title":"switch_to_trans_with_CCS()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.trans_with_obj_center","text":"trans_with_obj_center ( T_center : Posture , vis ) \u4ee5\u7269\u4f53\u4e2d\u5fc3\u7684\u65cb\u8f6c","title":"trans_with_obj_center()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.translate_X_dec","text":"translate_X_dec ( vis )","title":"translate_X_dec()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.translate_X_inc","text":"translate_X_inc ( vis )","title":"translate_X_inc()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.translate_Y_dec","text":"translate_Y_dec ( vis )","title":"translate_Y_dec()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.translate_Y_inc","text":"translate_Y_inc ( vis )","title":"translate_Y_inc()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.translate_Z_dec","text":"translate_Z_dec ( vis )","title":"translate_Z_dec()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.InteractIcp.translate_Z_inc","text":"translate_Z_inc ( vis )","title":"translate_Z_inc()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.MaskBilter","text":"","title":"MaskBilter"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.MaskBilter.SHOW_NUM","text":"SHOW_NUM = 6","title":"SHOW_NUM"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.MaskBilter.camera_intr","text":"camera_intr = CameraIntr . from_json ( os . path . join ( self . data_path , CALI_INTR_FILE ))","title":"camera_intr"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.MaskBilter.cur_range","text":"cur_range \u5f53\u524d\u7684\u5e27\u8303\u56f4","title":"cur_range"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.MaskBilter.data_path","text":"data_path = data_recorder . data_path","title":"data_path"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.MaskBilter.data_recorder","text":"data_recorder = data_recorder","title":"data_recorder"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.MaskBilter.model_index_range","text":"model_index_range = self . data_recorder . category_idx_range","title":"model_index_range"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.MaskBilter.selected_depth_masks","text":"selected_depth_masks = []","title":"selected_depth_masks"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.MaskBilter.selected_frame_indecies","text":"selected_frame_indecies = []","title":"selected_frame_indecies"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.MaskBilter.selected_rgbs","text":"selected_rgbs = []","title":"selected_rgbs"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.MaskBilter.selected_view_trans_mats","text":"selected_view_trans_mats = []","title":"selected_view_trans_mats"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.MaskBilter.this_frame_rgb","text":"this_frame_rgb","title":"this_frame_rgb"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.MaskBilter.this_view_trans_mat","text":"this_view_trans_mat","title":"this_view_trans_mat"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.MaskBilter.__init__","text":"__init__ ( data_recorder : DataRecorder ) -> None","title":"__init__()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.MaskBilter.farthest_point_sample_angle","text":"farthest_point_sample_angle ( xyz , npoint ) Input: xyz: pointcloud data, [N, 3] npoint: number of samples Return: centroids: sampled pointcloud index, [B, npoint]","title":"farthest_point_sample_angle()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.MaskBilter.next_view","text":"next_view () \u4e0b\u4e00\u4e2a\u89c6\u89d2","title":"next_view()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.MaskBilter.read_rgbs","text":"read_rgbs ()","title":"read_rgbs()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.MaskBilter.select_views","text":"select_views ( num ) \u9009\u62e9\u89c6\u89d2","title":"select_views()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.MaskBilter.set_current_name","text":"set_current_name ( name )","title":"set_current_name()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.MaskBilter.show","text":"show ( std_model_meta : ModelInfo , is_mask_visible )","title":"show()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.ModelBalencePosture","text":"","title":"ModelBalencePosture"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.ModelBalencePosture.POINT_BALENCE_TOL","text":"POINT_BALENCE_TOL = 0.5 * np . pi / 180","title":"POINT_BALENCE_TOL"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.ModelBalencePosture.POINT_STABLE_TOL","text":"POINT_STABLE_TOL = 0.1 * np . pi / 180","title":"POINT_STABLE_TOL"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.ModelBalencePosture.current_mi","text":"current_mi : ModelInfo = None","title":"current_mi"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.ModelBalencePosture.__init__","text":"__init__ () -> None","title":"__init__()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.ModelBalencePosture._angle","text":"_angle ( vce1 , vec2 )","title":"_angle()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.ModelBalencePosture.fall","text":"fall ( mi : ModelInfo , contact_dict : dict , step = 1.0 / 180 * np . pi ) step \u6b65\u957f","title":"fall()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.ModelBalencePosture.find_all_connected","text":"find_all_connected ( tri , seed_idx , valid_idx_array )","title":"find_all_connected()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.ModelBalencePosture.get_bary_vec","text":"get_bary_vec ( mi : ModelInfo , index )","title":"get_bary_vec()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.ModelBalencePosture.get_contact_point","text":"get_contact_point ( mi : ModelInfo )","title":"get_contact_point()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.ModelBalencePosture.get_drop_foot","text":"get_drop_foot ( point , line_p1 , line_p2 )","title":"get_drop_foot()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.ModelBalencePosture.get_neighbors","text":"get_neighbors ( point : np . ndarray , point_list : np . ndarray , r )","title":"get_neighbors()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.ModelBalencePosture.get_normal","text":"get_normal ( mi : ModelInfo , index )","title":"get_normal()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.ModelBalencePosture.if_point_stable","text":"if_point_stable ( mi : ModelInfo , contact_dict : dict ) \u70b9\u662f\u5426\u7a33\u5b9a\uff0c\u8ba1\u7b97\u8be5\u70b9\u7684\u5939\u89d2\u3001\u9644\u8fd1\u70b9\u7684\u5939\u89d2","title":"if_point_stable()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.ModelBalencePosture.place","text":"place ( mi : ModelInfo )","title":"place()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.ModelBalencePosture.point_distance_line","text":"point_distance_line ( points , lines_point1 , lines_point2 ) points : [P, 3] -> [P, L, 3] lines_point1: [L, 3] -> [P, L, 3]","title":"point_distance_line()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.ModelBalencePosture.proj_vec","text":"proj_vec ( vec , n , normal = True )","title":"proj_vec()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.ModelInfo","text":"Bases: MeshMeta","title":"ModelInfo"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.ModelInfo.avg_dist","text":"avg_dist = np . mean ( distances )","title":"avg_dist"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.ModelInfo.barycenter","text":"barycenter = self . calc_barycenter ( self . avg_dist * 3 )","title":"barycenter"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.ModelInfo.pcd","text":"pcd = o3d . geometry . PointCloud ()","title":"pcd"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.ModelInfo.__init__","text":"__init__ ( mesh , name = '' , class_id =- 1 , barycenter : np . ndarray = None ) -> None","title":"__init__()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.ModelInfo.calc_barycenter","text":"calc_barycenter ( voxel_size )","title":"calc_barycenter()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.ModelInfo.transform","text":"transform ( posture : Union [ Posture , np . ndarray ], copy = True )","title":"transform()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.MyGA","text":"Bases: GA","title":"MyGA"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.MyGA.fit","text":"fit = run","title":"fit"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.MyGA.result_precision","text":"result_precision = result_precision","title":"result_precision"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.MyGA.__init__","text":"__init__ ( func , n_dim , size_pop = 50 , max_iter = 200 , prob_mut = 1 , lb =- 1 , ub = 1 , constraint_eq = [], constraint_ueq = [], precision = 1e-07 , early_stop = None , result_precision = 0.01 )","title":"__init__()"},{"location":"md/create_6d_posture_dataset/interact_icp/#create_6d_posture_dataset.interact_icp.MyGA.run","text":"run ( max_iter = None )","title":"run()"},{"location":"md/create_6d_posture_dataset/pcd_creator/","text":"pcd_creator register_scene.py Create registered scene pointcloud with ambient noise removal The registered pointcloud includes the table top, markers, and some noise This mesh needs to be processed in a mesh processing tool to remove the artifact Aruco_Voronoi arcuo_centers instance-attribute arcuo_centers = {} aruco_used_times instance-attribute aruco_used_times = process_data [ process_data . ARUCO_USED_TIMES ] o3d_vols instance-attribute o3d_vols = {} pcd_creator instance-attribute pcd_creator = pcd_creator voronoi_poly instance-attribute voronoi_poly = bounded_voronoi ( bbox , centers [:, : 2 ]) __init__ __init__ ( pcd_creator : PcdCreator , trans_mat ) -> None crop crop ( pcd , ids ) crop_by_aruco_num crop_by_aruco_num ( pcd , name : str ) Interact_ChechSeg comp instance-attribute comp = None model_idx instance-attribute model_idx = - 1 model_names instance-attribute model_names = model_names model_pcds instance-attribute model_pcds = model_pcds o3d_vols instance-attribute o3d_vols = o3d_vols top_rank_slice instance-attribute top_rank_slice = top_rank_slice vol instance-attribute vol = None vol_idx instance-attribute vol_idx = - 1 __init__ __init__ ( model_pcds , model_names , top_rank_slice , o3d_vols ) -> None change_model change_model ( vis , inc = True ) check_end check_end ( vis ) confirm confirm ( vis = None ) crop crop ( vis ) start start () press V to change model press N to confirm PcdCreator 1.register the pointclouds of the scene 2.segment the scene into different parts 3.match the name of the segment with the name of the object aruco_detector instance-attribute aruco_detector = aruco_detector data_recorder instance-attribute data_recorder = data_recorder max_correspondence_distance_coarse instance-attribute max_correspondence_distance_coarse = voxel_size * 15 max_correspondence_distance_fine instance-attribute max_correspondence_distance_fine = voxel_size * 1.5 model_manager instance-attribute model_manager = model_manager process_data instance-attribute process_data = self . model_manager . process_data radius instance-attribute radius = self . voxel_size * 2 voxel_size instance-attribute voxel_size = voxel_size __init__ __init__ ( data_recorder : DataRecorder , aruco_detector : ArucoDetector , model_manager : ModelManager , voxel_size = 0.5 ) -> None _cvt_rgb_2_hsv staticmethod _cvt_rgb_2_hsv ( rgb_array ) _filter_by_color staticmethod _filter_by_color ( pcd , remove_color , tol , remove = True ) \u6309\u989c\u8272\u8fc7\u6ee4, RGB remove_color: hsv _get_floor_points staticmethod _get_floor_points ( pcd , band_height = 2 , offset = 5 ) _merge_meshes _merge_meshes () generate the merged mesh of the scene _register_post_process _register_post_process ( originals : list [ o3d . geometry . PointCloud ]) Merge segments so that new points will not be add to the merged model if within voxel_Radius to the existing points, and keep a vote for if the point is issolated outside the radius of inlier_Radius at the timeof the merge Parameters: originals ( List of open3d.Pointcloud classe ) \u2013 6D pontcloud of the segments transformed into the world frame voxel_Radius ( float ) \u2013 Reject duplicate point if the new point lies within the voxel radius of the existing point inlier_Radius ( float ) \u2013 Point considered an outlier if more than inlier_Radius away from any other points Returns: points ( (n,3) float ) \u2013 The (x,y,z) of the processed and filtered pointcloud colors ( (n,3) float ) \u2013 The (r,g,b) color information corresponding to the points vote ( (n, ) int ) \u2013 The number of vote (seen duplicate points within the voxel_radius) each processed point has reveived auto_seg auto_seg ( update = False ) \u81ea\u52a8\u5206\u5272\uff1a 1\u3001\u6839\u636earuco\u5efa\u7acb\u573a\u666f\u5750\u6807\u7cfbSCS\uff0caruco\u5fc5\u987b\u753112\u4e2a\uff0c\u5747\u5e03\u5728\u77e9\u5f62\u7684\u4e00\u5468 2\u3001\u521d\u6b65\u5206\u5272\u70b9\u4e91\uff0c\u53ea\u4fdd\u7559aruco\u5305\u56f4\u7684\u77e9\u5f62\u8303\u56f4 3\u3001\u573a\u666f\u4f53\u7d20\u5316\uff0c\u5f00\u8fd0\u7b97\u63d0\u53d6\u5b64\u7acb\u5b9e\u4f53 4\u3001\u4fdd\u5b58 build_build_sceneCS build_build_sceneCS ( test_pcd ) crop_sence crop_sence ( trans_mat , arucos_SCS ) extract_uniform_pcd extract_uniform_pcd ( SCStrans_mat , floor_color = None ) \u63d0\u53d6\u5747\u5300\u70b9\u4e91 seg_polygons: N*[p, 3] get_floor_color get_floor_color ( points : np . ndarray , colors : np . ndarray ) get the mean color in hsv space match_segmesh_name match_segmesh_name ( seg_polygons , SCStrans_mat ) \u6839\u636evoronoi\u5206\u5272\u56fe\u548c\u5404\u4e2a\u6a21\u578b\u7684ply\uff0c\u5c06\u4ed6\u4eec\u6309\u6b63\u786e\u7684\u7c7b\u522b\u8fdb\u884c\u5206\u5272\uff0c\u8fd4\u56de\u5b57\u5178{name: box} seg_polygons: N*[p, 3] register register ( downsample = True , update = False )","title":"pcd_creator"},{"location":"md/create_6d_posture_dataset/pcd_creator/#pcd_creator","text":"","title":"pcd_creator"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator--register_scenepy","text":"Create registered scene pointcloud with ambient noise removal The registered pointcloud includes the table top, markers, and some noise This mesh needs to be processed in a mesh processing tool to remove the artifact","title":"register_scene.py"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.Aruco_Voronoi","text":"","title":"Aruco_Voronoi"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.Aruco_Voronoi.arcuo_centers","text":"arcuo_centers = {}","title":"arcuo_centers"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.Aruco_Voronoi.aruco_used_times","text":"aruco_used_times = process_data [ process_data . ARUCO_USED_TIMES ]","title":"aruco_used_times"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.Aruco_Voronoi.o3d_vols","text":"o3d_vols = {}","title":"o3d_vols"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.Aruco_Voronoi.pcd_creator","text":"pcd_creator = pcd_creator","title":"pcd_creator"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.Aruco_Voronoi.voronoi_poly","text":"voronoi_poly = bounded_voronoi ( bbox , centers [:, : 2 ])","title":"voronoi_poly"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.Aruco_Voronoi.__init__","text":"__init__ ( pcd_creator : PcdCreator , trans_mat ) -> None","title":"__init__()"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.Aruco_Voronoi.crop","text":"crop ( pcd , ids )","title":"crop()"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.Aruco_Voronoi.crop_by_aruco_num","text":"crop_by_aruco_num ( pcd , name : str )","title":"crop_by_aruco_num()"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.Interact_ChechSeg","text":"","title":"Interact_ChechSeg"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.Interact_ChechSeg.comp","text":"comp = None","title":"comp"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.Interact_ChechSeg.model_idx","text":"model_idx = - 1","title":"model_idx"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.Interact_ChechSeg.model_names","text":"model_names = model_names","title":"model_names"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.Interact_ChechSeg.model_pcds","text":"model_pcds = model_pcds","title":"model_pcds"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.Interact_ChechSeg.o3d_vols","text":"o3d_vols = o3d_vols","title":"o3d_vols"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.Interact_ChechSeg.top_rank_slice","text":"top_rank_slice = top_rank_slice","title":"top_rank_slice"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.Interact_ChechSeg.vol","text":"vol = None","title":"vol"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.Interact_ChechSeg.vol_idx","text":"vol_idx = - 1","title":"vol_idx"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.Interact_ChechSeg.__init__","text":"__init__ ( model_pcds , model_names , top_rank_slice , o3d_vols ) -> None","title":"__init__()"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.Interact_ChechSeg.change_model","text":"change_model ( vis , inc = True )","title":"change_model()"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.Interact_ChechSeg.check_end","text":"check_end ( vis )","title":"check_end()"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.Interact_ChechSeg.confirm","text":"confirm ( vis = None )","title":"confirm()"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.Interact_ChechSeg.crop","text":"crop ( vis )","title":"crop()"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.Interact_ChechSeg.start","text":"start () press V to change model press N to confirm","title":"start()"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.PcdCreator","text":"1.register the pointclouds of the scene 2.segment the scene into different parts 3.match the name of the segment with the name of the object","title":"PcdCreator"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.PcdCreator.aruco_detector","text":"aruco_detector = aruco_detector","title":"aruco_detector"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.PcdCreator.data_recorder","text":"data_recorder = data_recorder","title":"data_recorder"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.PcdCreator.max_correspondence_distance_coarse","text":"max_correspondence_distance_coarse = voxel_size * 15","title":"max_correspondence_distance_coarse"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.PcdCreator.max_correspondence_distance_fine","text":"max_correspondence_distance_fine = voxel_size * 1.5","title":"max_correspondence_distance_fine"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.PcdCreator.model_manager","text":"model_manager = model_manager","title":"model_manager"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.PcdCreator.process_data","text":"process_data = self . model_manager . process_data","title":"process_data"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.PcdCreator.radius","text":"radius = self . voxel_size * 2","title":"radius"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.PcdCreator.voxel_size","text":"voxel_size = voxel_size","title":"voxel_size"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.PcdCreator.__init__","text":"__init__ ( data_recorder : DataRecorder , aruco_detector : ArucoDetector , model_manager : ModelManager , voxel_size = 0.5 ) -> None","title":"__init__()"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.PcdCreator._cvt_rgb_2_hsv","text":"_cvt_rgb_2_hsv ( rgb_array )","title":"_cvt_rgb_2_hsv()"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.PcdCreator._filter_by_color","text":"_filter_by_color ( pcd , remove_color , tol , remove = True ) \u6309\u989c\u8272\u8fc7\u6ee4, RGB remove_color: hsv","title":"_filter_by_color()"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.PcdCreator._get_floor_points","text":"_get_floor_points ( pcd , band_height = 2 , offset = 5 )","title":"_get_floor_points()"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.PcdCreator._merge_meshes","text":"_merge_meshes () generate the merged mesh of the scene","title":"_merge_meshes()"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.PcdCreator._register_post_process","text":"_register_post_process ( originals : list [ o3d . geometry . PointCloud ]) Merge segments so that new points will not be add to the merged model if within voxel_Radius to the existing points, and keep a vote for if the point is issolated outside the radius of inlier_Radius at the timeof the merge Parameters: originals ( List of open3d.Pointcloud classe ) \u2013 6D pontcloud of the segments transformed into the world frame voxel_Radius ( float ) \u2013 Reject duplicate point if the new point lies within the voxel radius of the existing point inlier_Radius ( float ) \u2013 Point considered an outlier if more than inlier_Radius away from any other points Returns: points ( (n,3) float ) \u2013 The (x,y,z) of the processed and filtered pointcloud colors ( (n,3) float ) \u2013 The (r,g,b) color information corresponding to the points vote ( (n, ) int ) \u2013 The number of vote (seen duplicate points within the voxel_radius) each processed point has reveived","title":"_register_post_process()"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.PcdCreator.auto_seg","text":"auto_seg ( update = False ) \u81ea\u52a8\u5206\u5272\uff1a 1\u3001\u6839\u636earuco\u5efa\u7acb\u573a\u666f\u5750\u6807\u7cfbSCS\uff0caruco\u5fc5\u987b\u753112\u4e2a\uff0c\u5747\u5e03\u5728\u77e9\u5f62\u7684\u4e00\u5468 2\u3001\u521d\u6b65\u5206\u5272\u70b9\u4e91\uff0c\u53ea\u4fdd\u7559aruco\u5305\u56f4\u7684\u77e9\u5f62\u8303\u56f4 3\u3001\u573a\u666f\u4f53\u7d20\u5316\uff0c\u5f00\u8fd0\u7b97\u63d0\u53d6\u5b64\u7acb\u5b9e\u4f53 4\u3001\u4fdd\u5b58","title":"auto_seg()"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.PcdCreator.build_build_sceneCS","text":"build_build_sceneCS ( test_pcd )","title":"build_build_sceneCS()"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.PcdCreator.crop_sence","text":"crop_sence ( trans_mat , arucos_SCS )","title":"crop_sence()"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.PcdCreator.extract_uniform_pcd","text":"extract_uniform_pcd ( SCStrans_mat , floor_color = None ) \u63d0\u53d6\u5747\u5300\u70b9\u4e91 seg_polygons: N*[p, 3]","title":"extract_uniform_pcd()"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.PcdCreator.get_floor_color","text":"get_floor_color ( points : np . ndarray , colors : np . ndarray ) get the mean color in hsv space","title":"get_floor_color()"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.PcdCreator.match_segmesh_name","text":"match_segmesh_name ( seg_polygons , SCStrans_mat ) \u6839\u636evoronoi\u5206\u5272\u56fe\u548c\u5404\u4e2a\u6a21\u578b\u7684ply\uff0c\u5c06\u4ed6\u4eec\u6309\u6b63\u786e\u7684\u7c7b\u522b\u8fdb\u884c\u5206\u5272\uff0c\u8fd4\u56de\u5b57\u5178{name: box} seg_polygons: N*[p, 3]","title":"match_segmesh_name()"},{"location":"md/create_6d_posture_dataset/pcd_creator/#create_6d_posture_dataset.pcd_creator.PcdCreator.register","text":"register ( downsample = True , update = False )","title":"register()"},{"location":"md/create_6d_posture_dataset/pipeline/","text":"pipeline PipeLine aruco_detector instance-attribute aruco_detector = ArucoDetector ( self . data_recorder . aruco_floor_json . read ( 0 )) capturing instance-attribute capturing = Capturing ( self . data_recorder , self . aruco_detector , self . model_manager ) data_num property data_num data_recorder instance-attribute data_recorder = DataRecorder ( self . directory , '' , flag_name = 'data_recorder' ) dataset_name instance-attribute dataset_name = dataset_name directory instance-attribute directory = os . path . join ( dataset_name , sub_dir ) interact_icp instance-attribute interact_icp = InteractIcp ( self . data_recorder , self . model_manager ) model_manager instance-attribute model_manager = ModelManager ( self . directory , '' , flag_name = 'model_manager' ) pcd_creator instance-attribute pcd_creator = PcdCreator ( self . data_recorder , self . aruco_detector , self . model_manager ) sub_dir instance-attribute sub_dir = sub_dir __init__ __init__ ( dataset_name , sub_dir ) -> None capture_image capture_image () export_data export_data ( mesh_manager : Union [ MeshManager , dict [ int , MeshMeta ]], cvt_intr : CameraIntr = None ) icp icp () plot_captured plot_captured () plot_dataset plot_dataset () register_pcd register_pcd ( update = False ) segment_pcd segment_pcd ( update = False )","title":"pipeline"},{"location":"md/create_6d_posture_dataset/pipeline/#pipeline","text":"","title":"pipeline"},{"location":"md/create_6d_posture_dataset/pipeline/#create_6d_posture_dataset.pipeline.PipeLine","text":"","title":"PipeLine"},{"location":"md/create_6d_posture_dataset/pipeline/#create_6d_posture_dataset.pipeline.PipeLine.aruco_detector","text":"aruco_detector = ArucoDetector ( self . data_recorder . aruco_floor_json . read ( 0 ))","title":"aruco_detector"},{"location":"md/create_6d_posture_dataset/pipeline/#create_6d_posture_dataset.pipeline.PipeLine.capturing","text":"capturing = Capturing ( self . data_recorder , self . aruco_detector , self . model_manager )","title":"capturing"},{"location":"md/create_6d_posture_dataset/pipeline/#create_6d_posture_dataset.pipeline.PipeLine.data_num","text":"data_num","title":"data_num"},{"location":"md/create_6d_posture_dataset/pipeline/#create_6d_posture_dataset.pipeline.PipeLine.data_recorder","text":"data_recorder = DataRecorder ( self . directory , '' , flag_name = 'data_recorder' )","title":"data_recorder"},{"location":"md/create_6d_posture_dataset/pipeline/#create_6d_posture_dataset.pipeline.PipeLine.dataset_name","text":"dataset_name = dataset_name","title":"dataset_name"},{"location":"md/create_6d_posture_dataset/pipeline/#create_6d_posture_dataset.pipeline.PipeLine.directory","text":"directory = os . path . join ( dataset_name , sub_dir )","title":"directory"},{"location":"md/create_6d_posture_dataset/pipeline/#create_6d_posture_dataset.pipeline.PipeLine.interact_icp","text":"interact_icp = InteractIcp ( self . data_recorder , self . model_manager )","title":"interact_icp"},{"location":"md/create_6d_posture_dataset/pipeline/#create_6d_posture_dataset.pipeline.PipeLine.model_manager","text":"model_manager = ModelManager ( self . directory , '' , flag_name = 'model_manager' )","title":"model_manager"},{"location":"md/create_6d_posture_dataset/pipeline/#create_6d_posture_dataset.pipeline.PipeLine.pcd_creator","text":"pcd_creator = PcdCreator ( self . data_recorder , self . aruco_detector , self . model_manager )","title":"pcd_creator"},{"location":"md/create_6d_posture_dataset/pipeline/#create_6d_posture_dataset.pipeline.PipeLine.sub_dir","text":"sub_dir = sub_dir","title":"sub_dir"},{"location":"md/create_6d_posture_dataset/pipeline/#create_6d_posture_dataset.pipeline.PipeLine.__init__","text":"__init__ ( dataset_name , sub_dir ) -> None","title":"__init__()"},{"location":"md/create_6d_posture_dataset/pipeline/#create_6d_posture_dataset.pipeline.PipeLine.capture_image","text":"capture_image ()","title":"capture_image()"},{"location":"md/create_6d_posture_dataset/pipeline/#create_6d_posture_dataset.pipeline.PipeLine.export_data","text":"export_data ( mesh_manager : Union [ MeshManager , dict [ int , MeshMeta ]], cvt_intr : CameraIntr = None )","title":"export_data()"},{"location":"md/create_6d_posture_dataset/pipeline/#create_6d_posture_dataset.pipeline.PipeLine.icp","text":"icp ()","title":"icp()"},{"location":"md/create_6d_posture_dataset/pipeline/#create_6d_posture_dataset.pipeline.PipeLine.plot_captured","text":"plot_captured ()","title":"plot_captured()"},{"location":"md/create_6d_posture_dataset/pipeline/#create_6d_posture_dataset.pipeline.PipeLine.plot_dataset","text":"plot_dataset ()","title":"plot_dataset()"},{"location":"md/create_6d_posture_dataset/pipeline/#create_6d_posture_dataset.pipeline.PipeLine.register_pcd","text":"register_pcd ( update = False )","title":"register_pcd()"},{"location":"md/create_6d_posture_dataset/pipeline/#create_6d_posture_dataset.pipeline.PipeLine.segment_pcd","text":"segment_pcd ( update = False )","title":"segment_pcd()"},{"location":"md/create_6d_posture_dataset/utils/aruco_detector/","text":"aruco_detector compute_gt_poses.py Main Function for registering (aligning) colored point clouds with ICP/aruco marker matching as well as pose graph optimizating, output transforms.npy in each directory ArucoDetector detect aruco marker and compute its pose C0_aruco_3d_dict instance-attribute C0_aruco_3d_dict = JsonIO . load_json ( aruco_floor ) _inner_aruco_detector class-attribute instance-attribute _inner_aruco_detector = aruco . ArucoDetector ( aruco_dict , parameters ) aruco_dict class-attribute instance-attribute aruco_dict = aruco . getPredefinedDictionary ( aruco . DICT_6X6_250 ) parameters class-attribute instance-attribute parameters = aruco . DetectorParameters () verify_tol instance-attribute verify_tol = 0.01 __init__ __init__ ( aruco_floor : Union [ str , dict , np . ndarray ], * , long_side_real_size = None ) -> None collect_if_id_in_C0_aruco collect_if_id_in_C0_aruco ( ids : np . ndarray , * values ) detect_aruco_2d classmethod detect_aruco_2d ( image : np . ndarray ) -> tuple [ np . ndarray , np . ndarray , np . ndarray ] return corners_src: np.ndarray, [N, 4, 2] ids: np.ndarray, [N] rejectedImgPoints: np.ndarray, [N, 1, 2] detect_aruco_3d classmethod detect_aruco_3d ( color , depth , camera_intrinsics : Union [ np . ndarray , CameraIntr ], corners_src = None , ids = None ) brief detect aruco marker in 2d image and compute its 3d pose by depth image params color: np.ndarray, [H, W, 3] depth: np.ndarray, [H, W] np.uint16 camera_intrinsics: np.ndarray, [3, 3] or CameraIntr corners_src: Optional, np.ndarray, [N, 4, 2], to avoid repeatly detect aruco marker if detect_aruco_2d has been called in context ids: Optional, np.ndarray, [N], to avoid repeatly detect aruco marker if detect_aruco_2d has been called in context get_C0_aruco_3d_dict_from_image staticmethod get_C0_aruco_3d_dict_from_image ( image : Union [ str , np . ndarray ], long_side_real_size : float ) params image: np.ndarray, [H, W, 3] long_side_real_size: float, the real size of the long side of the image, unit: mm get_T_2d get_T_2d ( color : np . ndarray , depth : np . ndarray , camera_intrinsics : CameraIntr , return_coords = True ) get_T_3d get_T_3d ( color , depth , camera_intrinsics , tol = 0.01 , return_coords = True ) project staticmethod project ( camera_intrinsics : Union [ np . ndarray , CameraIntr ], points_C ) points_C: [N, 3] restore staticmethod restore ( camera_intrinsics : Union [ np . ndarray , CameraIntr ], points_I ) points_I: [N, 2] verify_frame verify_frame ( cad , depth , camera_intrinsics , if_2d = True )","title":"utils.aruco_detector"},{"location":"md/create_6d_posture_dataset/utils/aruco_detector/#aruco_detector","text":"","title":"aruco_detector"},{"location":"md/create_6d_posture_dataset/utils/aruco_detector/#create_6d_posture_dataset.utils.aruco_detector--compute_gt_posespy","text":"Main Function for registering (aligning) colored point clouds with ICP/aruco marker matching as well as pose graph optimizating, output transforms.npy in each directory","title":"compute_gt_poses.py"},{"location":"md/create_6d_posture_dataset/utils/aruco_detector/#create_6d_posture_dataset.utils.aruco_detector.ArucoDetector","text":"detect aruco marker and compute its pose","title":"ArucoDetector"},{"location":"md/create_6d_posture_dataset/utils/aruco_detector/#create_6d_posture_dataset.utils.aruco_detector.ArucoDetector.C0_aruco_3d_dict","text":"C0_aruco_3d_dict = JsonIO . load_json ( aruco_floor )","title":"C0_aruco_3d_dict"},{"location":"md/create_6d_posture_dataset/utils/aruco_detector/#create_6d_posture_dataset.utils.aruco_detector.ArucoDetector._inner_aruco_detector","text":"_inner_aruco_detector = aruco . ArucoDetector ( aruco_dict , parameters )","title":"_inner_aruco_detector"},{"location":"md/create_6d_posture_dataset/utils/aruco_detector/#create_6d_posture_dataset.utils.aruco_detector.ArucoDetector.aruco_dict","text":"aruco_dict = aruco . getPredefinedDictionary ( aruco . DICT_6X6_250 )","title":"aruco_dict"},{"location":"md/create_6d_posture_dataset/utils/aruco_detector/#create_6d_posture_dataset.utils.aruco_detector.ArucoDetector.parameters","text":"parameters = aruco . DetectorParameters ()","title":"parameters"},{"location":"md/create_6d_posture_dataset/utils/aruco_detector/#create_6d_posture_dataset.utils.aruco_detector.ArucoDetector.verify_tol","text":"verify_tol = 0.01","title":"verify_tol"},{"location":"md/create_6d_posture_dataset/utils/aruco_detector/#create_6d_posture_dataset.utils.aruco_detector.ArucoDetector.__init__","text":"__init__ ( aruco_floor : Union [ str , dict , np . ndarray ], * , long_side_real_size = None ) -> None","title":"__init__()"},{"location":"md/create_6d_posture_dataset/utils/aruco_detector/#create_6d_posture_dataset.utils.aruco_detector.ArucoDetector.collect_if_id_in_C0_aruco","text":"collect_if_id_in_C0_aruco ( ids : np . ndarray , * values )","title":"collect_if_id_in_C0_aruco()"},{"location":"md/create_6d_posture_dataset/utils/aruco_detector/#create_6d_posture_dataset.utils.aruco_detector.ArucoDetector.detect_aruco_2d","text":"detect_aruco_2d ( image : np . ndarray ) -> tuple [ np . ndarray , np . ndarray , np . ndarray ]","title":"detect_aruco_2d()"},{"location":"md/create_6d_posture_dataset/utils/aruco_detector/#create_6d_posture_dataset.utils.aruco_detector.ArucoDetector.detect_aruco_2d--return","text":"corners_src: np.ndarray, [N, 4, 2] ids: np.ndarray, [N] rejectedImgPoints: np.ndarray, [N, 1, 2]","title":"return"},{"location":"md/create_6d_posture_dataset/utils/aruco_detector/#create_6d_posture_dataset.utils.aruco_detector.ArucoDetector.detect_aruco_3d","text":"detect_aruco_3d ( color , depth , camera_intrinsics : Union [ np . ndarray , CameraIntr ], corners_src = None , ids = None )","title":"detect_aruco_3d()"},{"location":"md/create_6d_posture_dataset/utils/aruco_detector/#create_6d_posture_dataset.utils.aruco_detector.ArucoDetector.detect_aruco_3d--brief","text":"detect aruco marker in 2d image and compute its 3d pose by depth image","title":"brief"},{"location":"md/create_6d_posture_dataset/utils/aruco_detector/#create_6d_posture_dataset.utils.aruco_detector.ArucoDetector.detect_aruco_3d--params","text":"color: np.ndarray, [H, W, 3] depth: np.ndarray, [H, W] np.uint16 camera_intrinsics: np.ndarray, [3, 3] or CameraIntr corners_src: Optional, np.ndarray, [N, 4, 2], to avoid repeatly detect aruco marker if detect_aruco_2d has been called in context ids: Optional, np.ndarray, [N], to avoid repeatly detect aruco marker if detect_aruco_2d has been called in context","title":"params"},{"location":"md/create_6d_posture_dataset/utils/aruco_detector/#create_6d_posture_dataset.utils.aruco_detector.ArucoDetector.get_C0_aruco_3d_dict_from_image","text":"get_C0_aruco_3d_dict_from_image ( image : Union [ str , np . ndarray ], long_side_real_size : float )","title":"get_C0_aruco_3d_dict_from_image()"},{"location":"md/create_6d_posture_dataset/utils/aruco_detector/#create_6d_posture_dataset.utils.aruco_detector.ArucoDetector.get_C0_aruco_3d_dict_from_image--params","text":"image: np.ndarray, [H, W, 3] long_side_real_size: float, the real size of the long side of the image, unit: mm","title":"params"},{"location":"md/create_6d_posture_dataset/utils/aruco_detector/#create_6d_posture_dataset.utils.aruco_detector.ArucoDetector.get_T_2d","text":"get_T_2d ( color : np . ndarray , depth : np . ndarray , camera_intrinsics : CameraIntr , return_coords = True )","title":"get_T_2d()"},{"location":"md/create_6d_posture_dataset/utils/aruco_detector/#create_6d_posture_dataset.utils.aruco_detector.ArucoDetector.get_T_3d","text":"get_T_3d ( color , depth , camera_intrinsics , tol = 0.01 , return_coords = True )","title":"get_T_3d()"},{"location":"md/create_6d_posture_dataset/utils/aruco_detector/#create_6d_posture_dataset.utils.aruco_detector.ArucoDetector.project","text":"project ( camera_intrinsics : Union [ np . ndarray , CameraIntr ], points_C ) points_C: [N, 3]","title":"project()"},{"location":"md/create_6d_posture_dataset/utils/aruco_detector/#create_6d_posture_dataset.utils.aruco_detector.ArucoDetector.restore","text":"restore ( camera_intrinsics : Union [ np . ndarray , CameraIntr ], points_I ) points_I: [N, 2]","title":"restore()"},{"location":"md/create_6d_posture_dataset/utils/aruco_detector/#create_6d_posture_dataset.utils.aruco_detector.ArucoDetector.verify_frame","text":"verify_frame ( cad , depth , camera_intrinsics , if_2d = True )","title":"verify_frame()"},{"location":"md/create_6d_posture_dataset/utils/bounded_voronoi/","text":"bounded_voronoi bnd module-attribute bnd = np . array ([[ 0 , 0 ], [ 1 , 0 ], [ 1 , 1 ], [ 0 , 1 ]]) n module-attribute n = 30 pnts module-attribute pnts = np . random . rand ( n , 2 ) vor_polys module-attribute vor_polys = bounded_voronoi ( bnd , pnts ) bounded_voronoi bounded_voronoi ( bnd , pnts , plot = False ) \u8ba1\u7b97\u6709\u754c\u7684voronoi\u8981\u7ed8\u5236\u7684\u51fd\u6570\u3002 get_seg_maps get_seg_maps ( floor_slice_map , restore_mat , scale = 1000 , model_num = 9 )","title":"utils.bounded_voronoi"},{"location":"md/create_6d_posture_dataset/utils/bounded_voronoi/#bounded_voronoi","text":"","title":"bounded_voronoi"},{"location":"md/create_6d_posture_dataset/utils/bounded_voronoi/#create_6d_posture_dataset.utils.bounded_voronoi.bnd","text":"bnd = np . array ([[ 0 , 0 ], [ 1 , 0 ], [ 1 , 1 ], [ 0 , 1 ]])","title":"bnd"},{"location":"md/create_6d_posture_dataset/utils/bounded_voronoi/#create_6d_posture_dataset.utils.bounded_voronoi.n","text":"n = 30","title":"n"},{"location":"md/create_6d_posture_dataset/utils/bounded_voronoi/#create_6d_posture_dataset.utils.bounded_voronoi.pnts","text":"pnts = np . random . rand ( n , 2 )","title":"pnts"},{"location":"md/create_6d_posture_dataset/utils/bounded_voronoi/#create_6d_posture_dataset.utils.bounded_voronoi.vor_polys","text":"vor_polys = bounded_voronoi ( bnd , pnts )","title":"vor_polys"},{"location":"md/create_6d_posture_dataset/utils/bounded_voronoi/#create_6d_posture_dataset.utils.bounded_voronoi.bounded_voronoi","text":"bounded_voronoi ( bnd , pnts , plot = False ) \u8ba1\u7b97\u6709\u754c\u7684voronoi\u8981\u7ed8\u5236\u7684\u51fd\u6570\u3002","title":"bounded_voronoi()"},{"location":"md/create_6d_posture_dataset/utils/bounded_voronoi/#create_6d_posture_dataset.utils.bounded_voronoi.get_seg_maps","text":"get_seg_maps ( floor_slice_map , restore_mat , scale = 1000 , model_num = 9 )","title":"get_seg_maps()"},{"location":"md/create_6d_posture_dataset/utils/camera_sys/","text":"camera_sys convert_depth_frame_to_pointcloud convert_depth_frame_to_pointcloud ( depth_image , camera_intrinsics : dict ) Convert the depthmap to a 3D point cloud Parameters: depth_frame : (m,n) uint16 The depth_frame containing the depth map camera_intrinsics : dict The intrinsic values of the depth imager in whose coordinate system the depth_frame is computed Return: pointcloud : (m,n,3) float The corresponding pointcloud in meters","title":"utils.camera_sys"},{"location":"md/create_6d_posture_dataset/utils/camera_sys/#camera_sys","text":"","title":"camera_sys"},{"location":"md/create_6d_posture_dataset/utils/camera_sys/#create_6d_posture_dataset.utils.camera_sys.convert_depth_frame_to_pointcloud","text":"convert_depth_frame_to_pointcloud ( depth_image , camera_intrinsics : dict ) Convert the depthmap to a 3D point cloud Parameters: depth_frame : (m,n) uint16 The depth_frame containing the depth map camera_intrinsics : dict The intrinsic values of the depth imager in whose coordinate system the depth_frame is computed Return: pointcloud : (m,n,3) float The corresponding pointcloud in meters","title":"convert_depth_frame_to_pointcloud()"},{"location":"md/create_6d_posture_dataset/utils/pc_voxelize/","text":"pc_voxelize pc_voxelize_reture Bases: enumerate BOX class-attribute instance-attribute BOX = 0 O3DPCD class-attribute instance-attribute O3DPCD = 2 SURF class-attribute instance-attribute SURF = 1 pc_voxelize pc_voxelize ( pcd , voxel_size = 1 , reture_type : pc_voxelize_reture = pc_voxelize_reture . BOX , pcd_color = np . array ([ 0 , 0 , 0 ])) \u70b9\u4e91\u4f53\u7d20\u5316 pcd: [N,4]","title":"utils.pc_voxelize"},{"location":"md/create_6d_posture_dataset/utils/pc_voxelize/#pc_voxelize","text":"","title":"pc_voxelize"},{"location":"md/create_6d_posture_dataset/utils/pc_voxelize/#create_6d_posture_dataset.utils.pc_voxelize.pc_voxelize_reture","text":"Bases: enumerate","title":"pc_voxelize_reture"},{"location":"md/create_6d_posture_dataset/utils/pc_voxelize/#create_6d_posture_dataset.utils.pc_voxelize.pc_voxelize_reture.BOX","text":"BOX = 0","title":"BOX"},{"location":"md/create_6d_posture_dataset/utils/pc_voxelize/#create_6d_posture_dataset.utils.pc_voxelize.pc_voxelize_reture.O3DPCD","text":"O3DPCD = 2","title":"O3DPCD"},{"location":"md/create_6d_posture_dataset/utils/pc_voxelize/#create_6d_posture_dataset.utils.pc_voxelize.pc_voxelize_reture.SURF","text":"SURF = 1","title":"SURF"},{"location":"md/create_6d_posture_dataset/utils/pc_voxelize/#create_6d_posture_dataset.utils.pc_voxelize.pc_voxelize","text":"pc_voxelize ( pcd , voxel_size = 1 , reture_type : pc_voxelize_reture = pc_voxelize_reture . BOX , pcd_color = np . array ([ 0 , 0 , 0 ])) \u70b9\u4e91\u4f53\u7d20\u5316 pcd: [N,4]","title":"pc_voxelize()"},{"location":"md/create_6d_posture_dataset/utils/plane/","text":"plane plane.py Functions related to plane segmentation. f_min f_min ( X , p ) findplane findplane ( cad , d ) findplane_wo_outliers findplane_wo_outliers ( points_3d , aruco_size = 0.056 , return_out_index = False ) points_3d [N, 3] fitplane fitplane ( p0 , points ) point_to_plane point_to_plane ( X , p ) residuals residuals ( params , signal , X )","title":"utils.plane"},{"location":"md/create_6d_posture_dataset/utils/plane/#plane","text":"","title":"plane"},{"location":"md/create_6d_posture_dataset/utils/plane/#create_6d_posture_dataset.utils.plane--planepy","text":"Functions related to plane segmentation.","title":"plane.py"},{"location":"md/create_6d_posture_dataset/utils/plane/#create_6d_posture_dataset.utils.plane.f_min","text":"f_min ( X , p )","title":"f_min()"},{"location":"md/create_6d_posture_dataset/utils/plane/#create_6d_posture_dataset.utils.plane.findplane","text":"findplane ( cad , d )","title":"findplane()"},{"location":"md/create_6d_posture_dataset/utils/plane/#create_6d_posture_dataset.utils.plane.findplane_wo_outliers","text":"findplane_wo_outliers ( points_3d , aruco_size = 0.056 , return_out_index = False ) points_3d [N, 3]","title":"findplane_wo_outliers()"},{"location":"md/create_6d_posture_dataset/utils/plane/#create_6d_posture_dataset.utils.plane.fitplane","text":"fitplane ( p0 , points )","title":"fitplane()"},{"location":"md/create_6d_posture_dataset/utils/plane/#create_6d_posture_dataset.utils.plane.point_to_plane","text":"point_to_plane ( X , p )","title":"point_to_plane()"},{"location":"md/create_6d_posture_dataset/utils/plane/#create_6d_posture_dataset.utils.plane.residuals","text":"residuals ( params , signal , X )","title":"residuals()"},{"location":"md/data/IOAbstract/","text":"IOAbstract DEBUG module-attribute DEBUG = False DMT module-attribute DMT = TypeVar ( 'DMT' , bound = 'DataMapping' ) DSNT module-attribute DSNT = TypeVar ( 'DSNT' , bound = 'DatasetNode' ) FCT module-attribute FCT = TypeVar ( 'FCT' , bound = 'FilesCluster' ) FHT module-attribute FHT = TypeVar ( 'FHT' , bound = 'FilesHandle' ) IOSM module-attribute IOSM = TypeVar ( 'IOSM' , bound = 'IOStatusManager' ) NODE module-attribute NODE = TypeVar ( 'NODE' , bound = 'Node' ) RGSITEM module-attribute RGSITEM = TypeVar ( 'RGSITEM' ) T module-attribute T = TypeVar ( 'T' ) T_MUITLSTR module-attribute T_MUITLSTR = TypeVar ( 'T_MUITLSTR' , str , List [ str ]) VDMT module-attribute VDMT = TypeVar ( 'VDMT' ) VDST module-attribute VDST = TypeVar ( 'VDST' ) _KT module-attribute _KT = TypeVar ( '_KT' ) _VT module-attribute _VT = TypeVar ( '_VT' ) AmbiguousError Bases: ValueError BinDict Bases: dict [ _KT , _VT ] , Generic [ _KT , _VT ] A dictionary subclass that supports bidirectional mapping between keys and values. Parameters: dict_ ( dict , default: None ) \u2013 The initial dictionary to populate the BinDict with. Attributes: _reverse_dict ( dict ) \u2013 A dictionary that stores the reverse mapping of values to keys. Methods: Name Description gen_reverse_dict Generates the reverse dictionary from the given dictionary. init_reverse_dict Initializes the _reverse_dict attribute. __getitem__ Returns the value associated with the given key. __del_item Deletes the item with the given key and its corresponding reverse mapping. __setitem__ Sets the value associated with the given key and updates the reverse mapping. update Updates the BinDict with the key-value pairs from other dictionaries. pop Removes and returns the value associated with the given key. popitem Removes and returns the last key-value pair in the BinDict. clear Removes all items from the BinDict. setdefault Returns the value associated with the given key, or sets it to the default value if the key is not present. __delitem__ Deletes the item with the given key and its corresponding reverse mapping. __repr__ Returns a string representation of the BinDict. Examples: >>> bin_dict = BinDict ({ 'a' : 1 , 'b' : 2 }) >>> print ( bin_dict [ 'a' ]) 1 >>> bin_dict . update ({ 'c' : 3 }) >>> print ( bin_dict ) BinDict({'a': 1, 'b': 2, 'c': 3}) >>> bin_dict . _reverse_dict [ 3 ] 'c' __delitem__ __delitem__ ( key ) Deletes the item with the given key and its corresponding reverse mapping. Parameters: key ( _KT ) \u2013 The key of the item to delete. __getitem__ __getitem__ ( __key : _KT ) -> _VT Returns the value associated with the given key. Parameters: __key ( _KT ) \u2013 The key to retrieve the value for. Returns: _VT \u2013 The value associated with the key. __init__ __init__ ( dict_ : Optional [ dict [ _KT , _VT ]] = None , * args , ** kwargs ) __repr__ __repr__ () -> str Returns a string representation of the BinDict. Returns: str \u2013 A string representation of the BinDict. __setitem__ __setitem__ ( key , value ) Sets the value associated with the given key and updates the reverse mapping. Parameters: key ( _KT ) \u2013 The key to set the value for. value ( _VT ) \u2013 The value to associate with the key. clear clear () Removes all items from the BinDict. gen_reverse_dict staticmethod gen_reverse_dict ( dict_ : dict [ _KT , _VT ]) -> dict [ _VT , _KT ] Generates a reverse dictionary from the given dictionary. Parameters: dict_ ( dict ) \u2013 The dictionary to generate the reverse dictionary from. Returns: dict \u2013 The reverse dictionary. init_reverse_dict init_reverse_dict () Initializes the _reverse_dict attribute by generating the reverse dictionary from the current dictionary. pop pop ( key , default = None ) -> _VT Removes and returns the value associated with the given key. Parameters: key ( _KT ) \u2013 The key of the item to remove. default ( any , default: None ) \u2013 The value to return if the key is not found, by default None. Returns: _VT \u2013 The value associated with the key, or the default value if the key is not found. popitem popitem () -> tuple [ _KT , _VT ] Removes and returns the last key-value pair in the BinDict. Returns: tuple \u2013 The last key-value pair in the BinDict. setdefault setdefault ( key , default = None ) -> _VT Returns the value associated with the given key, or sets it to the default value if the key is not present. Parameters: key ( _KT ) \u2013 The key to retrieve the value for. default ( any , default: None ) \u2013 The default value to set if the key is not present, by default None. Returns: _VT \u2013 The value associated with the key, or the default value if the key is not present. update update ( * args : dict [ _KT , _VT ], ** kwargs ) Updates the BinDict with the key-value pairs from other dictionaries. Parameters: *args ( dict , default: () ) \u2013 Other dictionaries to update the BinDict with. **kwargs ( key-value pairs , default: {} ) \u2013 Key-value pairs to update the BinDict with. CacheProxy Bases: Generic [ VDMT ] A generic class representing a cache proxy with options for the cache, value type, and initialization function. Parameters: cache ( VDMT or any ) \u2013 The cache to be used. value_type ( type [ VDMT ] , default: None ) \u2013 The type of values stored in the cache, by default None. value_init_func ( Callable , default: None ) \u2013 The initialization function for the cache, by default None. Attributes: KW_cache ( str ) \u2013 Keyword for the cache attribute. KW_value_type ( str ) \u2013 Keyword for the value_type attribute. Methods: Name Description value_type : type[VDMT] Getter for the value_type attribute. cache : VDMT or None Getter and setter for the cache attribute. as_dict Returns the CacheProxy object as a dictionary. from_dict Creates a CacheProxy object from a dictionary. init_cache Initializes the cache using the specified initialization function. Examples: >>> cache_instance = CacheProxy ( cache = SomeCache (), value_type = int ) >>> print ( cache_instance . value_type ) <class 'int'> >>> cache_dict = { 'cache' : SomeCache (), 'value_type' : int } >>> new_cache_instance = CacheProxy . from_dict ( cache_dict ) >>> print ( new_cache_instance ) \"CacheProxy({'cache': SomeCache(), 'value_type': int})\" KW_cache class-attribute instance-attribute KW_cache = 'cache' KW_value_type class-attribute instance-attribute KW_value_type = 'value_type' _pickleable_type class-attribute instance-attribute _pickleable_type = [] _unpickleable_type class-attribute instance-attribute _unpickleable_type = [] cache property writable cache : Union [ VDMT , None ] Getter for the cache attribute. Returns: `VDMT` or None \u2013 The current cache value. synced instance-attribute synced = False value_type property value_type : type [ VDMT ] Getter for the value_type attribute. Returns: type[`VDMT`] \u2013 The current value_type. __init__ __init__ ( cache , value_type : Optional [ type [ VDMT ]] = None , value_init_func : Optional [ Callable ] = None ) -> None Initialize the CacheProxy object. Parameters: cache ( `VDMT` or any ) \u2013 The cache to be used. value_type ( type[`VDMT`] , default: None ) \u2013 The type of values stored in the cache, by default None. value_init_func ( Callable , default: None ) \u2013 The initialization function for the cache, by default None. as_dict as_dict () -> dict Returns the CacheProxy object as a dictionary. Returns: dict \u2013 A dictionary representation of the CacheProxy object. from_dict classmethod from_dict ( dict_ : dict ) -> CacheProxy Creates a CacheProxy object from a dictionary. Parameters: dict_ ( dict ) \u2013 The dictionary containing the cache and value_type values. Returns: `CacheProxy` \u2013 A new CacheProxy object created from the provided dictionary. init_cache init_cache () -> bool Initializes the cache using the specified initialization function. Returns: bool \u2013 True if initialization was successful, False otherwise. ClusterDataIOError Bases: RuntimeError ClusterIONotExecutedWarning Bases: ClusterWarning ClusterNotRecommendWarning Bases: ClusterWarning ClusterWarning Bases: Warning DataMapExistError Bases: OSError DataMapping Bases: IOStatusManager , _RegisterInstance ['DataMapping'] , Node ['DataMapping'] , ABC , Generic [ _VT , DMT , VDMT ] An abstract class representing bidirectional mapping between data and files. Attributes: MEMORY_DATA_FILE (str) \u2013 The default filename for storing memory data. MEMORY_DATA_TYPE (type) \u2013 The default data type for memory data storage (BinDict). KEY_TYPE (type) \u2013 The type of keys used in the mapping (int). FILESHANDLE_TYPE (type) \u2013 The type of files handle used (FilesHandle). Methods: Name Description try_open Tries to open the data mapping for operation. has_not_inited Checks if the data mapping has not been initialized. _clear_empty_dir Clears empty directories in the data mapping. _rebuild_done Handles actions after the rebuild operation is completed. init_identity Initializes the identity of the data mapping. get_child Gets the child node with the specified name. save_memory_func Serializes and saves the memory data to a file. load_memory_func Loads and deserializes memory data from a file. register Registers a data mapping instance with a unique identity string. get_instance Retrieves a registered data mapping instance based on its identity string. identity_string Returns the identity string of the data mapping. identity_name Returns the identity name of the data mapping. gen_identity_string Generates a new identity string for the data mapping. gen_identity_name Generates a new identity name for the data mapping. make_path Creates the necessary directory structure for the data mapping. set_parent Sets the parent node of the data mapping. open_hook Hook method called during the open operation. stop_writing_hook Hook method called when writing is stopped. get_writing_mark_file Returns the path to the writing mark file. close Closes the data mapping. open Opens the data mapping. set_readonly Sets the data mapping to readonly mode. set_writable Sets the data mapping to writable mode. stop_writing Stops writing to the data mapping. start_writing Starts writing to the data mapping. set_overwrite_forbidden Forbids overwriting in the data mapping. set_overwrite_allowed Allows overwriting in the data mapping. remove_mark Removes the mark file associated with the data mapping. _set_MemoryData_modified Sets the flag indicating modification in memory data. _reset_MemoryData_modified Resets the flag indicating modification in memory data. MemoryData_modified: Property indicating whether memory data has been modified. MemoryData: Property representing the memory data of the mapping. MemoryData_path: Property representing the path to the memory data file. pickle_MemoryData_path: Property representing the path to the pickled memory data file. data_path: Property representing the data path of the mapping. save_preprecess Hook method for preprocessing data before saving. load_postprocess Hook method for post-processing data after loading. remove_memory_data_file Removes the memory data file. rebuild Abstract method for rebuilding the data mapping. merge_MemoryData Abstract method for merging memory data. sort Sorts the memory data. num: Property representing the number of items in the mapping. i_upper: Property representing the upper limit of indices in the mapping. next_valid_i: Property representing the next valid index in the mapping. continuous: Property indicating whether the indices in the mapping are continuous. set_io_ctrl_strategy Sets the I/O control strategy based on the provided strategy. get_io_ctrl_strategy Gets the I/O control strategy. read Abstract method for reading data from the mapping. write Abstract method for writing data to the mapping. modify_key Abstract method for modifying keys in the mapping. remove Abstract method for removing data from the mapping. merge_from Abstract method for merging data from another mapping. copy_from Abstract method for copying data from another mapping. append Appends a value to the mapping. clear Clears the data mapping. make_continuous Makes the indices in the mapping continuous. cache_to_file Caches data to files. file_to_cache Reads data from files and updates the cache. clear_files Clears the files associated with the data mapping. clear_cache Clears the cache associated with the data mapping. _set_unfinished_operation Sets the unfinished operation flag. _get_unfinished_operation Gets the unfinished operation flag. _set_last_write_unfinished Sets the flag indicating the last write operation was unfinished. _reset_last_write_unfinished Resets the flag indicating the last write operation was unfinished. _get_last_write_unfinished Gets the flag indicating the last write operation was unfinished. choose_unfinished_operation Asks the user to choose an operation to continue when an operation is unfinished. process_unfinished Processes unfinished operations in the data mapping. FILESHANDLE_TYPE class-attribute instance-attribute FILESHANDLE_TYPE : type [ FilesHandle ] = FilesHandle INDENTITY_PARA_NAMES class-attribute instance-attribute INDENTITY_PARA_NAMES = [ '_top_directory' , 'mapping_name' , 'flag_name' ] KEY_TYPE class-attribute instance-attribute KEY_TYPE = int MEMORY_DATA_FILE class-attribute instance-attribute MEMORY_DATA_FILE = '.datamap' MEMORY_DATA_TYPE class-attribute instance-attribute MEMORY_DATA_TYPE = BinDict MemoryData property MemoryData DO NOT use _MemoryData directly, use this property instead. MemoryData_modified property MemoryData_modified DO NOT use _MemoryData_modified directly, use this property instead. MemoryData_path property MemoryData_path _DMT class-attribute instance-attribute _DMT = TypeVar ( '_DMT' , bound = 'DataMapping' ) _MemoryData instance-attribute _MemoryData : dict [ int , _VT ] = self . load_postprocess ({}) _MemoryData_modified instance-attribute _MemoryData_modified = True _VDMT class-attribute instance-attribute _VDMT = TypeVar ( '_VDMT' ) cache_priority instance-attribute cache_priority = True children_names property children_names get the identity names of the children nodes continuous property continuous data_path property data_path top directory of the data mapping i_upper property i_upper load_memory_func class-attribute instance-attribute load_memory_func : Callable [[ str ], dict ] = deserialize_object next_valid_i property next_valid_i num property num pickle_MemoryData_path property pickle_MemoryData_path save_memory_func class-attribute instance-attribute save_memory_func : Callable [[ str , dict ], None ] = serialize_object strict_priority_mode instance-attribute strict_priority_mode = False top_directory property writable top_directory write_synchronous instance-attribute write_synchronous = False __getitem__ __getitem__ ( data_i : Union [ int , slice ]) __init__ __init__ ( top_directory : Union [ str , DatasetNode ], mapping_name : str = '' , * args , flag_name : str = '' , ** kwargs ) -> None Initializes the data mapping with the provided top_directory, mapping_name, and registration flag. Parameters: top_directory ( Union [ str , DatasetNode ] ) \u2013 A string or DatasetNode representing the top directory of the data mapping. mapping_name ( str , default: '' ) \u2013 A string representing the name of the data mapping. It's used as sub directory name under top_directory .for FilesCluster (the subclass of DataMapping ) flag_name ( str , default: '' ) \u2013 A string representing the registration flag. It's used to distinguish different instances of the same data mapping. __init_subclass__ __init_subclass__ ( ** kwargs ) Adds hooks to some methods. __iter__ __iter__ () -> Iterable [ VDMT ] __len__ __len__ () __new__ __new__ ( dataset_node : Union [ str , DatasetNode ], mapping_name : str = '' , * args , flag_name = '' , ** kwargs ) __repr__ __repr__ () __setitem__ __setitem__ ( data_i , value : VDMT ) _clear_empty_dir _clear_empty_dir () remove empty directories in the data mapping. _get_last_write_unfinished _get_last_write_unfinished () _get_unfinished_operation _get_unfinished_operation () _rebuild_done _rebuild_done () _reset_MemoryData_modified _reset_MemoryData_modified () _reset_last_write_unfinished _reset_last_write_unfinished () _set_MemoryData_modified _set_MemoryData_modified () this operation will be propagated to all parent nodes in preorder traversal. Examples: dm dm_child1 dm_child2 dm_child3 >>> dm_child3 . _set_MemoryData_modified () >>> dm_child2 . MemoryData_modified True >>> dm . MemoryData_modified True >>> dm_child1 . MemoryData_modified False _set_last_write_unfinished _set_last_write_unfinished () _set_unfinished_operation _set_unfinished_operation ( unfinished_operation ) append append ( value : VDMT , * , force = False , ** other_paras ) cache_to_file abstractmethod cache_to_file ( data_i : Optional [ int ] = None , * , force = False , ** other_paras ) choose_unfinished_operation choose_unfinished_operation () skip clear the unfinished data try to rollback the unfinished data exit\")) clear clear ( * , force = False ) clear_cache abstractmethod clear_cache ( * , force = False ) clear_files abstractmethod clear_files ( * , force = False ) close close ( closed = True ) see :link: IOStatusManager.close this operation will be propagated to all children nodes in preorder traversal copy_from abstractmethod copy_from ( src : DMT , * , cover = False , force = False ) -> None file_to_cache abstractmethod file_to_cache ( data_i : Optional [ int ] = None , * , save = True , force = False , ** other_paras ) gen_identity_name gen_identity_name () see :link: RegisterInstance.gen_identity_name Note if self.flag_name is not empty, return self.flag_name , otherwise return self.mapping_name gen_identity_string gen_identity_string () see :link: RegisterInstance.gen_identity_string get_child get_child ( name : str ) get the child node with the specified name get_instance classmethod get_instance ( identity_string , _obj ) see :link: RegisterInstance.get_instance get_io_ctrl_strategy get_io_ctrl_strategy () get_writing_mark_file get_writing_mark_file () has_not_inited has_not_inited () Checks if the data mapping has not been initialized. Returns: bool ( ) \u2013 True if the data mapping has not been initialized, False otherwise. identity_name identity_name () see :link: RegisterInstance.identity_name identity_string identity_string () see :link: RegisterInstance.identity_string init_identity init_identity ( parent_like : Union [ str , DatasetNode ], mapping_name : str , * args , flag_name = '' , ** kwargs ) Initializes the identity of the data mapping. Parameters: parent_like ( Union [ str , DatasetNode ] ) \u2013 A string or DatasetNode representing the parent of the data mapping. mapping_name ( str ) \u2013 A string representing the name of the data mapping. flag_name \u2013 A string representing the flag name. Raises: TypeError: \u2013 If parent_like is not a string or DatasetNode. see :link: DataMapping.__init__ for more information. items items () keys keys () load load () load self.MemoryData from file load_postprocess load_postprocess ( data ) the opertions to do after loading memory data recommend to override this method in subclass make_continuous make_continuous ( * , force = False ) make_path make_path () Create the directory path specified by self.data_path if it does not exist. If self.data_path ends with a file extension, create the parent directory and an empty file. If self.data_path does not end with a file extension, create the directory recursively. merge_MemoryData abstractmethod merge_MemoryData ( MemoryData : dict ) merge_from abstractmethod merge_from ( src : DMT , * , force = False ) -> None modify_key abstractmethod modify_key ( src : int , dst : int , * , force = False , ** other_paras ) -> None open open ( opened = True ) see :link: IOStatusManager.open this operation will be propagated to all children nodes in preorder traversal open_hook open_hook () process_unfinished process_unfinished () read abstractmethod read ( src : int ) -> VDMT rebuild abstractmethod rebuild ( force = False ) Rebuilds self.MemoryData by the files. if MemoryData_path does not exist or load_postprocess fails, this method will be called. must override this method in subclass register classmethod register ( identity_string , obj : DataMapping ) see :link: RegisterInstance.register remove abstractmethod remove ( dst : int , * , force = False , ** other_paras ) -> None remove_mark remove_mark () see :link: IOStatusManager.remove_mark this operation will be propagated to all children nodes in preorder traversal remove_memory_data_file remove_memory_data_file () remove_pickle_datamaping remove_pickle_datamaping () save save ( force = False ) save self.MemoryData to file save_as_pickle save_as_pickle ( force = False ) save_preprecess save_preprecess () the opertions to do before saving memory data recommend to override this method in subclass set_io_ctrl_strategy set_io_ctrl_strategy ( strategy ) set_overwrite_allowed set_overwrite_allowed ( overwrite_allowed = True ) see :link: IOStatusManager.set_overwrite_allowed this operation will be propagated to all children nodes in preorder traversal set_overwrite_forbidden set_overwrite_forbidden ( overwrite_forbidden = True ) see :link: IOStatusManager.set_overwrite_forbidden this operation will be propagated to all children nodes in preorder traversal set_parent set_parent ( parent : DataMapping ) set_readonly set_readonly ( readonly = True ) see :link: IOStatusManager.set_readonly this operation will be propagated to all children nodes in preorder traversal set_writable set_writable ( writable = True ) see :link: IOStatusManager.set_writable this operation will be propagated to all children nodes in preorder traversal sort sort () start_writing start_writing ( start_writing = True ) see :link: IOStatusManager.start_writing this operation will be propagated to all children nodes in preorder traversal stop_writing stop_writing ( stop_writing = True ) see :link: IOStatusManager.stop_writing this operation will be propagated to all children nodes in preorder traversal stop_writing_hook stop_writing_hook () try_open try_open () Tries to open the data mapping for operation. If the data path exists, it opens the data mapping. Otherwise, it closes the data mapping. values values () -> Generator [ VDMT , Any , None ] write abstractmethod write ( dst : int , value : VDMT , * , force = False , ** other_paras ) -> None DatasetNode Bases: DataMapping [ dict [ str , bool ], DSNT , VDST ] , ABC , Generic [ FCT , DSNT , VDST ] Represents a dataset node in the data mapping hierarchy. Attributes: MEMORY_DATA_TYPE (Table[int, str, bool]): The memory data type. MEMORY_DATA_FILE (str): The memory data file. load_memory_func (function): The function used to load memory data. save_memory_func (function): The function used to save memory data. MEMORY_DATA_FILE class-attribute instance-attribute MEMORY_DATA_FILE = '.overview' MEMORY_DATA_TYPE class-attribute instance-attribute MEMORY_DATA_TYPE = Table [ int , str , bool ] MemoryData property MemoryData : Table [ int , str , bool ] Gets the memory data. Returns: Table[int, str, bool]: The memory data. child_node_num property child_node_num : int child_nodes property child_nodes : list [ DatasetNode ] child_nodes_map instance-attribute child_nodes_map : dict [ str , DatasetNode ] = dict () cluster_use_rely property writable cluster_use_rely clusters property clusters : list [ FCT ] Gets the clusters in the dataset node. Returns: list[FCT]: The clusters. clusters_map instance-attribute clusters_map : dict [ str , FCT ] = dict () clusters_num property clusters_num : int Gets the number of clusters in the dataset node. Returns: int: The number of clusters. elem_clusters property elem_clusters : list [ FCT ] Gets the element clusters in the dataset node. Returns: list[FCT]: The element clusters. load_memory_func class-attribute instance-attribute load_memory_func = JsonIO . load_json opened_clusters property opened_clusters Gets the opened clusters in the dataset node. Returns: list[FCT]: The opened clusters. opened_elem_clusters property opened_elem_clusters Gets the opened element clusters in the dataset node. Returns: list[FCT]: The opened element clusters. save_memory_func class-attribute instance-attribute save_memory_func = JsonIO . dump_json __init__ __init__ ( top_directory : Union [ str , DatasetNode ], mapping_name : str = '' , * args , flag_name = '' , ** kwargs ) -> None Initializes a DatasetNode instance. Args: top_directory (Union[str, DatasetNode]): The top directory of the dataset node. mapping_name (str, optional): The mapping name. Defaults to \"\". flag_name (str, optional): The flag name. Defaults to \"\". args: Additional positional arguments. *kwargs: Additional keyword arguments. __setattr__ __setattr__ ( name , value ) _clear_empty_row _clear_empty_row ( data_i : int , force = False ) _move_row _move_row ( src , dst ) add_child_node add_child_node ( child_node : DatasetNode ) Adds a child node to the dataset node. Args: child_node (DatasetNode): The child node to add. add_cluster add_cluster ( cluster : FCT ) Adds a cluster to the dataset node. Args: cluster (FCT): The cluster to add. cache_to_file cache_to_file ( * , force = False ) calc_overview calc_overview ( data_i ) child_node_keys child_node_keys () Gets the keys of the child nodes in the dataset node. Returns: dict_keys: The keys of the child nodes. clear clear ( * , force = False , clear_both = True , clear_completely = False ) clear_cache clear_cache ( * , force = False ) clear_files clear_files ( * , force = False ) cluster_keys cluster_keys () Gets the keys of the clusters in the dataset node. Returns: dict_keys: The keys of the clusters. cluster_use_rely_decorator cluster_use_rely_decorator ( func ) copy_from copy_from ( src_dataset_node : DSNT , * , cover = False , force = False ) -> None file_to_cache file_to_cache ( * , force = False ) get_all_clusters get_all_clusters ( _type : Union [ type , tuple [ type ]] = None , only_opened = False ) -> dict [ int , FCT ] Gets all clusters in the dataset node. Args: _type (Union[type, tuple[type]], optional): The type of clusters to retrieve. Defaults to None. only_opened (bool, optional): Whether to retrieve only opened clusters. Defaults to False. Returns: dict[int, FCT]: A dictionary of clusters. get_child_node get_child_node ( identity_name : str ) Gets a child node from the dataset node. Args: identity_name (str): The identity name of the child node. Returns: DatasetNode: The child node. get_cluster get_cluster ( identity_name : str ) Gets a cluster from the dataset node. Args: identity_name (str): The identity name of the cluster. Returns: FCT: The cluster. init_clusters_hook init_clusters_hook () init_dataset_attr_hook init_dataset_attr_hook () Initializes the dataset attribute hook. load_postprocess load_postprocess ( data : dict ) merge_MemoryData merge_MemoryData ( MemoryData : Table [ int , str , bool ]) merge_from merge_from ( src_dataset_node : DSNT , * , force = False ) -> None modify_key modify_key ( src : int , dst : int , * , force = False , ** other_paras ) -> None operate_children_node operate_children_node ( func : Union [ Callable , str ], * args , ** kwargs ) operate_clusters operate_clusters ( func : Union [ Callable , str ], * args , ** kwargs ) operate_one_child_node operate_one_child_node ( child_node : DatasetNode , func : Union [ Callable , str ], * args , ** kwargs ) operate_one_cluster operate_one_cluster ( cluster , func : Union [ Callable , str ], * args , ** kwargs ) raw_read raw_read ( src , * , force = False , ** other_paras ) -> dict [ str , Any ] raw_write raw_write ( dst , values : dict [ str , Any ], * , force = False , ** other_paras ) -> None read read ( src : int ) -> VDST rebuild rebuild ( force = False ) remove remove ( dst : int , * , force = False , ** other_paras ) -> None remove_child_node remove_child_node ( child_node : DatasetNode ) Removes a child node from the dataset node. Args: child_node (DatasetNode): The child node to remove. remove_cluster remove_cluster ( cluster : FCT ) Removes a cluster from the dataset node. Args: cluster (FCT): The cluster to remove. save_all save_all ( force = False ) save_preprecess save_preprecess ( MemoryData : Table = None ) update_clusters update_clusters ( log_type , src , dst , value , cluster ) update_overview update_overview ( log_type , src , dst , value , cluster : FilesCluster ) write write ( dst : int , value : VDST , * , force = False , ** other_paras ) -> None FilesCluster Bases: DataMapping [ FHT , FCT , VDMT ] , Generic [ FHT , FCT , DSNT , VDMT ] FilesCluster A class representing a cluster of files. Class Attributes: _IS_ELEM _ELEM_BY_CACHE \u9700\u8981\u8bf4\u660e\u7684\u662fdata\u548celem\u7684\u5b9a\u4e49\uff1a data \u662f\u6307 FilesCluster \u5bf9\u8c61\u5305\u542b\u7684\u6587\u4ef6\uff0c\u5f53 _ELEM_BY_CACHE \u4e3a False \u65f6\uff0c \u6240\u4f7f\u7528\u7684\u7d22\u5f15\u662f\u9ed8\u8ba4\u9488\u5bf9\u5728 FilesCluster.MemoryData \u4e2d\u5bf9\u5e94\u7684 FilesHandle \u7684\u3002 \u800c\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u6587\u4ef6\u7684IO\u64cd\u4f5c\u53ef\u80fd\u662f\u4e0d\u63a8\u8350\u76f4\u63a5\u8fdb\u884c\u7684\uff0c\u800c\u5e94\u8be5\u5148\u64cd\u4f5c FilesHandle \u7684 cache \uff0c \u7136\u540e\u518d\u8c03\u7528 cache_to_file \u3002\u5426\u5219\uff0c\u5982\u679c\u6bcf\u6761\u6570\u636e\u7684\u5199\u5165\u90fd\u9700\u8981\u8fdb\u884cIO\u64cd\u4f5c\uff0c\u4f1a\u6d88\u8017\u5927\u91cf\u8d44\u6e90\u3002 \u4f8b\u5982\u4e00\u4e2a\u5305\u542b\u4e86\u591a\u6761\u6570\u636e\u7684json/xml\u6587\u4ef6\u3002\u8fd9\u65f6\u9700\u8981\u8bbe\u7f6e _ELEM_BY_CACHE \u4e3a True \uff0c \u4f7f\u5f97\u7d22\u5f15\u9ed8\u8ba4\u9488\u5bf9 elem \uff0c\u5373\u5bf9\u6240\u6709 FilesHandle \u7684cache\u540c\u540d\u7684 key \u3002 _ELEM_BY_CACHE \u7684\u503c\u4f1a\u5f71\u54cd\u4e00\u7cfb\u5217\u5c5e\u6027\u548c\u65b9\u6cd5\u7684\u9ed8\u8ba4\u8c03\u7528\uff0c\u4f60\u4e5f\u53ef\u4ee5\u8c03\u7528\u5bf9\u5e94\u7684\u660e\u786e\u65b9\u6cd5\uff1a \u5c5e\u6027\uff1a num : data_num / elem_num i_upper : data_i_upper / elem_i_upper next_valid_i : next_valid_elem_i / net_valid_data_i \u65b9\u6cd5\uff1a read : read_data / read_elem write : write_data / write_elem modify_key : modify_data_key / modity_elem_key remove : remove_data / remove_elem merge_from : merge_data_from / merge_elem_from copy_from : copy_data_from / copy_elem_from clear : clear_data / clear_elem keys : data_keys / elem_keys idx_unwritten \u4e3e\u4e2a\u4f8b\u5b50\uff0c\u5982\u679c\u5728 self.MemoryData \u4e2d\u67092\u4e2aFilesHandle\uff1a fc.MemoryData {0: fh0, 1: fh1} fh0.cache {0: array([0,1,2]), 1: array([3,4,5]) 2: array([6,7,8])} fh1.cache \u5982\u679c _ELEM_BY_CACHE \u4e3a False \uff0c\u8c03\u7528 read \u65f6\uff0c\u5b9e\u9645\u4e0a read_data \u4f1a\u88ab\u8c03\u7528 fc.read(0) # \u7b49\u6548\u4e8efc.read_data(0) \u5982\u679c _ELEM_BY_CACHE \u4e3a True \uff0c\u8c03\u7528 read \u65f6\uff0c\u5b9e\u9645\u4e0a read_elem \u4f1a\u88ab\u8c03\u7528 fc.read(0) # \u7b49\u6548\u4e8efc.read_elem(0) (array([0,1,2]), 1.0) KEY_TYPE: The type of the keys used to access the files in the cluster. ALWAYS_ALLOW_WRITE: A boolean indicating whether write operations are always allowed. ALWAYS_ALLOW_OVERWRITE: A boolean indicating whether overwriting files is always allowed. DEFAULT_SUFFIX: The default suffix for file names. DEFAULT_PREFIX: The default prefix for file names. DEFAULT_PREFIX_JOINER: The default joiner for prefix and core names. DEFAULT_APPENDNAMES: The default append names for file names. DEFAULT_APPENDNAMES_JOINER: The default joiner for append names. DEFAULT_READ_FUNC: The default function for reading files. DEFAULT_WRITE_FUNC: The default function for writing files. DEFAULT_VALUE_TYPE: The default type of the values stored in the files. DEFAULT_VALUE_INIT_FUNC: The default function for initializing values. MULTI_FILES: A boolean indicating whether the cluster contains multiple files. STRATEGY_ONLY_CACHE: The strategy for file operations when only using cache. STRATEGY_ONLY_FILE: The strategy for file operations when only using file. STRATEGY_CACHE_AND_FILE: The strategy for file operations when using both cache and file. Properties commonly used: * dataset_node: The dataset node that the cluster belongs to. * continuous: A boolean indicating whether the cluster is continuous. * num: The number of files in the cluster. * i_upper: The upper bound of the indices of the files in the cluster. Methods commonly used: * query_all_fileshandle: Queries all the file handles in the cluster. * read: Reads a file from the cluster. * write: Writes a file to the cluster. * modify_key: Modifies the key of a file in the cluster. * remove: Removes a file from the cluster. * merge_from: Merges the cluster from another cluster. * copy_from: Copies the cluster from another cluster. * append: Appends a file to the cluster. * clear: Clears the cluster. * make_continuous: Makes the cluster continuous. ALWAYS_ALLOW_OVERWRITE class-attribute instance-attribute ALWAYS_ALLOW_OVERWRITE = False ALWAYS_ALLOW_WRITE class-attribute instance-attribute ALWAYS_ALLOW_WRITE = False DEFAULT_APPENDNAMES class-attribute instance-attribute DEFAULT_APPENDNAMES = None DEFAULT_APPENDNAMES_JOINER class-attribute instance-attribute DEFAULT_APPENDNAMES_JOINER = None DEFAULT_PREFIX class-attribute instance-attribute DEFAULT_PREFIX = None DEFAULT_PREFIX_JOINER class-attribute instance-attribute DEFAULT_PREFIX_JOINER = None DEFAULT_READ_FUNC class-attribute instance-attribute DEFAULT_READ_FUNC = None DEFAULT_SUFFIX class-attribute instance-attribute DEFAULT_SUFFIX = None DEFAULT_VALUE_INIT_FUNC class-attribute instance-attribute DEFAULT_VALUE_INIT_FUNC = None DEFAULT_VALUE_TYPE class-attribute instance-attribute DEFAULT_VALUE_TYPE = None DEFAULT_WRITE_FUNC class-attribute instance-attribute DEFAULT_WRITE_FUNC = None KEY_TYPE class-attribute instance-attribute KEY_TYPE = int xyz MULTI_FILES class-attribute instance-attribute MULTI_FILES = False MemoryData property MemoryData : BinDict [ int , FHT ] STRATEGY_CACHE_AND_FILE class-attribute instance-attribute STRATEGY_CACHE_AND_FILE = 2 STRATEGY_ONLY_CACHE class-attribute instance-attribute STRATEGY_ONLY_CACHE = 0 STRATEGY_ONLY_FILE class-attribute instance-attribute STRATEGY_ONLY_FILE = 1 _ELEM_BY_CACHE class-attribute instance-attribute _ELEM_BY_CACHE = False _FCT class-attribute instance-attribute _FCT = TypeVar ( '_FCT' , bound = 'FilesCluster' ) _FHT class-attribute instance-attribute _FHT = TypeVar ( '_FHT' , bound = FilesHandle ) _IS_ELEM class-attribute instance-attribute _IS_ELEM = False _VDMT class-attribute instance-attribute _VDMT = TypeVar ( '_VDMT' ) continuous property continuous data_continuous property data_continuous data_i_upper property data_i_upper data_num property data_num dataset_node property dataset_node : DatasetNode elem_continuous property elem_continuous elem_i_upper property elem_i_upper elem_num property elem_num i_upper property i_upper next_valid_data_i property next_valid_data_i next_valid_elem_i property next_valid_elem_i next_valid_i property next_valid_i num property num registerd property registerd use_rely property use_rely Check if use rely _change_dir Bases: _operation [ _FCT , _VDMT , _FHT ] W_SYNC class-attribute instance-attribute W_SYNC = True core_func instance-attribute core_func = os . rename __init__ __init__ ( files_cluster ) -> None check_value check_value ( value : str ) cvt_to_core_paras cvt_to_core_paras ( src_file_handle : FilesHandle , dst_file_handle : FilesHandle , value : FilesHandle , ** other_paras ) -> tuple get_FilesHandle get_FilesHandle ( src , dst , value : str ) io_cache io_cache ( src_file_handle , dst_file_handle , value = None ) -> Any _modify_key Bases: IOMeta [ _FCT , _VDMT , _FHT ] LOG_TYPE class-attribute instance-attribute LOG_TYPE = IOStatusManager . LOG_MOVE READ class-attribute instance-attribute READ = False W_SYNC class-attribute instance-attribute W_SYNC = True core_func instance-attribute core_func = os . rename __init__ __init__ ( files_cluster ) -> None cvt_to_core_paras cvt_to_core_paras ( src_file_handle : FilesHandle , dst_file_handle : FilesHandle , value , ** other_paras ) -> tuple get_FilesHandle get_FilesHandle ( src , dst , value , ** other_paras ) io_cache io_cache ( src_file_handle , dst_file_handle : FilesHandle , value = None ) -> Any _operation Bases: IOMeta [ _FCT , _VDMT , _FHT ] LOG_TYPE class-attribute instance-attribute LOG_TYPE = IOStatusManager . LOG_OPERATION READ class-attribute instance-attribute READ = False _paste_file Bases: IOMeta [ _FCT , _VDMT , _FHT ] LOG_TYPE class-attribute instance-attribute LOG_TYPE = IOStatusManager . LOG_ADD PATH_EXISTS_REQUIRED class-attribute instance-attribute PATH_EXISTS_REQUIRED = True READ class-attribute instance-attribute READ = False core_func instance-attribute core_func = shutil . copy __init__ __init__ ( files_cluster ) -> None cvt_to_core_paras cvt_to_core_paras ( src_file_handle : FilesHandle , dst_file_handle : FilesHandle , value : FilesHandle , ** other_paras ) -> tuple get_FilesHandle get_FilesHandle ( src , dst , value , ** other_paras ) io_cache io_cache ( src_file_handle , dst_file_handle : FilesHandle , value : FilesHandle = None ) -> Any _read Bases: IOMeta [ _FCT , _VDMT , _FHT ] cvt_to_core_paras cvt_to_core_paras ( src_file_handle : FilesHandle , dst_file_handle : FilesHandle , value , ** other_paras ) -> tuple get_FilesHandle get_FilesHandle ( src , dst , value , ** other_paras ) get_file_core_func get_file_core_func ( src_file_handle : FHT , dst_file_handle : FHT , value ) -> Callable io_cache io_cache ( src_file_handle : FilesHandle , dst_file_handle , value = None ) -> Any _remove Bases: IOMeta [ _FCT , _VDMT , _FHT ] LOG_TYPE class-attribute instance-attribute LOG_TYPE = IOStatusManager . LOG_REMOVE READ class-attribute instance-attribute READ = False core_func instance-attribute core_func = os . remove __init__ __init__ ( files_cluster ) -> None check_dst check_dst ( dst ) cvt_to_core_paras cvt_to_core_paras ( src_file_handle : FilesHandle , dst_file_handle : FilesHandle , value , ** other_paras ) -> tuple get_FilesHandle get_FilesHandle ( src , dst , value , ** other_paras ) io_cache io_cache ( src_file_handle , dst_file_handle : FilesHandle , value = None ) -> Any _write Bases: IOMeta [ _FCT , _VDMT , _FHT ] LOG_TYPE class-attribute instance-attribute LOG_TYPE = IOStatusManager . LOG_ADD PATH_EXISTS_REQUIRED class-attribute instance-attribute PATH_EXISTS_REQUIRED = False READ class-attribute instance-attribute READ = False cvt_to_core_paras cvt_to_core_paras ( src_file_handle : FilesHandle , dst_file_handle : FilesHandle , value , ** other_paras ) -> tuple get_FilesHandle get_FilesHandle ( src , dst , value , ** other_paras ) get_file_core_func get_file_core_func ( src_file_handle , dst_file_handle : FilesHandle , value ) -> Callable [ ... , Any ] io_cache io_cache ( src_file_handle , dst_file_handle : FilesHandle , value = None ) -> Any __contains__ __contains__ ( i ) __init__ __init__ ( dataset_node : Union [ str , DatasetNode ], mapping_name : str , * args , flag_name = '' , ** kwargs ) -> None _clear_rely _clear_rely () _get_rely _get_rely ( name ) _pop_fileshandle _pop_fileshandle ( data_i ) Pop the file handle for the given data index from the MemoryData dictionary. Args: data_i (int): The index of the data. Returns: object: The popped file handle. _send_rely _send_rely ( rlt ) send parameters to the relying clusters _set_fileshandle _set_fileshandle ( data_i , fileshandle : FHT ) Set the fileshandle for the given data index. Parameters: data_i (int): The index of the data. fileshandle (FHT): The fileshandle to be set. Returns: bool: True if the fileshandle is set successfully, False otherwise. _set_rely _set_rely ( relied : FilesCluster , rlt ) set relied parameters from the relied cluster, relied is the cluster that send the parameters, rlt is the parameters _switch_io_operation _switch_io_operation ( io_data_func , io_elem_func ) _update_rely _update_rely ( name , rlt ) cache_to_file cache_to_file ( data_i : int = None , * , force = False , ** other_paras ) change_dir change_dir ( dst : int , new_dir_name , * , force = False , ** other_paras ) -> None clear clear ( * , force = False , clear_both = True ) clear_cache clear_cache ( * , force = False ) clear_data clear_data ( * , force = False , clear_both = True ) clear_elem clear_elem ( * , force = False , clear_both = True ) clear_files clear_files ( * , force = False ) copy_data_from copy_data_from ( src_data_map : FCT , * , cover = False , force = False ) copy_elem_from copy_elem_from ( src_data_map : FCT , * , cover = False , force = False ) copy_from copy_from ( src_data_map : FCT , * , cover = False , force = False ) create_fh classmethod create_fh ( path ) create_fileshandle_in_iometa abstractmethod create_fileshandle_in_iometa ( src , dst , value , ** other_paras ) -> FHT cvt_key cvt_key ( key ) data_keys data_keys () deformat_corename deformat_corename ( corename : str ) -> int Deformats the core name of the data. * recommended to be overridden in subclasses e.g.: \"000001\" -> 1 \"000309\" -> 309 Args: corename (str): The core name. Returns: int elem_keys elem_keys () file_to_cache file_to_cache ( data_i : int = None , * , save = True , force = False , auto_decide = True , ** other_paras ) format_corename format_corename ( data_i : int ) -> str Formats the core name of the data. * recommended to be overridden in subclasses e.g.: 1 -> \"000001\" 309 -> \"000309\" Args: data_i (int): The data index. Returns: str from_cluster classmethod from_cluster ( cluster : FCT , dataset_node : DSNT = None , mapping_name = None , * args , flag_name = '' , ** kwargs ) -> FCT get_rely_io_parameters get_rely_io_parameters () has has ( i ) has_data has_data ( elem_i ) has_elem has_elem ( elem_i ) idx_unwrited idx_unwrited ( idx ) init_attrs init_attrs () init_io_metas init_io_metas () io_decorator io_decorator ( io_meta : IOMeta , force = False ) Decorator function for input/output operations. Args: io_meta (IOMeta): The metadata object for the input/output operation. force (bool): Flag indicating whether to force the operation. Defaults to False. Returns: function: The decorated function. keys keys () link_rely_on link_rely_on ( cluster : FilesCluster ) Links the current cluster to the specified cluster as a relying cluster. Details: The IO of the cluster may depend on other clusters. For example, the normalized pixel coordinates depend on the size of the image. In this case, you can use link_rely_on to set the cluster that self depends on. relying_clusters: those clusters that rely on self relied_clusters: those clusters that self relies on Args: cluster (FilesCluster): The cluster to be linked as a relying cluster. load_and_process_data load_and_process_data ( key , value ) load_postprocess load_postprocess ( data : dict ) matching_path matching_path () merge_MemoryData merge_MemoryData ( MemoryData : BinDict [ int , FHT ]) merge_data_from merge_data_from ( src_data_map : FCT , * , force = False ) merge_elem_from merge_elem_from ( src_data_map : FCT , * , force = False ) merge_from merge_from ( src_data_map : FCT , * , force = False ) modify_data_key modify_data_key ( src : int , dst : int , * , force = False , ** other_paras ) -> None modify_elem_key modify_elem_key ( src : int , dst : int , * , force = False , ** other_paras ) modify_key modify_key ( src : int , dst : int , * , force = False , ** other_paras ) -> None paste_file paste_file ( dst : int , file_handler : FilesHandle , * , force = False , ** other_paras ) -> None query_all_fileshandle query_all_fileshandle () Returns all the file handles stored in the MemoryData dictionary. Returns: list: A list of file handles. query_fileshandle query_fileshandle ( data_i : int ) -> FHT Retrieve the fileshandle at the specified index from the MemoryData. Args: data_i (int): The index of the fileshandle to retrieve. Returns: FHT: The fileshandle at the specified index. query_fileshandle_from_iterable query_fileshandle_from_iterable ( iterable : Union [ Iterable , slice ]) -> Generator [ FHT , Any , None ] Queries fileshandle from an iterable or a slice. Args: iterable (Union[Iterable, slice]): An iterable or a slice. Yields: Generator[FHT, Any, None]: A generator that yields fileshandle. Returns: None read read ( src : int , * , force = False , ** other_paras ) -> VDMT read_data read_data ( src : int , * , force = False , ** other_paras ) -> VDMT read_elem read_elem ( src : int , * , force = False , ** other_paras ) rebuild rebuild ( force = False ) remove remove ( dst : int , remove_both = False , * , force = False , ** other_paras ) -> None remove_data remove_data ( dst : int , remove_both = False , * , force = False , ** other_paras ) -> None remove_elem remove_elem ( dst : int , * , force = False , ** other_paras ) save_preprecess save_preprecess ( MemoryData : BinDict [ int , FHT ] = None ) unlink_rely_on unlink_rely_on ( cluster : FilesCluster ) Unlinks the cluster from relying. Args: cluster (FilesCluster): The cluster to be unlinked from relying. write write ( dst : int , value : VDMT , * , force = False , ** other_paras ) -> None write_data write_data ( dst : int , value : VDMT , * , force = False , ** other_paras ) -> None write_elem write_elem ( dst : int , value : VDMT , * , force = False , ** other_paras ) FilesHandle Bases: _RegisterInstance ['FilesHandle'] , Generic [ FCT , VDMT ] Note A class representing a file handle for input/output operations. Its instance manages some attributes of one file or a group of files, depending on the value of the multi_files attribute. Its instance is immutable object, once created, it can't be changed. Parameters: cluster ( FCT ) \u2013 The cluster to which the file handle belongs. data_path ( str , default: '' ) \u2013 The top path to the file or directory. sub_dir ( str ) \u2013 The subdirectory of the file or directory. Defaults to \"\". corename ( str ) \u2013 The corename of the file or directory. Defaults to \"\". suffix ( str ) \u2013 The suffix of the file or directory. Defaults to \"\". _appendnames_obj \u2013 The _AppendNames object. Defaults to None. _prefix_obj \u2013 The _Prefix object. Defaults to None. read_func ( Optional [ Callable ] , default: None ) \u2013 The function to be used for reading the file. Defaults to None. write_func ( Optional [ Callable ] , default: None ) \u2013 The function to be used for writing the file. Defaults to None. cache_proxy \u2013 The cache proxy to be used. Defaults to None. Examples: >>> cluster = FilesCluster ( \"./top\" ) >>> fh = FilesHandle ( cluster , sub_dir = \"sub\" , corename = \"core\" , suffix = \".txt\" ) >>> fh . get_path () \"./top/sub/core.txt\" >>> fh2 = FilesHandle ( cluster , sub_dir = \"sub\" , corename = \"core\" , suffix = \".txt\" , prefix = \"prefix\" , appendnames = [ \"append1\" , \"append2\" ], prefix_joiner = \"-\" , appendnames_joiner = \"_\" ) >>> fh2 . get_path () ['./top/sub/prefix-core_append1.txt', './top/sub/prefix-core_append2.txt'] DEFAULT_APPENDNAMES class-attribute instance-attribute DEFAULT_APPENDNAMES = None can be overrided by subclass DEFAULT_APPENDNAMES_JOINER class-attribute instance-attribute DEFAULT_APPENDNAMES_JOINER = None can be overrided by subclass DEFAULT_FILE_TYPE class-attribute instance-attribute DEFAULT_FILE_TYPE = { '.json' : [ JsonIO . load_json , JsonIO . dump_json , dict ], '.npy' : [ partial ( np . load , allow_pickle = True ), partial ( np . save , allow_pickle = True ), None ], '.npz' : [ partial ( np . load , allow_pickle = True ), partial ( np . savez , allow_pickle = True ), None ], '.pkl' : [ deserialize_object , serialize_object , None ], '.txt' : [ read_file_as_str , write_str_to_file , None ], '.png' : [ cv2 . imread , cv2 . imwrite , None ], '.jpg' : [ cv2 . imread , cv2 . imwrite , None ], '.jpeg' : [ cv2 . imread , cv2 . imwrite , None ], '.bmp' : [ cv2 . imread , cv2 . imwrite , None ], '.tif' : [ cv2 . imread , cv2 . imwrite , None ]} some default file type and their read/write functions DEFAULT_PREFIX class-attribute instance-attribute DEFAULT_PREFIX = None can be overrided by subclass DEFAULT_PREFIX_JOINER class-attribute instance-attribute DEFAULT_PREFIX_JOINER = None can be overrided by subclass DEFAULT_READ_FUNC class-attribute instance-attribute DEFAULT_READ_FUNC = None can be overrided by subclass DEFAULT_SUFFIX class-attribute instance-attribute DEFAULT_SUFFIX = None can be overrided by subclass DEFAULT_VALUE_INIT_FUNC class-attribute instance-attribute DEFAULT_VALUE_INIT_FUNC = None can be overrided by subclass DEFAULT_VALUE_TYPE class-attribute instance-attribute DEFAULT_VALUE_TYPE = None can be overrided by subclass DEFAULT_WRITE_FUNC class-attribute instance-attribute DEFAULT_WRITE_FUNC = None can be overrided by subclass GET_INSTANCE_STRATEGY class-attribute instance-attribute GET_INSTANCE_STRATEGY = 0 control the strategy of get_instance 0: return the inited instance, 1: return the original instance and cover the inited instance 2: return the original instance and not register it INDENTITY_PARA_NAMES class-attribute instance-attribute INDENTITY_PARA_NAMES = [ 'sub_dir' , 'corename' , 'suffix' , 'prefix' , 'appendnames' , 'prefix_joiner' , 'appendnames_joiner' , 'data_path' ] KW_FUNC_BIND_ARGS class-attribute instance-attribute KW_FUNC_BIND_ARGS = 'func_bind_args' KW_FUNC_BIND_KWARGS class-attribute instance-attribute KW_FUNC_BIND_KWARGS = 'func_bind_kwargs' KW_FUNC_MODULE class-attribute instance-attribute KW_FUNC_MODULE = 'func_module' KW_FUNC_NAME class-attribute instance-attribute KW_FUNC_NAME = 'func_name' KW_INIT_WITHOUT_CACHE class-attribute instance-attribute KW_INIT_WITHOUT_CACHE = 'INIT_WITHOUT_CACHE' KW_appendnames class-attribute instance-attribute KW_appendnames = 'appendnames' KW_cache class-attribute instance-attribute KW_cache = 'cache' KW_corename class-attribute instance-attribute KW_corename = 'corename' KW_data_path class-attribute instance-attribute KW_data_path = 'data_path' KW_prefix class-attribute instance-attribute KW_prefix = 'prefix' KW_read_func class-attribute instance-attribute KW_read_func = 'read_func' KW_sub_dir class-attribute instance-attribute KW_sub_dir = 'sub_dir' KW_suffix class-attribute instance-attribute KW_suffix = 'suffix' KW_write_func class-attribute instance-attribute KW_write_func = 'write_func' LOAD_CACHE_ON_INIT class-attribute instance-attribute LOAD_CACHE_ON_INIT = False can be overrided by subclass if True, load cache from disk when init all_file_exist property all_file_exist all_file_not_exist property all_file_not_exist any_file_exist property any_file_exist any_file_not_exist property any_file_not_exist appendnames property appendnames : Union [ list [ str ], str ] appendnames_with_joiner property appendnames_with_joiner : Union [ list [ str ], str ] cache property cache : Union [ VDMT , None ] Returns the cache of the instance. If is_readonly == True , returns a shallow copy of the cache object. Else, returns the cache object. Returns: Union[VDMT, None]: The cache object or a shallow copy of the cache object. \u2013 cache_proxy instance-attribute cache_proxy : CacheProxy [ VDMT ] = CacheProxy [ VDMT ]( cache , value_type , default_value_type ) empty property empty Check if the object does not have cache and all files do not exist. Returns: bool ( True if the object is empty, False otherwise. ) \u2013 file_exist_status property file_exist_status : list [ bool ] Returns: list[bool]: \u2013 A list of boolean values indicating whether each file exists. full_directory property full_directory the full directory of the file(s) has_cache property has_cache is_closed property is_closed self.cluster.closed is_readonly property is_readonly self.cluster.readonly multi_files property multi_files Code self.cluster.MULTI_FILES Note multi_files is decided by self.cluster . It indicates how to deal with the appendnames. see :link: FilesCluster.MULTI_FILES , :link: FilesHandle.get_name , :link: FilesHandle.get_path overwrite_forbidden property overwrite_forbidden self.cluster.readonly prefix property prefix : str prefix_with_joiner property prefix_with_joiner : str read_func instance-attribute read_func = read_func synced property synced Whether the cache is synced with the file(s). Note Each FilesHandle instance corresponds to one (or more) files. When performing IO operations, you can directly perform IO operations on the files, or you can modify the cache of the FilesHandle instance in memory. See :link: IO_CTRL_STRATEGY for details. When only files are written, or only cache is modified, the data in file(s) and cache are asynchronous, and synced is False. To make synced be True , there are the following 3 methods: Call cache_to_file or file_to_cache of the FilesCluster instance (hereinafter referred to as cluster ) to which the FilesHandle instance belongs to manually synchronize data. Inherit `FilesCluster` and `FilesCluster._write` (assumed the subclasses to be named `NewFC`, `NewFC._write`), and rewrite the `W_SYNC` parameter of `NewFC._write` to True. This will modify the IO operation logic. When NewFC.write is called, `file(s)` and `cache` are written/modified synchronously. But please pay special attention: Frequent IO operations will consume a lot of resources, especially when the file is large. Therefore, when a large amount of data needs to be written, it is still recommended to modify `cache` first and then call `cache_to_file`. (Not recommended) When writing data, call set_io_ctrl_strategy of `cluster`. valid property valid self.cluster is not None value_type property value_type : type [ VDMT ] write_func instance-attribute write_func = write_func __eq__ __eq__ ( o : object ) -> bool compare the identity_string of two FilesHandle objects __hash__ __hash__ () hash(self.identity_string()) __init__ __init__ ( cluster : FCT , sub_dir : str , corename : str , suffix : str , * , prefix : Optional [ str ] = None , appendnames : Union [ str , list [ str ]] = None , prefix_joiner : Optional [ str ] = None , appendnames_joiner : Optional [ str ] = None , data_path : str = '' , read_func : Optional [ Callable ] = None , write_func : Optional [ Callable ] = None , cache = None , value_type : Optional [ type [ VDMT ]] = None ) -> None Initialize the IOAbstract class. Parameters: cluster ( FCT ) \u2013 The cluster object. sub_dir ( str ) \u2013 The sub-directory. corename ( str ) \u2013 The core name. suffix ( str ) \u2013 The suffix. prefix ( Optional [ str ] , default: None ) \u2013 The prefix. Defaults to None. appendnames ( Union [ str , list [ str ]] , default: None ) \u2013 The append names. Defaults to None. prefix_joiner ( Optional [ str ] , default: None ) \u2013 The prefix joiner. Defaults to None. appendnames_joiner ( Optional [ str ] , default: None ) \u2013 The append names joiner. Defaults to None. data_path ( str , default: '' ) \u2013 The data path. Defaults to \"\". read_func ( Optional [ Callable ] , default: None ) \u2013 The read function. Defaults to None. write_func ( Optional [ Callable ] , default: None ) \u2013 The write function. Defaults to None. cache \u2013 The cache. Defaults to None. value_type ( Optional [ type [ VDMT ]] , default: None ) \u2013 The value type. Defaults to None. Returns: None \u2013 __init_subclass__ __init_subclass__ ( ** kwargs ) __repr__ __repr__ () -> str __setattr__ __setattr__ ( name , value ) _default_parse_file_name staticmethod _default_parse_file_name ( file_name : str , prefix_joiner : str , appendnames_joiner : str , _extract_corename_func : Optional [ Callable ] = None ) Parses the given file name and extracts corename see :link: _parse_one_path_to_paras , :link: _parse_path_to_name Parameters: file_name ( str ) \u2013 The file name to be parsed. prefix_joiner ( str ) \u2013 The character or string used to join the prefix with the rest of the file name. appendnames_joiner ( str ) \u2013 The character or string used to join the core name with the append name. _extract_corename_func ( Optional [ Callable ] , default: None ) \u2013 Optional function to extract the core name from the file name. Used for custom parsing. Returns: tuple ( A tuple containing the following components: ) \u2013 sub_dir (str): The sub-directory of the file. corename (str): The core name of the file. suffix (str): The file suffix. prefix (str): The prefix of the file name. appendname (str): The append name of the file. _prefix_joiner: The prefix joiner used. _appendnames_joiner: The append names joiner used. Examples: >>> FilesHandle . _default_parse_file_name ( \"sub_dir/pre_corename-append.txt\" , \"_\" , \"-\" ) >>> ( 'sub_dir' , 'corename' , '.txt' , 'pre' , 'append' , '_' , '-' ) _parse_one_path_to_paras staticmethod _parse_one_path_to_paras ( cluster : FilesCluster , path : str , prefix_joiner : str , appendnames_joiner : str ) Parses a single path to extract various parameters. see :link: _parse_path_to_name and :link: _default_parse_file_name for more details. Parameters: cluster ( FilesCluster ) \u2013 The FilesCluster object. path ( str ) \u2013 The path to be parsed. prefix_joiner ( str ) \u2013 The prefix joiner. appendnames_joiner ( str ) \u2013 The append names joiner. Returns: tuple ( ) \u2013 A tuple containing the following parameters: - sub_dir (str): The sub directory. - corename (str): The core name. - suffix (str): The suffix. - prefix (str): The prefix. - appendname (str): The append name. - prefix_joiner: The prefix joiner. - appendnames_joiner: The append names joiner. _parse_path_to_name staticmethod _parse_path_to_name ( cluster : FilesCluster , path : T_MUITLSTR ) -> T_MUITLSTR Parses the given path or list of paths to extract the filename(s) relative to the data_path of the cluster. see :link: _parse_one_path_to_paras see :link: _parse_one_path_to_paras and :link: _default_parse_file_name , Parameters: cluster ( FilesCluster ) \u2013 The FilesCluster object. path ( T_MUITLSTR ) \u2013 The path(s) to be parsed. Returns: T_MUITLSTR ( ) \u2013 The filename(s) relative to the data_path of the cluster. Raises: AssertionError: \u2013 If the path is not a subpath of the data_path. AssertionError: \u2013 If the path is not a string or a list of strings. _set_synced _set_synced ( synced : bool = True ) Set the synchronization status of the cache. Parameters: synced ( bool , default: True ) \u2013 Note DO NOT call this function directly, use cache_to_file or file_to_cache instead. Returns: None _unsafe_get_cache _unsafe_get_cache () -> Union [ VDMT , None ] Get cache without any check NOT recommended, use with caution add_appendname add_appendname ( appendname ) as_dict as_dict () convert the FilesHandle to a dict Returns: dict \u2013 clear_notfound clear_notfound () clear those files which are not found create_new_and_cover classmethod create_new_and_cover () Creates a new instance of the class by setting the GET_INSTANCE_STRATEGY to 1 . GET_INSTANCE_STRATEGY will automatically be reset to 0 after a new instance is created. the new instance will cover the old instance with the same identity_string. Returns: cls ( ) \u2013 The modified class with the GET_INSTANCE_STRATEGY attribute set to 1 . Examples: >>> path = \"./sub/core.txt\" >>> cluster = FilesCluster ( \"./top\" ) >>> fh = FilesHandle . from_path ( cluster , path ) # OK >>> fh2 = FilesHandle . from_path ( cluster , path ) # OK, fh and fh2 are the same instance >>> fh3 = FilesHandle . create_new_and_cover () . from_path ( cluster , path ) # OK, fh3 is a new instance, and it is registered and covers the old instance. >>> FilesHandle . has_instance ( fh3 ) True >>> FilesHandle . has_instance ( fh ) False create_not_exist_fileshandle classmethod create_not_exist_fileshandle ( cluster : FCT ) Create a file handle for a non-existent file. Parameters: cluster ( FCT ) \u2013 The cluster object. Returns: FilesHandle \u2013 An instance of the class for the non-existent file. create_temp classmethod create_temp () Creates a temporary instance of the class. This method sets the GET_INSTANCE_STRATEGY attribute of the class to 2 and returns the modified class. GET_INSTANCE_STRATEGY will automatically be reset to 0 after a new instance is created. the new instance will not be registered. Returns: cls ( ) \u2013 The modified class with the GET_INSTANCE_STRATEGY attribute set to 2 . Examples: >>> path = \"./sub/core.txt\" >>> cluster = FilesCluster ( \"./top\" ) >>> fh = FilesHandle . from_path ( cluster , path ) # OK >>> fh2 = FilesHandle . from_path ( cluster , path ) # OK, fh and fh2 are the same instance >>> fh3 = FilesHandle . create_temp () . from_path ( cluster , path ) # OK, fh3 is a new instance, and it is not registered. erase_cache erase_cache () Erase the cache. Note If self.is_readonly == True or self.is_closed == True , the cache will not be erased. export_func classmethod export_func ( func : Union [ Callable , None ]) Export a function for serialization. If the function is unpickleable, it returns a dictionary containing Args func (Callable or None): The function to be exported. Returns: Union[dict, Callable, None]: \u2013 If the function is unpickleable, it returns a dictionary containing information about the function. Otherwise, it returns the function itself. from_dict classmethod from_dict ( cluster : FCT , dict_ : dict ) create a FilesHandle from a dict Returns: FilesHandle \u2013 from_fileshandle classmethod from_fileshandle ( cluster : FCT , file_handle : FilesHandle , * , sub_dir : Optional [ str ] = None , corename : Optional [ str ] = None , suffix : Optional [ str ] = None , prefix : Optional [ str ] = None , appendnames : Union [ str , list [ str ]] = None , prefix_joiner : Optional [ str ] = None , appendnames_joiner : Optional [ str ] = None , read_func : Optional [ Callable ] = None , write_func : Optional [ Callable ] = None , cache = None , value_type : Optional [ type ] = None ) Create an instance of the class from another fileshandle object. Parameters: cluster ( FCT ) \u2013 The cluster object. file_handle ( FilesHandle ) \u2013 The file handle object. sub_dir ( str , default: None ) \u2013 The sub-directory path. Defaults to None. corename ( str , default: None ) \u2013 The core name. Defaults to None. suffix ( str , default: None ) \u2013 The file suffix. Defaults to None. prefix ( str , default: None ) \u2013 The file prefix. Defaults to None. appendnames ( str or list [ str ] , default: None ) \u2013 The append names. Defaults to None. prefix_joiner ( str , default: None ) \u2013 The joiner for prefix and append names. Defaults to None. appendnames_joiner ( str , default: None ) \u2013 The joiner for append names. Defaults to None. read_func ( Callable , default: None ) \u2013 The read function. Defaults to None. write_func ( Callable , default: None ) \u2013 The write function. Defaults to None. cache ( optional , default: None ) \u2013 The cache object. Defaults to None. value_type ( type , default: None ) \u2013 The value type. Defaults to None. Returns: FilesHandle \u2013 An instance of the class. from_name classmethod from_name ( cluster : FCT , filename : Union [ str , list [ str ]], * , prefix_joiner : Optional [ str ] = None , appendnames_joiner : Optional [ str ] = None , read_func : Optional [ Callable ] = None , write_func : Optional [ Callable ] = None , cache = None , value_type : Optional [ type ] = None , _extract_corename_func : Optional [ Callable [[ str ], tuple [ str , str , str , str , str ]]] = None ) Create an instance of the class using the given file name. Parameters: cluster ( FCT ) \u2013 The FilesCluster object. filename ( Union [ str , List [ str ]] ) \u2013 The name of the file, can be a string or a list of strings. prefix_joiner ( Optional [ str ] , default: None ) \u2013 The joiner between prefix and corename. appendnames_joiner ( Optional [ str ] , default: None ) \u2013 The joiner between appendnames. read_func ( Optional [ Callable ] , default: None ) \u2013 The function to read the file. write_func ( Optional [ Callable ] , default: None ) \u2013 The function to write the file. cache ( any , default: None ) \u2013 The cache object. value_type ( Optional [ type ] , default: None ) \u2013 The type of the cache object. _extract_corename_func ( Optional [ Callable [[ str ], tuple [ str , str , str , str , str ]]] , default: None ) \u2013 The function to extract the corename, the function should return a tuple: (sub_dir, corename, suffix, prefix, appendname, _prefix_joiner, _appendnames_joiner) Returns: FilesHandle \u2013 An instance of the class. Raises: AssertionError \u2013 If the filename is not a string or a list of strings. If the sub_dir, corename, suffix, prefix, or appendname are not the same for all filenames in the list. Examples: >>> instance = FilesHandle . from_name ( cluster , \"filename.txt\" ) >>> instance = FilesHandle . from_name ( cluster , [ \"file_1.txt\" , \"file_2.txt\" ], appendnames_joiner = \"_\" ) from_path classmethod from_path ( cluster : FCT , path : Union [ str , list [ str ]], * , prefix_joiner : Optional [ str ] = None , appendnames_joiner : Optional [ str ] = None , read_func : Optional [ Callable ] = None , write_func : Optional [ Callable ] = None , cache : Optional = None , value_type : Optional [ type ] = None , _extract_corename_func : Optional [ Callable [[ str ], tuple [ str , str , str , str , str ]]] = None ) -> Any Create a fileshandle object from a file path or a list of file paths. Parameters: cluster ( FCT ) \u2013 The cluster object. path ( Union [ str , list [ str ]] ) \u2013 The file path or a list of file paths. prefix_joiner ( Optional [ str ] , default: None ) \u2013 The prefix joiner. Defaults to None. appendnames_joiner ( Optional [ str ] , default: None ) \u2013 The append names joiner. Defaults to None. read_func ( Optional [ Callable ] , default: None ) \u2013 The read function. Defaults to None. write_func ( Optional [ Callable ] , default: None ) \u2013 The write function. Defaults to None. cache ( Optional , default: None ) \u2013 The cache object. Defaults to None. value_type ( Optional [ type ] , default: None ) \u2013 The value type. Defaults to None. _extract_corename_func ( Optional [ Callable [[ str ], tuple [ str , str , str , str , str ]]] , default: None ) \u2013 The extract core name function. Defaults to None. Returns: Any ( The fileshandle object. ) \u2013 gen_identity_name gen_identity_name () gen_identity_string gen_identity_string () get_default_file_type classmethod get_default_file_type ( file : str ) Get the default file type for a given file. If the file type is not found in the DEFAULT_FILE_TYPE dictionary, None is returned. Parameters: file ( str ) \u2013 The file name or path. Returns: tuple ( ) \u2013 A tuple containing the read function, write function, and value type associated with the file type. If the file type is not found in the DEFAULT_FILE_TYPE dictionary, None is returned for all three values. get_dir get_dir () the full directory of the file(s) get_instance classmethod get_instance ( identity_string , orig_obj : FilesHandle ) Get an instance of the class based on the specified identity string and original object. Note the strategy is controled by GET_INSTANCE_STRATEGY 0: return the inited instance, 1: return the original instance and cover the inited instance 2: return the original instance and not register it Parameters: identity_string \u2013 The identity string. orig_obj ( FilesHandle ) \u2013 The original object. Returns: FilesHandle ( ) \u2013 The instance of the class. Raises: ValueError: \u2013 If GET_INSTANCE_STRATEGY is not 0, 1, or 2. get_key get_key () Get its key in the self.cluster.MemoryData get_name get_name ( get_list : bool = False ) -> Union [ list [ str ], str ] Returns the name of the file(s). Parameters: get_list ( bool , default: False ) \u2013 If True, returns a list of names. Defaults to False. If multi_files is True, returns a list of names regardless of the value of get_list . Returns: Union[list[str], str]: The name(s) of the file(s). get_path get_path ( get_list = False ) -> Union [ list [ str ], str ] Returns the path of the file(s) associated with the object. Parameters: get_list \u2013 If True, returns a list of paths. Defaults to False. If multi_files is True, returns a list of paths regardless of the value of get_list . Returns: Union[list[str], str]: \u2013 The path(s) of the file(s). has_not_inited has_not_inited () immutable_attr_same_as immutable_attr_same_as ( object : FilesHandle ) -> bool Check if the immutable attributes of the current object are the same as another FilesHandle object. Immutable attributes include data_path sub_dir corename suffix prefix appendnames read_func write_func value_type Parameters: object ( FilesHandle ) \u2013 The FilesHandle object to compare with. Returns: bool ( ) \u2013 True if the immutable attributes are the same, False otherwise. import_func classmethod import_func ( import_obj ) Import and return a function based on the given import object. Parameters: import_obj \u2013 The import object, which can be a dictionary or a callable. Returns: The imported function. \u2013 Raises: ValueError: \u2013 If the import object is not a dictionary or a callable. It suggests installing the module if the module name is provided in the import object. init_additional_hook init_additional_hook () init_identity init_identity ( cluster : FCT , sub_dir : str , corename : str , suffix : str , * , prefix : Optional [ str ] = None , appendnames : Optional [ Union [ str , list [ str ]]] = None , prefix_joiner : Optional [ str ] = None , appendnames_joiner : Optional [ str ] = None , data_path = '' , read_func : Optional [ Callable ] = None , write_func : Optional [ Callable ] = None , cache = None , value_type : Optional [ type ] = None ) principle: the parameter of identity can not be changed once it has been inited init_input_hook init_input_hook ( * , sub_dir , corename , suffix , prefix , appendnames , prefix_joiner , appendnames_joiner , data_path , read_func , write_func , cache , value_type ) Initializes the input hook with the specified parameters. This method can be overridden by subclasses to customize the input hook. Args sub_dir (str): The sub-directory where the data is located. corename (str): The core name of the data file. suffix (str): The suffix of the data file. prefix (str): The prefix of the data file. appendnames (List[str]): The list of names to append to the data file. prefix_joiner (str): The joiner used to concatenate the prefix and appendnames. appendnames_joiner (str): The joiner used to concatenate the appendnames. data_path (str): The top dir to the data file. read_func (callable): The function used to read the data file. write_func (callable): The function used to write the data file. cache (bool): Flag indicating whether to cache the data. value_type (type): The type of the data values. Returns: Tuple[str, str, str, str, List[str], str, str, str, callable, callable, bool, type]: The initialized input hook parameters. \u2013 read read () -> Union [ VDMT , list [ VDMT ], None ] Reads data from the specified path using the read function. If self.read_func is None , returns None . Returns: Union[VDMT, list[VDMT], None]: \u2013 The read data, or None if the path does not exist. register classmethod register ( identity_string , obj : FilesHandle ) remove_appendname remove_appendname ( appendname ) set_cache set_cache ( cache ) Set the cache for the IOAbstract object. Parameters: cache \u2013 Note If is_readonly == True or is_closed == True , the cache will not be set. Returns: None \u2013 set_inited set_inited () IOMeta Bases: ABC , Generic [ FCT , VDMT , FHT ] This class represents the abstract base class for input/output (IO) operations. Pre-process/post-process input and output, format conversion, and perform IO operations. Need to be used in combination with FilesCluster.io_decorator Attributes: READ (bool): Flag indicating if the IO operation is a read operation. PATH_EXISTS_REQUIRED (bool): Flag indicating if the existence of paths is required. LOG_TYPE: The log type for IO operations. WARNING_INFO (str): Information about the warning. W_SYNC (bool): Flag indicating if the write operation should be synchronous. OPER_ELEM (bool): Flag indicating if the operation is performed on individual elements. Methods: init (self, files_cluster: FCT): Initializes the IOMeta object. _set_ctrl_flag(self, ctrl_strategy=IO_CTRL_STRATEGY.CACHE_IDPNDT, io_raw=False): Sets the control flags for IO operations. _clear_ctrl_flag(self): Clears the control flags for IO operations. enter (self): Enters the control mode. exit (self, exc_type, exc_value, traceback): Exits the control mode. _set_synced_flag(self, src_handle: FilesHandle, dst_handle: FilesHandle, synced=False): Sets the synced flag for file handles. key_type(self): Returns the key type of the files cluster. multi_files(self): Returns whether the files cluster contains multiple files. cache_priority(self): Returns the cache priority. strict_priority_mode(self): Returns the strict priority mode. write_synchronous(self): Returns whether the write operation is synchronous. io_raw(self): Returns whether the IO operation is raw. _FCMemoryData(self): Returns the memory data of the files cluster. get_FilesHandle(self, src, dst, value, other_paras): Gets the file handles for the IO operation. _query_fileshandle(self, data_i: int): Queries the file handle for the given data index. get_file_core_func(self, src_file_handle: FHT, dst_file_handle: FHT, value): Gets the core function for the file handles. progress_FilesHandle(self, src_file_handle: FHT, dst_file_handle: FHT, postprocessed_value, other_paras): Progresses the file handles after the IO operation. io_cache(self, src_file_handle: FHT, dst_file_handle: FHT, value=None): Performs the IO operation with caching. cvt_to_core_paras(self, src_file_handle: FHT, dst_file_handle: FHT, value): Converts the parameters for the core function. preprogress_value(self, value, other_paras): Preprocesses the value before the IO operation. postprogress_value(self, value, other_paras): Postprocesses the value after the IO operation. format_value(self, value: Optional[VDMT]): Formats the value before the IO operation. inv_format_value(self, formatted_value): Inversely formats the value after the IO operation. core_func_hook(self, core_args): Hook function for the core function. operate_elem(self, src, dst, value, other_paras): Performs the operation on individual elements. gather_mutil_results(self, results: list): Gathers multiple results. split_value_as_mutil(self, core_values): Splits the value into multiple core values. assert_path_exists(self, path): Asserts that the path exists. io_file(self, src_file_handle, dst_file_handle, value: Optional[VDMT] = None): Performs the IO operation on a file. Methods (abstract): get_FilesHandle(self, src, dst, value, **other_paras): Gets the file handles for the IO operation. io_cache cvt_to_core_paras Methods recommended to be overridden: get_file_core_func: Gets the core function of the file handles. preprogress_value: Preprocesses the value before the I operation. postprogress_value: Postprocesses the value after the O operation. format_value: Formats the value before the I operation. inv_format_value: Inversely formats the value after the O operation. core_func_hook: Hook function for the core function. Methods need to be overridden if OPER_ELEM : operate_elem Methods need to be overridden if the files cluster contains multiple files: gather_mutil_results split_value_as_mutil LOG_TYPE class-attribute instance-attribute LOG_TYPE = IOStatusManager . LOG_READ OPER_ELEM class-attribute instance-attribute OPER_ELEM = False PATH_EXISTS_REQUIRED class-attribute instance-attribute PATH_EXISTS_REQUIRED = True READ class-attribute instance-attribute READ = True WARNING_INFO class-attribute instance-attribute WARNING_INFO = 'no description' W_SYNC class-attribute instance-attribute W_SYNC = False _FCMemoryData property _FCMemoryData : BinDict [ int , FHT ] cache_priority property cache_priority core_func instance-attribute core_func : Optional [ Callable ] = None core_func_binded_paras instance-attribute core_func_binded_paras = {} ctrl_mode instance-attribute ctrl_mode = False files_cluster instance-attribute files_cluster : FCT = files_cluster io_raw property io_raw key_type property key_type multi_files property multi_files save_memory_after_writing instance-attribute save_memory_after_writing = False strict_priority_mode property strict_priority_mode write_synchronous property write_synchronous __call__ __call__ ( * , src = None , dst = None , value = None , ** other_paras ) -> Any Make the IOMeta object callable. Args: src: The source parameter. dst: The destination parameter. value: The value parameter. **other_paras: Additional parameters. Returns: The result of the call. Raises: None. __enter__ __enter__ () __exit__ __exit__ ( exc_type , exc_value , traceback ) __init__ __init__ ( files_cluster : FCT ) -> None _clear_ctrl_flag _clear_ctrl_flag () _query_fileshandle _query_fileshandle ( data_i : int ) -> FHT _set_ctrl_flag _set_ctrl_flag ( ctrl_strategy = IO_CTRL_STRATEGY . CACHE_IDPNDT , io_raw = False ) _set_synced_flag _set_synced_flag ( src_handle : FilesHandle , dst_handle : FilesHandle , synced = False ) assert_path_exists assert_path_exists ( path : T_MUITLSTR ) Asserts that the given path or paths exist. Args: path (str or list[str]): The path or paths to check. Raises: IOMetaPriorityError: If the path or any of the paths do not exist and PATH_EXISTS_REQUIRED is True. check_dst check_dst ( dst ) Check if the given destination is of the correct type. Parameters: dst (self.key_type): The destination to be checked. Returns: bool: True if the destination is of the correct type, False otherwise. check_src check_src ( src ) Check if the given source is valid. Parameters: src (self.key_type): The source to be checked. Returns: bool: True if the source is valid, False otherwise. check_value check_value ( value : Any ) core_func_hook core_func_hook ( * core_args ) This is a hook function that can be overridden in subclasses. It is called after the core function is executed. Parameters: *core_args: Variable number of arguments passed to the core_func. Returns: None cvt_to_core_paras abstractmethod cvt_to_core_paras ( src_file_handle : FHT , dst_file_handle : FHT , value ) -> tuple Convert the given source file handle and destination file handle to core parameters. Args: src_file_handle (FilesHandle): The source file handle. dst_file_handle (FilesHandle): The destination file handle. value: The value to be converted. Returns: path: The path or paths that the core function will use. *core_values: The core values that the core function will use. execute_core_func execute_core_func ( core_func , * core_args , ** other_paras ) Executes the core function with the given arguments and parameters. Args: core_func: The core function to be executed. core_args: The arguments to be passed to the core function. other_paras: Other parameters to be passed to the core function. Returns: The result of the core function execution. format_value format_value ( value : Optional [ VDMT ]) -> Any Formats the value before the O operation. the difference between format_value and preprogress_value is that: preprogress_value has additional parameters: **other_paras , which allows more flexible preprocessing, such as resize an image. format_value need no additional parameters. It is used to format the value to the type that the core function can handle, such as converting a numpy array to a tensor. Args: value (Optional[VDMT]): The value to be formatted. Returns: Any: The formatted value. gather_mutil_results gather_mutil_results ( results : list ) WARNING: must be overridden if self.multi_files = True Gathers multiple results into a single result. Args: results (list): A list of results to be gathered. Raises: NotImplementedError: This method is not implemented and should be overridden in a subclass. get_FilesHandle abstractmethod get_FilesHandle ( src , dst , value , ** other_paras ) -> tuple [ FHT , FHT ] get_file_core_func get_file_core_func ( src_file_handle : FHT , dst_file_handle : FHT , value ) -> Callable This method returns the file core function. Args: src_file_handle (FilesHandle): The source file handle. dst_file_handle (FilesHandle): The destination file handle. value: The value. Returns: Callable: The file core function. inv_format_value inv_format_value ( formatted_value ) -> VDMT Inversely formats the value after the I operation. the difference between inv_format_value and postprogress_value see :link: format_value Args: formatted_value: The formatted value to be inverse formatted. Returns: The inverse formatted value. io io ( src_handle : FilesHandle , dst_handle : FilesHandle , preprocessed_value ) Perform input/output operations on the given source and destination handles. IO operations have a sequential order. Try to perform IO on the file and cache (or cache first and then the file) in sequence. the first operation is called 'priority', and the second operation is called 'secondary'. If 'priority' fails, continue to execute 'secondary', otherwise the result will be returned directly. you may control the strategy of the IO operations by setting the control flags by _set_ctrl_flag method: * self.cache_priority : If True, the cache will be used first. * self.strict_priority_mode : If True, an exception will be raised if the priority fails. * self.write_synchronous : If True, both file and cache will be written synchronously. * self.io_raw : If True, the IO operation will be raw. Tip You should pay attention to the definition of :link: cache_priority , :link: self.strict_priority_mode and :link: self.write_synchronous , see their docs for details Args: src_handle (FilesHandle): The source handle for the input operation. dst_handle (FilesHandle): The destination handle for the output operation. preprocessed_value: The preprocessed value to be used in the operations. Returns: The result of the input/output operations. io_cache abstractmethod io_cache ( src_file_handle : FHT , dst_file_handle : FHT , value = None ) -> Any io_file io_file ( src_file_handle : FilesHandle , dst_file_handle : FilesHandle , value : Optional [ VDMT ] = None ) -> Any Perform file input/output operation. Args: src_file_handle: The source file handle. dst_file_handle: The destination file handle. value: Optional value to be used in the operation. Returns: The result of the file operation. Raises: IOMetaPriorityError: If core_func is None. is_overwriting is_overwriting ( dst : int ) operate_elem operate_elem ( src , dst , value , ** other_paras ) WARNING: must be overridden if OPER_ELEM = True Perform an operation on the elements. Args: src: The source element. dst: The destination element. value: The value to be used in the operation. **other_paras: Additional parameters for the operation. Raises: NotImplementedError: If the method is not implemented. postprogress_value postprogress_value ( value , ** other_paras ) -> Any Postprocesses the value after the I operation. See Also the difference between inv_format_value and postprogress_value see :link: format_value Args: value: The value to be processed. **other_paras: Additional parameters. Returns: The processed value. preprogress_value preprogress_value ( value , ** other_paras ) -> Any Preprocesses the value before the O operation. See Also the difference between format_value and preprogress_value see :link: format_value Args: value: The value to be preprocessed. **other_paras: Additional parameters for preprocessing. Returns: The preprocessed value. progress_FilesHandle progress_FilesHandle ( src_file_handle : FHT , dst_file_handle : FHT , postprocessed_value , ** other_paras ) -> tuple [ FHT ] split_value_as_mutil split_value_as_mutil ( * core_values ) WARNING: must be overridden if self.multi_files = True Splits the given core values into multiple values. Args: *core_values: The core values to be split. Raises: NotImplementedError: This method is not implemented and should be overridden in a subclass. IOMetaParameterError Bases: ValueError IOMetaPriorityError Bases: ValueError IOStatusManager Manages the status and operations related to input/output (IO) operations. Attributes: WRITING_MARK ( str ) \u2013 The file extension used to mark a writing operation. LOG_READ ( int ) \u2013 Log type for read operation. LOG_ADD ( int ) \u2013 Log type for add operation. LOG_REMOVE ( int ) \u2013 Log type for remove operation. LOG_CHANGE ( int ) \u2013 Log type for change operation. LOG_MOVE ( int ) \u2013 Log type for move operation. LOG_OPERATION ( int ) \u2013 Log type for generic operation. LOG_KN ( list ) \u2013 List of valid log types. _DEBUG ( bool ) \u2013 Flag to enable debug mode. __closed ( bool ) \u2013 Flag indicating if the IOStatusManager object is closed. __readonly ( bool ) \u2013 Flag indicating if the IOStatusManager object is read-only. __wait_writing ( bool ) \u2013 Flag indicating if the IOStatusManager object is waiting for writing or a writing process is executing. __overwrite_allowed ( bool ) \u2013 Flag indicating if overwriting is allowed. __writer ( _Writer ) \u2013 The writer object for performing IO operations. LOG_ADD class-attribute instance-attribute LOG_ADD = 1 LOG_CHANGE class-attribute instance-attribute LOG_CHANGE = 3 LOG_KN class-attribute instance-attribute LOG_KN = [ LOG_READ , LOG_ADD , LOG_REMOVE , LOG_CHANGE , LOG_MOVE , LOG_OPERATION ] LOG_MOVE class-attribute instance-attribute LOG_MOVE = 4 LOG_OPERATION class-attribute instance-attribute LOG_OPERATION = 5 LOG_READ class-attribute instance-attribute LOG_READ = 0 LOG_REMOVE class-attribute instance-attribute LOG_REMOVE = 2 WRITING_MARK class-attribute instance-attribute WRITING_MARK = '.writing' _DEBUG class-attribute instance-attribute _DEBUG = False closed property closed Flag indicating if the IOStatusManager object is closed. Any IO operation will not be executed if the IOStatusManager object is closed. is_writing property is_writing Flag indicating if the IOStatusManager object is writing. See :link: wait_writing , :link: stop_writing , :link: start_writing opened property opened Flag indicating if the IOStatusManager object is opened. overwrite_allowed property overwrite_allowed Flag indicating if the IOStatusManager object allows overwriting. See :link: set_overwrite_allowed , :link: set_overwrite_forbidden , :link: overwrite_forbidden overwrite_forbidden property overwrite_forbidden Flag indicating if the IOStatusManager object doesn't allow overwriting. See :link: set_overwrite_allowed , :link: set_overwrite_forbidden , :link: overwrite_allowed readonly property readonly Flag indicating if the IOStatusManager object is read-only. Any write operation will not be executed if the IOStatusManager object is read-only. wait_writing property wait_writing Flag indicating if the IOStatusManager object is wait_writing. see :link: is_writing , :link: stop_writing , :link: start_writing Examples: >>> object = FilesCluster ( ... ) >>> object . wait_writing # True True >>> with object . get_writer () as writer : >>> object . wait_writing # False >>> ... >>> object . wait_writing # True True writable property writable Flag indicating if the IOStatusManager object is writable. _Empty_Writer Bases: _Writer A subclass of _Writer that represents an empty writer. Attributes: None \u2013 Methods: Name Description None __enter__ __enter__ () A subclass of _Writer that represents an empty writer. Attributes: None \u2013 Functions: Name Description None __exit__ __exit__ ( exc_type , exc_value , traceback ) Called when exiting the empty writer context. Parameters: exc_type ( type ) \u2013 The type of the exception raised, if any. exc_value ( Exception ) \u2013 The exception raised, if any. traceback ( traceback ) \u2013 The traceback object associated with the exception. Returns: None \u2013 Raises: Exception \u2013 If an exception was raised. _IOContext Context manager for managing the IO context. Attributes: DEFAULT_INPUT_OPEN ( bool ) \u2013 Default value for input open flag. DEFAULT_INPUT_WRITABLE ( bool ) \u2013 Default value for input writable flag. DEFAULT_INPUT_OVERWRITE_ALLOWED ( bool ) \u2013 Default value for input overwrite allowed flag. Methods: Name Description __init__ : Initializes the _IOContext object. reset_input : Resets the input flags to their default values. set_input : Sets the input flags to the specified values. enter_hook : Hook method called when entering the context. exit_hook : Hook method called when exiting the context. DEFAULT_INPUT_OPEN class-attribute instance-attribute DEFAULT_INPUT_OPEN = False DEFAULT_INPUT_OVERWRITE_ALLOWED class-attribute instance-attribute DEFAULT_INPUT_OVERWRITE_ALLOWED = False DEFAULT_INPUT_WRITABLE class-attribute instance-attribute DEFAULT_INPUT_WRITABLE = False obj instance-attribute obj : IOStatusManager = obj orig_closed instance-attribute orig_closed : bool = True orig_overwrite_allowed instance-attribute orig_overwrite_allowed : bool = False orig_readonly instance-attribute orig_readonly : bool = True working instance-attribute working = False __enter__ __enter__ () Called when entering the context. Returns: _IOContext \u2013 The _IOContext object. __exit__ __exit__ ( exc_type , exc_value , traceback ) Called when exiting the context. Parameters: exc_type ( type ) \u2013 The type of exception that caused the context to be exited, if any. exc_value ( Exception ) \u2013 The instance of the exception that caused the context to be exited, if any. traceback ( traceback ) \u2013 A traceback object encapsulating the call stack at the point where the exception was raised, if any. Returns: bool \u2013 Indicates successful exit from the context. __init__ __init__ ( obj : IOStatusManager ) -> None Initializes the _IOContext object. Parameters: obj ( IOStatusManager ) \u2013 The IOStatusManager object associated with this context. enter_hook enter_hook () -> None Hook method called when entering the context. exit_hook exit_hook () Hook method called when exiting the context. Returns: bool \u2013 Indicates successful exit from the context. reset_input reset_input () -> None Resets the input flags to their default values. set_input set_input ( open = False , writable = False , overwrite_allowed = False ) Sets the input flags to the specified values. Parameters: open ( bool , default: False ) \u2013 Flag indicating if the input should be opened. writable ( bool , default: False ) \u2013 Flag indicating if the input should be writable. overwrite_allowed ( bool , default: False ) \u2013 Flag indicating if overwriting is allowed. Returns: _IOContext \u2013 The _IOContext object. _Writer Bases: _IOContext Context manager for managing the writer context. Attributes: DEFAULT_INPUT_OPEN ( bool ) \u2013 Default value for input open flag. DEFAULT_INPUT_WRITABLE ( bool ) \u2013 Default value for input writable flag. Methods: Name Description allow_overwriting Sets the input overwrite allowed flag. DEFAULT_INPUT_OPEN class-attribute instance-attribute DEFAULT_INPUT_OPEN = True DEFAULT_INPUT_WRITABLE class-attribute instance-attribute DEFAULT_INPUT_WRITABLE = True allow_overwriting allow_overwriting ( overwrite_allowed = True ) Sets the input overwrite allowed flag. Parameters: overwrite_allowed ( bool , default: True ) \u2013 Flag indicating if overwriting is allowed. Default is True. Returns: _Writer \u2013 The _Writer object. __init__ __init__ () -> None Initializes the IOStatusManager object. Parameters: None \u2013 Returns: None \u2013 close close ( closed : bool = True ) Close the IOAbstract object. all the io operation will not be executed. Parameters: closed ( bool , default: True ) \u2013 Flag indicating whether the object should be closed. Defaults to True. close_hook close_hook () called when close is called * recommend to override this method get_writer get_writer ( valid = True ) Returns a writer object for performing IO operations. Parameters: valid ( bool , default: True ) \u2013 Flag indicating if the writer is valid. If valid is True, return self.__writer, else return self._Empty_Writer(self). An _Empty_Writer will do nothing when entering and exiting the context. Default is True. Returns: _Writer or _Empty_Writer \u2013 The writer object. Examples: >>> with self . get_writer () as writer : >>> for ... : >>> ... >>> with self . get_writer () . allow_overwriting () as writer : >>> ... get_writing_mark_file abstractmethod get_writing_mark_file () -> str Returns the file path for the writing mark file. Parameters: None \u2013 Returns: str \u2013 The file path for the writing mark file. identity_string abstractmethod identity_string () -> str Returns a string representation of the IOStatusManager object. Parameters: None \u2013 Returns: str \u2013 The string representation of the IOStatusManager object. is_closed is_closed ( with_warning = False ) Method to check if the cluster is closed. is_readonly is_readonly ( with_warning = False ) Method to check if the cluster is read-only. load_from_mark_file load_from_mark_file () Loads data from the writing mark file. Parameters: None \u2013 Returns: result (list): \u2013 The loaded data from the writing mark file. Raises: AssertionError: If the format of the mark file is incorrect. \u2013 log_to_mark_file log_to_mark_file ( log_type , src = None , dst = None , value = None ) Log the specified information to a mark file. Parameters: log_type \u2013 The type of log, should be one of [LOG_READ, LOG_ADD, LOG_REMOVE, LOG_CHANGE, LOG_MOVE, LOG_OPERATION] src \u2013 The source of the log. Defaults to None. dst \u2013 The destination of the log. Defaults to None. value \u2013 The value associated with the log. Defaults to None. mark_exist mark_exist () Checks if the writing mark file exists. Parameters: None \u2013 Returns: bool \u2013 True if the writing mark file exists, False otherwise. open open ( opened : bool = True ) Open the IOAbstract object. Parameters: opened ( bool , default: True ) \u2013 If True, opens the object. If False, closes the object. Defaults to True. Returns: None \u2013 open_hook open_hook () called when open is called * recommend to override this method readonly_hook readonly_hook () called when set_readonly is called * recommend to override this method remove_mark remove_mark () Removes the writing mark file. Parameters: None \u2013 Returns: None \u2013 reopen reopen () Reopens the file or resource for reading or writing. This method first closes the file or resource using the close() method, and then opens it again using the open() method. set_overwrite_allowed set_overwrite_allowed ( overwrite_allowed : bool = True ) set the overwrite_allowed flag for the object. See :link: set_overwrite_forbidden , :link: overwrite_allowed , :link: overwrite_forbidden Examples: >>> object = FilesCluster ( ... ) >>> object . set_overwrite_forbidden () # set overwrite_forbidden >>> with object . get_writer () as writer : >>> object . write ( 0 , ... ) # OK >>> object . write ( 0 , ... ) # raise ClusterIONotExecutedWarning >>> object . set_overwrite_allowed () # set overwrite_allowed >>> with object . get_writer () as writer : >>> object . write ( 0 , ... ) # OK >>> object . write ( 0 , ... ) # OK set_overwrite_allowed_hook set_overwrite_allowed_hook () called when set_overwrite_allowed is called * recommend to override this method set_overwrite_forbidden set_overwrite_forbidden ( overwrite_forbidden : bool = True ) set the overwrite_forbidden flag for the object. See :link: set_overwrite_allowed , :link: overwrite_allowed , :link: overwrite_forbidden set_overwrite_forbidden_hook set_overwrite_forbidden_hook () called when set_overwrite_forbidden is called * recommend to override this method set_readonly set_readonly ( readonly : bool = True ) Set the readonly flag for the object. Parameters: readonly ( bool , default: True ) \u2013 Whether the object should be set as readonly or not. Default is True. Examples: >>> object = FilesCluster ( ... ) >>> object . set_readonly () # set readonly >>> object . read ( 0 ) # OK >>> object . write ( 0 , ... ) # raise ClusterIONotExecutedWarning set_writable set_writable ( writable : bool = True ) Set the writable flag for the object. Parameters: writable ( bool , default: True ) \u2013 Whether the object should be set as writable or not. Default is True. Warns: NOT recommend to use this method. use `get_writer` instead. \u2013 Examples: NOT recommend: >>> object = FilesCluster ( ... ) >>> object . set_writable () # set writable >>> object . read ( 0 ) # OK >>> object . write ( 0 , ... ) # OK >>> object . set_readonly () # set readonly recommend: >>> object = FilesCluster ( ... ) >>> with object . get_writer () as writer : >>> object . read ( 0 ) # OK >>> object . write ( 0 , ... ) # OK start_writing start_writing ( start_writing : bool = True , overwrite_allowed : bool = False ) start_writing_hook wiil be called see :link: stop_writing , :link: wait_writing , :link: is_writing start_writing_hook start_writing_hook () called when start_writing is called * recommend to override this method stop_writing stop_writing ( stop_writing : bool = True ) Set the stop_writing flag for the object. stop_writing_hook wiil be called see :link: start_writing , :link: wait_writing , :link: is_writing Examples: NOT recommend: >>> object = FilesCluster ( ... ) >>> object . set_writable () # set writable >>> object . start_writing () # set start_writing >>> object . read ( 0 ) # OK >>> object . write ( 0 , ... ) # OK >>> object . stop_writing () # set stop_writing >>> object . set_readonly () # set readonly recommend: >>> object = FilesCluster ( ... ) >>> with object . get_writer () as writer : >>> object . read ( 0 ) # OK >>> object . write ( 0 , ... ) # OK stop_writing_hook stop_writing_hook () called when stop_writing is called * recommend to override this method writable_hook writable_hook () called when set_writable is called * recommend to override this method IOStatusWarning Bases: Warning IO_CTRL_STRATEGY Enum representing different IO control strategies. Note there are 3 control flags for DataMapping : cache_priority , strict_priority_mode , write_synchronous cache_priority IO operations have 2 destinations: cache and file(s). Cache is in memory, and file(s) is on disk. You can read from(write to) cache or file(s). They each have their own advantages under different conditions. When the file is large, such as an image or a video, it is recommended to read from(write to) the file(s) directly. Because reading from(writing to) the file(s) directly will not consume memory. cache_priority is recommended to be False in this case. When the file is small, such as a configuration file, it is recommended to read from(write to) the cache. Because reading from(writing to) the cache is faster than reading from(writing to) the file(s). Or if the file contains a large amounts of pieces of data, like a json/xml file, If the file is written to the disk when each piece of data is written, a lot of resources will be consumed. In this case, it is recommended to write to the cache first, and then write to the file(s) in batches. cache_priority is recommended to be True in this case. strict_priority_mode When strict_priority_mode is False . If the one set as priority fails to perform a read (or write) operation, it will try to perform a read (or write) operation on the other one. If failed again, it will raise an exception. When strict_priority_mode is True . When the priority fails, it will raise an exception without trying the other one. write_synchronous When write_synchronous is False . If the cache is modified, it will not be written to the file immediately. The same goes for files. When write_synchronous is True . If the cache is modified, it will be written to the file immediately. The same goes for files. Attributes: CACHE_PRIORITY \u2013 Set Cache as Priority FILE_PRIORITY \u2013 Set File as Priority STRICT_PRIORITY_MODE \u2013 Set strict_priority_mode NON_STRICT_PRIORITY_MODE \u2013 Clear strict_priority_mode WRITE_SYNCHRONOUS \u2013 Set write_synchronous WRITE_ASYNCHRONOUS \u2013 Clear write_synchronous Methods: Name Description get_ctrl_flag Get control flags based on the strategy. get_ctrl_strategy Get strategy based on control flags. CACHE_IDPNDT class-attribute instance-attribute CACHE_IDPNDT = 4 CACHE_PRIORITY, NON_STRICT_PRIORITY_MODE, WRITE_ASYNCHRONOUS CACHE_PRIORITY class-attribute instance-attribute CACHE_PRIORITY = 4 CACHE_STRICK_IDPNDT class-attribute instance-attribute CACHE_STRICK_IDPNDT = 6 CACHE_PRIORITY, STRICT_PRIORITY_MODE, WRITE_ASYNCHRONOUS CACHE_STRICK_SYNC class-attribute instance-attribute CACHE_STRICK_SYNC = 7 CACHE_PRIORITY, STRICT_PRIORITY_MODE, WRITE_SYNCHRONOUS CACHE_SYNC class-attribute instance-attribute CACHE_SYNC = 5 CACHE_PRIORITY, NON_STRICT_PRIORITY_MODE, WRITE_SYNCHRONOUS FILE_IDPNDT class-attribute instance-attribute FILE_IDPNDT = 0 FILE_PROIRITY, NON_STRICT_PRIORITY_MODE, WRITE_ASYNCHRONOUS FILE_PROIRITY class-attribute instance-attribute FILE_PROIRITY = 0 FILE_STRICK_IDPNDT class-attribute instance-attribute FILE_STRICK_IDPNDT = 2 FILE_PROIRITY, STRICT_PRIORITY_MODE, WRITE_ASYNCHRONOUS FILE_STRICK_SYNC class-attribute instance-attribute FILE_STRICK_SYNC = 3 FILE_PROIRITY, STRICT_PRIORITY_MODE, WRITE_SYNCHRONOUS FILE_SYNC class-attribute instance-attribute FILE_SYNC = 1 FILE_PROIRITY, NON_STRICT_PRIORITY_MODE, WRITE_SYNCHRONOUS NON_STRICT_PRIORITY_MODE class-attribute instance-attribute NON_STRICT_PRIORITY_MODE = 0 STRICT_PRIORITY_MODE class-attribute instance-attribute STRICT_PRIORITY_MODE = 2 WRITE_ASYNCHRONOUS class-attribute instance-attribute WRITE_ASYNCHRONOUS = 0 WRITE_SYNCHRONOUS class-attribute instance-attribute WRITE_SYNCHRONOUS = 1 get_ctrl_flag classmethod get_ctrl_flag ( strategy : int ) return cache_priority, strict_priority_mode, write_synchronous Examples: >>> IO_CTRL_STRATEGY . get_ctrl_flag ( IO_CTRL_STRATEGY . CACHE_IDPNDT ) (True, False, False) >>> IO_CTRL_STRATEGY . get_ctrl_flag ( IO_CTRL_STRATEGY . CACHE_PRIORITY | IO_CTRL_STRATEGY . STRICT_PRIORITY_MODE | IO_CTRL_STRATEGY . WRITE_SYNCHRONOUS ) (True, True, True) get_ctrl_strategy classmethod get_ctrl_strategy ( cache_priority : bool , strict_priority_mode : bool , write_synchronous : bool ) Get the control strategy based on the given parameters. Parameters: cache_priority ( bool ) \u2013 The priority of cache. strict_priority_mode ( bool ) \u2013 The mode of strict priority. write_synchronous ( bool ) \u2013 The mode of write synchronization. Returns: int ( ) \u2013 The control strategy calculated based on the given parameters. KeyNotFoundError Bases: KeyError Node Bases: Generic [ NODE ] A class representing a node in a tree structure. CHILD_TYPE class-attribute instance-attribute CHILD_TYPE : Optional [ type [ Node ]] = None PARENT_TYPE class-attribute instance-attribute PARENT_TYPE : Optional [ type [ Node ]] = None _children property _children : tuple [ NODE ] Get the children nodes of the current node. follow_parent instance-attribute follow_parent = True linked_with_children instance-attribute linked_with_children = True parent property parent : Union [ NODE , None ] Get the parent node of the current node. __init__ __init__ () -> None Initializes a Node object. _add_child _add_child ( child_node : Node ) Add a child node to the current node. _move_node _move_node ( new_parent : NODE ) Move the current node to a new parent node. _remove_child _remove_child ( child_node : Node ) Parameters: child_node ( Node ) \u2013 Remove a child node from the current node. _set_parent _set_parent ( parent ) Set the parent node of the current node. downward_postorder_propagate staticmethod downward_postorder_propagate ( func ) Decorator to propagate a function call to the leaves of the node in a downward postorder traversal. downward_preorder_propagate staticmethod downward_preorder_propagate ( func ) Decorator to propagate a function call to the leaves of the node in a downward preorder traversal. upward_postorder_propagate staticmethod upward_postorder_propagate ( func ) Decorator to propagate a function call to the ancestors of the node in a backtracking postorder traversal. upward_preorder_propagate staticmethod upward_preorder_propagate ( func ) Decorator to propagate a function call to the ancestors of the node in a backtracking preorder traversal. _AppendNames Bases: dict [ str , Union [ List [ str ], str ]] A class representing a configuration for appending names with options for a list of appendable names and a joiner. Parameters: appendnames ( list of str , default: None ) \u2013 The list of names to be appended, by default an empty list. joiner ( str , default: '_' ) \u2013 The joiner to be used, by default \"_\". Attributes: KW_APPENDNAMES ( str ) \u2013 Keyword for the appendnames attribute. KW_JOINER ( str ) \u2013 Keyword for the joiner attribute. Methods: Name Description joiner : str Getter for the joiner attribute. appendnames : list of str Getter for the appendnames attribute. get_with_joiner Returns a list of names with the joiner added. extend Extends the appendnames attribute with new names. add_appendname Adds an appendname to the list if it does not already exist. remove_appendname Removes an appendname from the list if it exists. conditional_return Conditionally returns either the list of names or the first name based on the value of mutil_file. __repr__ Returns a string representation of the AppendNames object. from_dict Creates an AppendNames object from a dictionary. as_dict Returns the AppendNames object as a dictionary. Examples: >>> append_names_instance = _AppendNames ( appendnames = [ \"name1\" , \"name2\" ], joiner = \"-\" ) >>> print ( append_names_instance . get_with_joiner ()) [\"-name1\", \"-name2\"] >>> append_names_dict = { 'appendnames' : [ 'item1' , 'item2' ], 'joiner' : '+' } >>> new_append_names_instance = _AppendNames . from_dict ( append_names_dict ) >>> print ( new_append_names_instance ) \"AppendNames({'appendnames': ['item1', 'item2'], 'joiner': '+'})\" KW_APPENDNAMES class-attribute instance-attribute KW_APPENDNAMES = 'appendnames' KW_JOINER class-attribute instance-attribute KW_JOINER = 'joiner' appendnames property appendnames : List [ str ] Getter for the appendnames attribute. Returns: list of str \u2013 The current list of appendable names. joiner property joiner : str Getter for the joiner attribute. Returns: str \u2013 The current joiner value. __init__ __init__ ( appendnames : List [ str ] = None , joiner : str = '_' ) -> None Initialize the AppendNames object. Parameters: appendnames ( list of str , default: None ) \u2013 The list of names to be appended, by default an empty list. joiner ( str , default: '_' ) \u2013 The joiner to be used, by default \"_\". __repr__ __repr__ () -> str Returns a string representation of the AppendNames object. Returns: str \u2013 A string representation of the AppendNames object. add_appendname add_appendname ( appendname : str ) -> bool Adds an appendname to the list if it does not already exist. Parameters: appendname ( str ) \u2013 The name to be added to the appendnames list. Returns: bool \u2013 True if the name was added, False if it already existed. as_dict as_dict () -> dict Returns the AppendNames object as a dictionary. Returns: dict \u2013 A dictionary representation of the AppendNames object. conditional_return staticmethod conditional_return ( mutil_file : bool , list_like : List [ str ]) -> Union [ str , List [ str ]] Conditionally returns either the list of names or the first name based on the value of mutil_file. Parameters: mutil_file ( bool ) \u2013 A boolean flag indicating whether to return the full list or just the first item. list_like ( list of str ) \u2013 The list of names. Returns: Union [ str , List [ str ]] \u2013 Either the full list or the first item based on the value of mutil_file. extend extend ( names : Union [ str , Iterable [ str ]]) -> None Extends the appendnames attribute with new names. Parameters: names ( str or iterable of str ) \u2013 The names to be added to the appendnames list. from_dict classmethod from_dict ( dict_ : dict ) -> _AppendNames Creates an AppendNames object from a dictionary. Parameters: dict_ ( dict ) \u2013 The dictionary containing the appendnames and joiner values. Returns: _AppendNames \u2013 A new AppendNames object created from the provided dictionary. get_with_joiner get_with_joiner () -> List [ str ] Returns a list of names with the joiner added. Returns: list of str \u2013 The result of concatenating the joiner with each name in the appendnames list. remove_appendname remove_appendname ( appendname : str ) -> bool Removes an appendname from the list if it exists. Parameters: appendname ( str ) \u2013 The name to be removed from the appendnames list. Returns: bool \u2013 True if the name was removed, False if it did not exist. _Prefix Bases: dict [ str , str ] A class representing a prefix configuration with options for prefix and joiner. Parameters: prefix ( str , default: '' ) \u2013 The prefix to be used, by default an empty string. joiner ( Any , default: '' ) \u2013 The joiner to be used, by default an empty string. Attributes: KW_PREFIX ( str ) \u2013 Keyword for the prefix attribute. KW_JOINER ( str ) \u2013 Keyword for the joiner attribute. Methods: Name Description prefix : str Getter and setter for the prefix attribute. joiner : Any Getter and setter for the joiner attribute. get_with_joiner Returns the concatenation of prefix and joiner. __repr__ Returns a string representation of the Prefix object. as_dict Returns the Prefix object as a dictionary. from_dict Creates a Prefix object from a dictionary. Examples: >>> prefix_instance = _Prefix ( prefix = \"abc\" , joiner = \"-\" ) >>> print ( prefix_instance . get_with_joiner ()) \"abc-\" >>> prefix_dict = { 'prefix' : 'xyz' , 'joiner' : '_' } >>> new_prefix_instance = _Prefix . from_dict ( prefix_dict ) >>> print ( new_prefix_instance ) \"Prefix(xyz, _)\" KW_JOINER class-attribute instance-attribute KW_JOINER = 'joiner' KW_PREFIX class-attribute instance-attribute KW_PREFIX = 'prefix' joiner property writable joiner : str Getter for the joiner attribute. Returns: str \u2013 The current joiner value. prefix property writable prefix : str Getter for the prefix attribute. Returns: str \u2013 The current prefix value. __init__ __init__ ( prefix : str = '' , joiner : str = '' ) -> None Initialize the Prefix object. Parameters: prefix ( str , default: '' ) \u2013 The prefix to be used, by default an empty string. joiner ( Any , default: '' ) \u2013 The joiner to be used, by default an empty string. __repr__ __repr__ () -> str Returns a string representation of the Prefix object. Returns: str \u2013 A string representation of the Prefix object. as_dict as_dict () -> dict Returns the Prefix object as a dictionary. Returns: dict \u2013 A dictionary representation of the Prefix object. from_dict classmethod from_dict ( dict_ : dict ) -> _Prefix Creates a Prefix object from a dictionary. Parameters: dict_ ( dict ) \u2013 The dictionary containing the prefix and joiner values. Returns: _Prefix \u2013 A new Prefix object created from the provided dictionary. get_with_joiner get_with_joiner () -> str Returns the concatenation of prefix and joiner. Returns: str \u2013 The result of concatenating prefix and joiner. _RegisterInstance Bases: ABC , Generic [ RGSITEM ] A base class for registering instances with unique identities. Every instance of a subclass of _RegisterInstance will be registered in _RegisterInstance._registry with its identity_string. Attributes: _registry (dict[str, RGSITEM]) \u2013 A dictionary to store registered instances. INDENTITY_PARA_NAMES (list) \u2013 A list of parameter names that define the identity of an instance. INDENTITY_PARA_NAMES class-attribute instance-attribute INDENTITY_PARA_NAMES = [] _registry class-attribute instance-attribute _registry : dict [ str , RGSITEM ] = {} __new__ __new__ ( * args , ** kwargs ) __setattr__ __setattr__ ( name : str , value ) -> Any gen_identity_name abstractmethod gen_identity_name () generate the identity_name of an instance gen_identity_string abstractmethod gen_identity_string () generate the identity_string of an instance get_instance abstractmethod classmethod get_instance ( identity_string , obj ) get an instance by identity_string. the strategy of getting is defined by the subclass has_instance classmethod has_instance ( obj : _RegisterInstance ) if an instance has been registered Parameters: obj ( _RegisterInstance ) \u2013 the instance to be checked identity_name identity_name () Note indentity_string() might be too long, so sometime we need a short name to represent it. If you are sure there will be no ambiguity, you can use identity_name() to distinguish different instances. identity_string identity_string () Note identity_string returns a string that can uniquely identify an instance init_identity abstractmethod init_identity ( * args , ** kwargs ) principle: the parameter of identity can not be changed once it has been inited register abstractmethod classmethod register ( identity_string , obj ) register an instance with its identity_string. the strategy of registering is defined by the subclass get_func_name get_func_name ( obj , func ) Get the name of a function within an object. Parameters: obj ( object ) \u2013 The object containing the function. func ( function ) \u2013 The function to get the name of. Returns: str or None \u2013 The name of the function if found, None otherwise. get_function_args get_function_args ( function , * exclude : str ) Get the arguments of a function, excluding specified arguments. Parameters: function ( function ) \u2013 The function to get the arguments of. *exclude ( str , default: () ) \u2013 The arguments to exclude. Returns: rlt \u2013 The signature of the function, excluding specified arguments. get_with_priority get_with_priority ( * args : Optional [ T ]) -> T Returns the first non-None argument from the given arguments. Parameters: *args ( Optional [ T ] , default: () ) \u2013 The arguments to check for non-None values. Returns: T \u2013 The first non-None argument, or None if all arguments are None. is_subpath is_subpath ( child_path , parent_path ) Check if a path is a subpath of another path. Parameters: child_path ( str ) \u2013 The path to check if it is a subpath. parent_path ( str ) \u2013 The parent path to compare against. Returns: bool \u2013 True if the child_path is a subpath of the parent_path, False otherwise. method_exit_hook_decorator method_exit_hook_decorator ( cls , func : Callable , exit_hook_func , enter_condition_func = None ) Decorator function that adds an exit hook to a method based on an enter condition. Parameters: cls ( class ) \u2013 The class to which the method belongs. func ( callable ) \u2013 The method to be decorated. exit_hook_func ( callable ) \u2013 The exit hook function to be called after the method execution. enter_condition_func ( callable , default: None ) \u2013 The enter condition function to determine if the method should be executed. Defaults to None. Returns: callable \u2013 The decorated method. parse_kw parse_kw ( ** kwargs ) -> list [ dict [ str , Any ]] Parses keyword arguments into a list of dictionaries. Parameters: **kwargs ( dict [ str , Any ] , default: {} ) \u2013 The keyword arguments to be parsed. Returns: list [ dict [ str , Any ]] \u2013 The parsed keyword arguments.","title":"IOAbstract"},{"location":"md/data/IOAbstract/#ioabstract","text":"","title":"IOAbstract"},{"location":"md/data/IOAbstract/#data.IOAbstract.DEBUG","text":"DEBUG = False","title":"DEBUG"},{"location":"md/data/IOAbstract/#data.IOAbstract.DMT","text":"DMT = TypeVar ( 'DMT' , bound = 'DataMapping' )","title":"DMT"},{"location":"md/data/IOAbstract/#data.IOAbstract.DSNT","text":"DSNT = TypeVar ( 'DSNT' , bound = 'DatasetNode' )","title":"DSNT"},{"location":"md/data/IOAbstract/#data.IOAbstract.FCT","text":"FCT = TypeVar ( 'FCT' , bound = 'FilesCluster' )","title":"FCT"},{"location":"md/data/IOAbstract/#data.IOAbstract.FHT","text":"FHT = TypeVar ( 'FHT' , bound = 'FilesHandle' )","title":"FHT"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOSM","text":"IOSM = TypeVar ( 'IOSM' , bound = 'IOStatusManager' )","title":"IOSM"},{"location":"md/data/IOAbstract/#data.IOAbstract.NODE","text":"NODE = TypeVar ( 'NODE' , bound = 'Node' )","title":"NODE"},{"location":"md/data/IOAbstract/#data.IOAbstract.RGSITEM","text":"RGSITEM = TypeVar ( 'RGSITEM' )","title":"RGSITEM"},{"location":"md/data/IOAbstract/#data.IOAbstract.T","text":"T = TypeVar ( 'T' )","title":"T"},{"location":"md/data/IOAbstract/#data.IOAbstract.T_MUITLSTR","text":"T_MUITLSTR = TypeVar ( 'T_MUITLSTR' , str , List [ str ])","title":"T_MUITLSTR"},{"location":"md/data/IOAbstract/#data.IOAbstract.VDMT","text":"VDMT = TypeVar ( 'VDMT' )","title":"VDMT"},{"location":"md/data/IOAbstract/#data.IOAbstract.VDST","text":"VDST = TypeVar ( 'VDST' )","title":"VDST"},{"location":"md/data/IOAbstract/#data.IOAbstract._KT","text":"_KT = TypeVar ( '_KT' )","title":"_KT"},{"location":"md/data/IOAbstract/#data.IOAbstract._VT","text":"_VT = TypeVar ( '_VT' )","title":"_VT"},{"location":"md/data/IOAbstract/#data.IOAbstract.AmbiguousError","text":"Bases: ValueError","title":"AmbiguousError"},{"location":"md/data/IOAbstract/#data.IOAbstract.BinDict","text":"Bases: dict [ _KT , _VT ] , Generic [ _KT , _VT ] A dictionary subclass that supports bidirectional mapping between keys and values. Parameters: dict_ ( dict , default: None ) \u2013 The initial dictionary to populate the BinDict with. Attributes: _reverse_dict ( dict ) \u2013 A dictionary that stores the reverse mapping of values to keys. Methods: Name Description gen_reverse_dict Generates the reverse dictionary from the given dictionary. init_reverse_dict Initializes the _reverse_dict attribute. __getitem__ Returns the value associated with the given key. __del_item Deletes the item with the given key and its corresponding reverse mapping. __setitem__ Sets the value associated with the given key and updates the reverse mapping. update Updates the BinDict with the key-value pairs from other dictionaries. pop Removes and returns the value associated with the given key. popitem Removes and returns the last key-value pair in the BinDict. clear Removes all items from the BinDict. setdefault Returns the value associated with the given key, or sets it to the default value if the key is not present. __delitem__ Deletes the item with the given key and its corresponding reverse mapping. __repr__ Returns a string representation of the BinDict. Examples: >>> bin_dict = BinDict ({ 'a' : 1 , 'b' : 2 }) >>> print ( bin_dict [ 'a' ]) 1 >>> bin_dict . update ({ 'c' : 3 }) >>> print ( bin_dict ) BinDict({'a': 1, 'b': 2, 'c': 3}) >>> bin_dict . _reverse_dict [ 3 ] 'c'","title":"BinDict"},{"location":"md/data/IOAbstract/#data.IOAbstract.BinDict.__delitem__","text":"__delitem__ ( key ) Deletes the item with the given key and its corresponding reverse mapping. Parameters: key ( _KT ) \u2013 The key of the item to delete.","title":"__delitem__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.BinDict.__getitem__","text":"__getitem__ ( __key : _KT ) -> _VT Returns the value associated with the given key. Parameters: __key ( _KT ) \u2013 The key to retrieve the value for. Returns: _VT \u2013 The value associated with the key.","title":"__getitem__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.BinDict.__init__","text":"__init__ ( dict_ : Optional [ dict [ _KT , _VT ]] = None , * args , ** kwargs )","title":"__init__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.BinDict.__repr__","text":"__repr__ () -> str Returns a string representation of the BinDict. Returns: str \u2013 A string representation of the BinDict.","title":"__repr__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.BinDict.__setitem__","text":"__setitem__ ( key , value ) Sets the value associated with the given key and updates the reverse mapping. Parameters: key ( _KT ) \u2013 The key to set the value for. value ( _VT ) \u2013 The value to associate with the key.","title":"__setitem__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.BinDict.clear","text":"clear () Removes all items from the BinDict.","title":"clear()"},{"location":"md/data/IOAbstract/#data.IOAbstract.BinDict.gen_reverse_dict","text":"gen_reverse_dict ( dict_ : dict [ _KT , _VT ]) -> dict [ _VT , _KT ] Generates a reverse dictionary from the given dictionary. Parameters: dict_ ( dict ) \u2013 The dictionary to generate the reverse dictionary from. Returns: dict \u2013 The reverse dictionary.","title":"gen_reverse_dict()"},{"location":"md/data/IOAbstract/#data.IOAbstract.BinDict.init_reverse_dict","text":"init_reverse_dict () Initializes the _reverse_dict attribute by generating the reverse dictionary from the current dictionary.","title":"init_reverse_dict()"},{"location":"md/data/IOAbstract/#data.IOAbstract.BinDict.pop","text":"pop ( key , default = None ) -> _VT Removes and returns the value associated with the given key. Parameters: key ( _KT ) \u2013 The key of the item to remove. default ( any , default: None ) \u2013 The value to return if the key is not found, by default None. Returns: _VT \u2013 The value associated with the key, or the default value if the key is not found.","title":"pop()"},{"location":"md/data/IOAbstract/#data.IOAbstract.BinDict.popitem","text":"popitem () -> tuple [ _KT , _VT ] Removes and returns the last key-value pair in the BinDict. Returns: tuple \u2013 The last key-value pair in the BinDict.","title":"popitem()"},{"location":"md/data/IOAbstract/#data.IOAbstract.BinDict.setdefault","text":"setdefault ( key , default = None ) -> _VT Returns the value associated with the given key, or sets it to the default value if the key is not present. Parameters: key ( _KT ) \u2013 The key to retrieve the value for. default ( any , default: None ) \u2013 The default value to set if the key is not present, by default None. Returns: _VT \u2013 The value associated with the key, or the default value if the key is not present.","title":"setdefault()"},{"location":"md/data/IOAbstract/#data.IOAbstract.BinDict.update","text":"update ( * args : dict [ _KT , _VT ], ** kwargs ) Updates the BinDict with the key-value pairs from other dictionaries. Parameters: *args ( dict , default: () ) \u2013 Other dictionaries to update the BinDict with. **kwargs ( key-value pairs , default: {} ) \u2013 Key-value pairs to update the BinDict with.","title":"update()"},{"location":"md/data/IOAbstract/#data.IOAbstract.CacheProxy","text":"Bases: Generic [ VDMT ] A generic class representing a cache proxy with options for the cache, value type, and initialization function. Parameters: cache ( VDMT or any ) \u2013 The cache to be used. value_type ( type [ VDMT ] , default: None ) \u2013 The type of values stored in the cache, by default None. value_init_func ( Callable , default: None ) \u2013 The initialization function for the cache, by default None. Attributes: KW_cache ( str ) \u2013 Keyword for the cache attribute. KW_value_type ( str ) \u2013 Keyword for the value_type attribute. Methods: Name Description value_type : type[VDMT] Getter for the value_type attribute. cache : VDMT or None Getter and setter for the cache attribute. as_dict Returns the CacheProxy object as a dictionary. from_dict Creates a CacheProxy object from a dictionary. init_cache Initializes the cache using the specified initialization function. Examples: >>> cache_instance = CacheProxy ( cache = SomeCache (), value_type = int ) >>> print ( cache_instance . value_type ) <class 'int'> >>> cache_dict = { 'cache' : SomeCache (), 'value_type' : int } >>> new_cache_instance = CacheProxy . from_dict ( cache_dict ) >>> print ( new_cache_instance ) \"CacheProxy({'cache': SomeCache(), 'value_type': int})\"","title":"CacheProxy"},{"location":"md/data/IOAbstract/#data.IOAbstract.CacheProxy.KW_cache","text":"KW_cache = 'cache'","title":"KW_cache"},{"location":"md/data/IOAbstract/#data.IOAbstract.CacheProxy.KW_value_type","text":"KW_value_type = 'value_type'","title":"KW_value_type"},{"location":"md/data/IOAbstract/#data.IOAbstract.CacheProxy._pickleable_type","text":"_pickleable_type = []","title":"_pickleable_type"},{"location":"md/data/IOAbstract/#data.IOAbstract.CacheProxy._unpickleable_type","text":"_unpickleable_type = []","title":"_unpickleable_type"},{"location":"md/data/IOAbstract/#data.IOAbstract.CacheProxy.cache","text":"cache : Union [ VDMT , None ] Getter for the cache attribute. Returns: `VDMT` or None \u2013 The current cache value.","title":"cache"},{"location":"md/data/IOAbstract/#data.IOAbstract.CacheProxy.synced","text":"synced = False","title":"synced"},{"location":"md/data/IOAbstract/#data.IOAbstract.CacheProxy.value_type","text":"value_type : type [ VDMT ] Getter for the value_type attribute. Returns: type[`VDMT`] \u2013 The current value_type.","title":"value_type"},{"location":"md/data/IOAbstract/#data.IOAbstract.CacheProxy.__init__","text":"__init__ ( cache , value_type : Optional [ type [ VDMT ]] = None , value_init_func : Optional [ Callable ] = None ) -> None Initialize the CacheProxy object. Parameters: cache ( `VDMT` or any ) \u2013 The cache to be used. value_type ( type[`VDMT`] , default: None ) \u2013 The type of values stored in the cache, by default None. value_init_func ( Callable , default: None ) \u2013 The initialization function for the cache, by default None.","title":"__init__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.CacheProxy.as_dict","text":"as_dict () -> dict Returns the CacheProxy object as a dictionary. Returns: dict \u2013 A dictionary representation of the CacheProxy object.","title":"as_dict()"},{"location":"md/data/IOAbstract/#data.IOAbstract.CacheProxy.from_dict","text":"from_dict ( dict_ : dict ) -> CacheProxy Creates a CacheProxy object from a dictionary. Parameters: dict_ ( dict ) \u2013 The dictionary containing the cache and value_type values. Returns: `CacheProxy` \u2013 A new CacheProxy object created from the provided dictionary.","title":"from_dict()"},{"location":"md/data/IOAbstract/#data.IOAbstract.CacheProxy.init_cache","text":"init_cache () -> bool Initializes the cache using the specified initialization function. Returns: bool \u2013 True if initialization was successful, False otherwise.","title":"init_cache()"},{"location":"md/data/IOAbstract/#data.IOAbstract.ClusterDataIOError","text":"Bases: RuntimeError","title":"ClusterDataIOError"},{"location":"md/data/IOAbstract/#data.IOAbstract.ClusterIONotExecutedWarning","text":"Bases: ClusterWarning","title":"ClusterIONotExecutedWarning"},{"location":"md/data/IOAbstract/#data.IOAbstract.ClusterNotRecommendWarning","text":"Bases: ClusterWarning","title":"ClusterNotRecommendWarning"},{"location":"md/data/IOAbstract/#data.IOAbstract.ClusterWarning","text":"Bases: Warning","title":"ClusterWarning"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapExistError","text":"Bases: OSError","title":"DataMapExistError"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping","text":"Bases: IOStatusManager , _RegisterInstance ['DataMapping'] , Node ['DataMapping'] , ABC , Generic [ _VT , DMT , VDMT ] An abstract class representing bidirectional mapping between data and files. Attributes: MEMORY_DATA_FILE (str) \u2013 The default filename for storing memory data. MEMORY_DATA_TYPE (type) \u2013 The default data type for memory data storage (BinDict). KEY_TYPE (type) \u2013 The type of keys used in the mapping (int). FILESHANDLE_TYPE (type) \u2013 The type of files handle used (FilesHandle). Methods: Name Description try_open Tries to open the data mapping for operation. has_not_inited Checks if the data mapping has not been initialized. _clear_empty_dir Clears empty directories in the data mapping. _rebuild_done Handles actions after the rebuild operation is completed. init_identity Initializes the identity of the data mapping. get_child Gets the child node with the specified name. save_memory_func Serializes and saves the memory data to a file. load_memory_func Loads and deserializes memory data from a file. register Registers a data mapping instance with a unique identity string. get_instance Retrieves a registered data mapping instance based on its identity string. identity_string Returns the identity string of the data mapping. identity_name Returns the identity name of the data mapping. gen_identity_string Generates a new identity string for the data mapping. gen_identity_name Generates a new identity name for the data mapping. make_path Creates the necessary directory structure for the data mapping. set_parent Sets the parent node of the data mapping. open_hook Hook method called during the open operation. stop_writing_hook Hook method called when writing is stopped. get_writing_mark_file Returns the path to the writing mark file. close Closes the data mapping. open Opens the data mapping. set_readonly Sets the data mapping to readonly mode. set_writable Sets the data mapping to writable mode. stop_writing Stops writing to the data mapping. start_writing Starts writing to the data mapping. set_overwrite_forbidden Forbids overwriting in the data mapping. set_overwrite_allowed Allows overwriting in the data mapping. remove_mark Removes the mark file associated with the data mapping. _set_MemoryData_modified Sets the flag indicating modification in memory data. _reset_MemoryData_modified Resets the flag indicating modification in memory data. MemoryData_modified: Property indicating whether memory data has been modified. MemoryData: Property representing the memory data of the mapping. MemoryData_path: Property representing the path to the memory data file. pickle_MemoryData_path: Property representing the path to the pickled memory data file. data_path: Property representing the data path of the mapping. save_preprecess Hook method for preprocessing data before saving. load_postprocess Hook method for post-processing data after loading. remove_memory_data_file Removes the memory data file. rebuild Abstract method for rebuilding the data mapping. merge_MemoryData Abstract method for merging memory data. sort Sorts the memory data. num: Property representing the number of items in the mapping. i_upper: Property representing the upper limit of indices in the mapping. next_valid_i: Property representing the next valid index in the mapping. continuous: Property indicating whether the indices in the mapping are continuous. set_io_ctrl_strategy Sets the I/O control strategy based on the provided strategy. get_io_ctrl_strategy Gets the I/O control strategy. read Abstract method for reading data from the mapping. write Abstract method for writing data to the mapping. modify_key Abstract method for modifying keys in the mapping. remove Abstract method for removing data from the mapping. merge_from Abstract method for merging data from another mapping. copy_from Abstract method for copying data from another mapping. append Appends a value to the mapping. clear Clears the data mapping. make_continuous Makes the indices in the mapping continuous. cache_to_file Caches data to files. file_to_cache Reads data from files and updates the cache. clear_files Clears the files associated with the data mapping. clear_cache Clears the cache associated with the data mapping. _set_unfinished_operation Sets the unfinished operation flag. _get_unfinished_operation Gets the unfinished operation flag. _set_last_write_unfinished Sets the flag indicating the last write operation was unfinished. _reset_last_write_unfinished Resets the flag indicating the last write operation was unfinished. _get_last_write_unfinished Gets the flag indicating the last write operation was unfinished. choose_unfinished_operation Asks the user to choose an operation to continue when an operation is unfinished. process_unfinished Processes unfinished operations in the data mapping.","title":"DataMapping"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.FILESHANDLE_TYPE","text":"FILESHANDLE_TYPE : type [ FilesHandle ] = FilesHandle","title":"FILESHANDLE_TYPE"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.INDENTITY_PARA_NAMES","text":"INDENTITY_PARA_NAMES = [ '_top_directory' , 'mapping_name' , 'flag_name' ]","title":"INDENTITY_PARA_NAMES"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.KEY_TYPE","text":"KEY_TYPE = int","title":"KEY_TYPE"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.MEMORY_DATA_FILE","text":"MEMORY_DATA_FILE = '.datamap'","title":"MEMORY_DATA_FILE"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.MEMORY_DATA_TYPE","text":"MEMORY_DATA_TYPE = BinDict","title":"MEMORY_DATA_TYPE"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.MemoryData","text":"MemoryData DO NOT use _MemoryData directly, use this property instead.","title":"MemoryData"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.MemoryData_modified","text":"MemoryData_modified DO NOT use _MemoryData_modified directly, use this property instead.","title":"MemoryData_modified"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.MemoryData_path","text":"MemoryData_path","title":"MemoryData_path"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping._DMT","text":"_DMT = TypeVar ( '_DMT' , bound = 'DataMapping' )","title":"_DMT"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping._MemoryData","text":"_MemoryData : dict [ int , _VT ] = self . load_postprocess ({})","title":"_MemoryData"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping._MemoryData_modified","text":"_MemoryData_modified = True","title":"_MemoryData_modified"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping._VDMT","text":"_VDMT = TypeVar ( '_VDMT' )","title":"_VDMT"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.cache_priority","text":"cache_priority = True","title":"cache_priority"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.children_names","text":"children_names get the identity names of the children nodes","title":"children_names"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.continuous","text":"continuous","title":"continuous"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.data_path","text":"data_path top directory of the data mapping","title":"data_path"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.i_upper","text":"i_upper","title":"i_upper"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.load_memory_func","text":"load_memory_func : Callable [[ str ], dict ] = deserialize_object","title":"load_memory_func"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.next_valid_i","text":"next_valid_i","title":"next_valid_i"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.num","text":"num","title":"num"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.pickle_MemoryData_path","text":"pickle_MemoryData_path","title":"pickle_MemoryData_path"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.save_memory_func","text":"save_memory_func : Callable [[ str , dict ], None ] = serialize_object","title":"save_memory_func"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.strict_priority_mode","text":"strict_priority_mode = False","title":"strict_priority_mode"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.top_directory","text":"top_directory","title":"top_directory"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.write_synchronous","text":"write_synchronous = False","title":"write_synchronous"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.__getitem__","text":"__getitem__ ( data_i : Union [ int , slice ])","title":"__getitem__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.__init__","text":"__init__ ( top_directory : Union [ str , DatasetNode ], mapping_name : str = '' , * args , flag_name : str = '' , ** kwargs ) -> None Initializes the data mapping with the provided top_directory, mapping_name, and registration flag. Parameters: top_directory ( Union [ str , DatasetNode ] ) \u2013 A string or DatasetNode representing the top directory of the data mapping. mapping_name ( str , default: '' ) \u2013 A string representing the name of the data mapping. It's used as sub directory name under top_directory .for FilesCluster (the subclass of DataMapping ) flag_name ( str , default: '' ) \u2013 A string representing the registration flag. It's used to distinguish different instances of the same data mapping.","title":"__init__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.__init_subclass__","text":"__init_subclass__ ( ** kwargs ) Adds hooks to some methods.","title":"__init_subclass__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.__iter__","text":"__iter__ () -> Iterable [ VDMT ]","title":"__iter__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.__len__","text":"__len__ ()","title":"__len__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.__new__","text":"__new__ ( dataset_node : Union [ str , DatasetNode ], mapping_name : str = '' , * args , flag_name = '' , ** kwargs )","title":"__new__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.__repr__","text":"__repr__ ()","title":"__repr__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.__setitem__","text":"__setitem__ ( data_i , value : VDMT )","title":"__setitem__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping._clear_empty_dir","text":"_clear_empty_dir () remove empty directories in the data mapping.","title":"_clear_empty_dir()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping._get_last_write_unfinished","text":"_get_last_write_unfinished ()","title":"_get_last_write_unfinished()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping._get_unfinished_operation","text":"_get_unfinished_operation ()","title":"_get_unfinished_operation()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping._rebuild_done","text":"_rebuild_done ()","title":"_rebuild_done()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping._reset_MemoryData_modified","text":"_reset_MemoryData_modified ()","title":"_reset_MemoryData_modified()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping._reset_last_write_unfinished","text":"_reset_last_write_unfinished ()","title":"_reset_last_write_unfinished()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping._set_MemoryData_modified","text":"_set_MemoryData_modified () this operation will be propagated to all parent nodes in preorder traversal. Examples: dm dm_child1 dm_child2 dm_child3 >>> dm_child3 . _set_MemoryData_modified () >>> dm_child2 . MemoryData_modified True >>> dm . MemoryData_modified True >>> dm_child1 . MemoryData_modified False","title":"_set_MemoryData_modified()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping._set_last_write_unfinished","text":"_set_last_write_unfinished ()","title":"_set_last_write_unfinished()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping._set_unfinished_operation","text":"_set_unfinished_operation ( unfinished_operation )","title":"_set_unfinished_operation()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.append","text":"append ( value : VDMT , * , force = False , ** other_paras )","title":"append()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.cache_to_file","text":"cache_to_file ( data_i : Optional [ int ] = None , * , force = False , ** other_paras )","title":"cache_to_file()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.choose_unfinished_operation","text":"choose_unfinished_operation () skip clear the unfinished data try to rollback the unfinished data exit\"))","title":"choose_unfinished_operation()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.clear","text":"clear ( * , force = False )","title":"clear()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.clear_cache","text":"clear_cache ( * , force = False )","title":"clear_cache()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.clear_files","text":"clear_files ( * , force = False )","title":"clear_files()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.close","text":"close ( closed = True ) see :link: IOStatusManager.close this operation will be propagated to all children nodes in preorder traversal","title":"close()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.copy_from","text":"copy_from ( src : DMT , * , cover = False , force = False ) -> None","title":"copy_from()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.file_to_cache","text":"file_to_cache ( data_i : Optional [ int ] = None , * , save = True , force = False , ** other_paras )","title":"file_to_cache()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.gen_identity_name","text":"gen_identity_name () see :link: RegisterInstance.gen_identity_name","title":"gen_identity_name()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.gen_identity_name--note","text":"if self.flag_name is not empty, return self.flag_name , otherwise return self.mapping_name","title":"Note"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.gen_identity_string","text":"gen_identity_string () see :link: RegisterInstance.gen_identity_string","title":"gen_identity_string()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.get_child","text":"get_child ( name : str ) get the child node with the specified name","title":"get_child()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.get_instance","text":"get_instance ( identity_string , _obj ) see :link: RegisterInstance.get_instance","title":"get_instance()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.get_io_ctrl_strategy","text":"get_io_ctrl_strategy ()","title":"get_io_ctrl_strategy()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.get_writing_mark_file","text":"get_writing_mark_file ()","title":"get_writing_mark_file()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.has_not_inited","text":"has_not_inited () Checks if the data mapping has not been initialized. Returns: bool ( ) \u2013 True if the data mapping has not been initialized, False otherwise.","title":"has_not_inited()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.identity_name","text":"identity_name () see :link: RegisterInstance.identity_name","title":"identity_name()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.identity_string","text":"identity_string () see :link: RegisterInstance.identity_string","title":"identity_string()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.init_identity","text":"init_identity ( parent_like : Union [ str , DatasetNode ], mapping_name : str , * args , flag_name = '' , ** kwargs ) Initializes the identity of the data mapping. Parameters: parent_like ( Union [ str , DatasetNode ] ) \u2013 A string or DatasetNode representing the parent of the data mapping. mapping_name ( str ) \u2013 A string representing the name of the data mapping. flag_name \u2013 A string representing the flag name. Raises: TypeError: \u2013 If parent_like is not a string or DatasetNode. see :link: DataMapping.__init__ for more information.","title":"init_identity()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.items","text":"items ()","title":"items()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.keys","text":"keys ()","title":"keys()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.load","text":"load () load self.MemoryData from file","title":"load()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.load_postprocess","text":"load_postprocess ( data ) the opertions to do after loading memory data recommend to override this method in subclass","title":"load_postprocess()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.make_continuous","text":"make_continuous ( * , force = False )","title":"make_continuous()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.make_path","text":"make_path () Create the directory path specified by self.data_path if it does not exist. If self.data_path ends with a file extension, create the parent directory and an empty file. If self.data_path does not end with a file extension, create the directory recursively.","title":"make_path()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.merge_MemoryData","text":"merge_MemoryData ( MemoryData : dict )","title":"merge_MemoryData()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.merge_from","text":"merge_from ( src : DMT , * , force = False ) -> None","title":"merge_from()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.modify_key","text":"modify_key ( src : int , dst : int , * , force = False , ** other_paras ) -> None","title":"modify_key()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.open","text":"open ( opened = True ) see :link: IOStatusManager.open this operation will be propagated to all children nodes in preorder traversal","title":"open()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.open_hook","text":"open_hook ()","title":"open_hook()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.process_unfinished","text":"process_unfinished ()","title":"process_unfinished()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.read","text":"read ( src : int ) -> VDMT","title":"read()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.rebuild","text":"rebuild ( force = False ) Rebuilds self.MemoryData by the files. if MemoryData_path does not exist or load_postprocess fails, this method will be called. must override this method in subclass","title":"rebuild()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.register","text":"register ( identity_string , obj : DataMapping ) see :link: RegisterInstance.register","title":"register()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.remove","text":"remove ( dst : int , * , force = False , ** other_paras ) -> None","title":"remove()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.remove_mark","text":"remove_mark () see :link: IOStatusManager.remove_mark this operation will be propagated to all children nodes in preorder traversal","title":"remove_mark()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.remove_memory_data_file","text":"remove_memory_data_file ()","title":"remove_memory_data_file()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.remove_pickle_datamaping","text":"remove_pickle_datamaping ()","title":"remove_pickle_datamaping()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.save","text":"save ( force = False ) save self.MemoryData to file","title":"save()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.save_as_pickle","text":"save_as_pickle ( force = False )","title":"save_as_pickle()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.save_preprecess","text":"save_preprecess () the opertions to do before saving memory data recommend to override this method in subclass","title":"save_preprecess()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.set_io_ctrl_strategy","text":"set_io_ctrl_strategy ( strategy )","title":"set_io_ctrl_strategy()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.set_overwrite_allowed","text":"set_overwrite_allowed ( overwrite_allowed = True ) see :link: IOStatusManager.set_overwrite_allowed this operation will be propagated to all children nodes in preorder traversal","title":"set_overwrite_allowed()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.set_overwrite_forbidden","text":"set_overwrite_forbidden ( overwrite_forbidden = True ) see :link: IOStatusManager.set_overwrite_forbidden this operation will be propagated to all children nodes in preorder traversal","title":"set_overwrite_forbidden()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.set_parent","text":"set_parent ( parent : DataMapping )","title":"set_parent()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.set_readonly","text":"set_readonly ( readonly = True ) see :link: IOStatusManager.set_readonly this operation will be propagated to all children nodes in preorder traversal","title":"set_readonly()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.set_writable","text":"set_writable ( writable = True ) see :link: IOStatusManager.set_writable this operation will be propagated to all children nodes in preorder traversal","title":"set_writable()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.sort","text":"sort ()","title":"sort()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.start_writing","text":"start_writing ( start_writing = True ) see :link: IOStatusManager.start_writing this operation will be propagated to all children nodes in preorder traversal","title":"start_writing()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.stop_writing","text":"stop_writing ( stop_writing = True ) see :link: IOStatusManager.stop_writing this operation will be propagated to all children nodes in preorder traversal","title":"stop_writing()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.stop_writing_hook","text":"stop_writing_hook ()","title":"stop_writing_hook()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.try_open","text":"try_open () Tries to open the data mapping for operation. If the data path exists, it opens the data mapping. Otherwise, it closes the data mapping.","title":"try_open()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.values","text":"values () -> Generator [ VDMT , Any , None ]","title":"values()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DataMapping.write","text":"write ( dst : int , value : VDMT , * , force = False , ** other_paras ) -> None","title":"write()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode","text":"Bases: DataMapping [ dict [ str , bool ], DSNT , VDST ] , ABC , Generic [ FCT , DSNT , VDST ] Represents a dataset node in the data mapping hierarchy. Attributes: MEMORY_DATA_TYPE (Table[int, str, bool]): The memory data type. MEMORY_DATA_FILE (str): The memory data file. load_memory_func (function): The function used to load memory data. save_memory_func (function): The function used to save memory data.","title":"DatasetNode"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.MEMORY_DATA_FILE","text":"MEMORY_DATA_FILE = '.overview'","title":"MEMORY_DATA_FILE"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.MEMORY_DATA_TYPE","text":"MEMORY_DATA_TYPE = Table [ int , str , bool ]","title":"MEMORY_DATA_TYPE"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.MemoryData","text":"MemoryData : Table [ int , str , bool ] Gets the memory data. Returns: Table[int, str, bool]: The memory data.","title":"MemoryData"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.child_node_num","text":"child_node_num : int","title":"child_node_num"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.child_nodes","text":"child_nodes : list [ DatasetNode ]","title":"child_nodes"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.child_nodes_map","text":"child_nodes_map : dict [ str , DatasetNode ] = dict ()","title":"child_nodes_map"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.cluster_use_rely","text":"cluster_use_rely","title":"cluster_use_rely"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.clusters","text":"clusters : list [ FCT ] Gets the clusters in the dataset node. Returns: list[FCT]: The clusters.","title":"clusters"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.clusters_map","text":"clusters_map : dict [ str , FCT ] = dict ()","title":"clusters_map"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.clusters_num","text":"clusters_num : int Gets the number of clusters in the dataset node. Returns: int: The number of clusters.","title":"clusters_num"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.elem_clusters","text":"elem_clusters : list [ FCT ] Gets the element clusters in the dataset node. Returns: list[FCT]: The element clusters.","title":"elem_clusters"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.load_memory_func","text":"load_memory_func = JsonIO . load_json","title":"load_memory_func"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.opened_clusters","text":"opened_clusters Gets the opened clusters in the dataset node. Returns: list[FCT]: The opened clusters.","title":"opened_clusters"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.opened_elem_clusters","text":"opened_elem_clusters Gets the opened element clusters in the dataset node. Returns: list[FCT]: The opened element clusters.","title":"opened_elem_clusters"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.save_memory_func","text":"save_memory_func = JsonIO . dump_json","title":"save_memory_func"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.__init__","text":"__init__ ( top_directory : Union [ str , DatasetNode ], mapping_name : str = '' , * args , flag_name = '' , ** kwargs ) -> None Initializes a DatasetNode instance. Args: top_directory (Union[str, DatasetNode]): The top directory of the dataset node. mapping_name (str, optional): The mapping name. Defaults to \"\". flag_name (str, optional): The flag name. Defaults to \"\". args: Additional positional arguments. *kwargs: Additional keyword arguments.","title":"__init__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.__setattr__","text":"__setattr__ ( name , value )","title":"__setattr__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode._clear_empty_row","text":"_clear_empty_row ( data_i : int , force = False )","title":"_clear_empty_row()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode._move_row","text":"_move_row ( src , dst )","title":"_move_row()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.add_child_node","text":"add_child_node ( child_node : DatasetNode ) Adds a child node to the dataset node. Args: child_node (DatasetNode): The child node to add.","title":"add_child_node()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.add_cluster","text":"add_cluster ( cluster : FCT ) Adds a cluster to the dataset node. Args: cluster (FCT): The cluster to add.","title":"add_cluster()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.cache_to_file","text":"cache_to_file ( * , force = False )","title":"cache_to_file()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.calc_overview","text":"calc_overview ( data_i )","title":"calc_overview()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.child_node_keys","text":"child_node_keys () Gets the keys of the child nodes in the dataset node. Returns: dict_keys: The keys of the child nodes.","title":"child_node_keys()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.clear","text":"clear ( * , force = False , clear_both = True , clear_completely = False )","title":"clear()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.clear_cache","text":"clear_cache ( * , force = False )","title":"clear_cache()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.clear_files","text":"clear_files ( * , force = False )","title":"clear_files()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.cluster_keys","text":"cluster_keys () Gets the keys of the clusters in the dataset node. Returns: dict_keys: The keys of the clusters.","title":"cluster_keys()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.cluster_use_rely_decorator","text":"cluster_use_rely_decorator ( func )","title":"cluster_use_rely_decorator()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.copy_from","text":"copy_from ( src_dataset_node : DSNT , * , cover = False , force = False ) -> None","title":"copy_from()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.file_to_cache","text":"file_to_cache ( * , force = False )","title":"file_to_cache()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.get_all_clusters","text":"get_all_clusters ( _type : Union [ type , tuple [ type ]] = None , only_opened = False ) -> dict [ int , FCT ] Gets all clusters in the dataset node. Args: _type (Union[type, tuple[type]], optional): The type of clusters to retrieve. Defaults to None. only_opened (bool, optional): Whether to retrieve only opened clusters. Defaults to False. Returns: dict[int, FCT]: A dictionary of clusters.","title":"get_all_clusters()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.get_child_node","text":"get_child_node ( identity_name : str ) Gets a child node from the dataset node. Args: identity_name (str): The identity name of the child node. Returns: DatasetNode: The child node.","title":"get_child_node()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.get_cluster","text":"get_cluster ( identity_name : str ) Gets a cluster from the dataset node. Args: identity_name (str): The identity name of the cluster. Returns: FCT: The cluster.","title":"get_cluster()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.init_clusters_hook","text":"init_clusters_hook ()","title":"init_clusters_hook()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.init_dataset_attr_hook","text":"init_dataset_attr_hook () Initializes the dataset attribute hook.","title":"init_dataset_attr_hook()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.load_postprocess","text":"load_postprocess ( data : dict )","title":"load_postprocess()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.merge_MemoryData","text":"merge_MemoryData ( MemoryData : Table [ int , str , bool ])","title":"merge_MemoryData()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.merge_from","text":"merge_from ( src_dataset_node : DSNT , * , force = False ) -> None","title":"merge_from()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.modify_key","text":"modify_key ( src : int , dst : int , * , force = False , ** other_paras ) -> None","title":"modify_key()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.operate_children_node","text":"operate_children_node ( func : Union [ Callable , str ], * args , ** kwargs )","title":"operate_children_node()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.operate_clusters","text":"operate_clusters ( func : Union [ Callable , str ], * args , ** kwargs )","title":"operate_clusters()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.operate_one_child_node","text":"operate_one_child_node ( child_node : DatasetNode , func : Union [ Callable , str ], * args , ** kwargs )","title":"operate_one_child_node()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.operate_one_cluster","text":"operate_one_cluster ( cluster , func : Union [ Callable , str ], * args , ** kwargs )","title":"operate_one_cluster()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.raw_read","text":"raw_read ( src , * , force = False , ** other_paras ) -> dict [ str , Any ]","title":"raw_read()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.raw_write","text":"raw_write ( dst , values : dict [ str , Any ], * , force = False , ** other_paras ) -> None","title":"raw_write()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.read","text":"read ( src : int ) -> VDST","title":"read()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.rebuild","text":"rebuild ( force = False )","title":"rebuild()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.remove","text":"remove ( dst : int , * , force = False , ** other_paras ) -> None","title":"remove()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.remove_child_node","text":"remove_child_node ( child_node : DatasetNode ) Removes a child node from the dataset node. Args: child_node (DatasetNode): The child node to remove.","title":"remove_child_node()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.remove_cluster","text":"remove_cluster ( cluster : FCT ) Removes a cluster from the dataset node. Args: cluster (FCT): The cluster to remove.","title":"remove_cluster()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.save_all","text":"save_all ( force = False )","title":"save_all()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.save_preprecess","text":"save_preprecess ( MemoryData : Table = None )","title":"save_preprecess()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.update_clusters","text":"update_clusters ( log_type , src , dst , value , cluster )","title":"update_clusters()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.update_overview","text":"update_overview ( log_type , src , dst , value , cluster : FilesCluster )","title":"update_overview()"},{"location":"md/data/IOAbstract/#data.IOAbstract.DatasetNode.write","text":"write ( dst : int , value : VDST , * , force = False , ** other_paras ) -> None","title":"write()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster","text":"Bases: DataMapping [ FHT , FCT , VDMT ] , Generic [ FHT , FCT , DSNT , VDMT ]","title":"FilesCluster"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster--filescluster","text":"A class representing a cluster of files.","title":"FilesCluster"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster--class-attributes","text":"","title":"Class Attributes:"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster--_is_elem","text":"","title":"_IS_ELEM"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster--_elem_by_cache","text":"\u9700\u8981\u8bf4\u660e\u7684\u662fdata\u548celem\u7684\u5b9a\u4e49\uff1a data \u662f\u6307 FilesCluster \u5bf9\u8c61\u5305\u542b\u7684\u6587\u4ef6\uff0c\u5f53 _ELEM_BY_CACHE \u4e3a False \u65f6\uff0c \u6240\u4f7f\u7528\u7684\u7d22\u5f15\u662f\u9ed8\u8ba4\u9488\u5bf9\u5728 FilesCluster.MemoryData \u4e2d\u5bf9\u5e94\u7684 FilesHandle \u7684\u3002 \u800c\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u6587\u4ef6\u7684IO\u64cd\u4f5c\u53ef\u80fd\u662f\u4e0d\u63a8\u8350\u76f4\u63a5\u8fdb\u884c\u7684\uff0c\u800c\u5e94\u8be5\u5148\u64cd\u4f5c FilesHandle \u7684 cache \uff0c \u7136\u540e\u518d\u8c03\u7528 cache_to_file \u3002\u5426\u5219\uff0c\u5982\u679c\u6bcf\u6761\u6570\u636e\u7684\u5199\u5165\u90fd\u9700\u8981\u8fdb\u884cIO\u64cd\u4f5c\uff0c\u4f1a\u6d88\u8017\u5927\u91cf\u8d44\u6e90\u3002 \u4f8b\u5982\u4e00\u4e2a\u5305\u542b\u4e86\u591a\u6761\u6570\u636e\u7684json/xml\u6587\u4ef6\u3002\u8fd9\u65f6\u9700\u8981\u8bbe\u7f6e _ELEM_BY_CACHE \u4e3a True \uff0c \u4f7f\u5f97\u7d22\u5f15\u9ed8\u8ba4\u9488\u5bf9 elem \uff0c\u5373\u5bf9\u6240\u6709 FilesHandle \u7684cache\u540c\u540d\u7684 key \u3002","title":"_ELEM_BY_CACHE"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster--_elem_by_cache_1","text":"","title":"_ELEM_BY_CACHE\u7684\u503c\u4f1a\u5f71\u54cd\u4e00\u7cfb\u5217\u5c5e\u6027\u548c\u65b9\u6cd5\u7684\u9ed8\u8ba4\u8c03\u7528\uff0c\u4f60\u4e5f\u53ef\u4ee5\u8c03\u7528\u5bf9\u5e94\u7684\u660e\u786e\u65b9\u6cd5\uff1a"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster--_1","text":"num : data_num / elem_num i_upper : data_i_upper / elem_i_upper next_valid_i : next_valid_elem_i / net_valid_data_i","title":"\u5c5e\u6027\uff1a"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster--_2","text":"read : read_data / read_elem write : write_data / write_elem modify_key : modify_data_key / modity_elem_key remove : remove_data / remove_elem merge_from : merge_data_from / merge_elem_from copy_from : copy_data_from / copy_elem_from clear : clear_data / clear_elem keys : data_keys / elem_keys idx_unwritten","title":"\u65b9\u6cd5\uff1a"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster--selfmemorydata2fileshandle","text":"fc.MemoryData {0: fh0, 1: fh1} fh0.cache {0: array([0,1,2]), 1: array([3,4,5]) 2: array([6,7,8])} fh1.cache \u5982\u679c _ELEM_BY_CACHE \u4e3a False \uff0c\u8c03\u7528 read \u65f6\uff0c\u5b9e\u9645\u4e0a read_data \u4f1a\u88ab\u8c03\u7528 fc.read(0) # \u7b49\u6548\u4e8efc.read_data(0) \u5982\u679c _ELEM_BY_CACHE \u4e3a True \uff0c\u8c03\u7528 read \u65f6\uff0c\u5b9e\u9645\u4e0a read_elem \u4f1a\u88ab\u8c03\u7528 fc.read(0) # \u7b49\u6548\u4e8efc.read_elem(0) (array([0,1,2]), 1.0) KEY_TYPE: The type of the keys used to access the files in the cluster. ALWAYS_ALLOW_WRITE: A boolean indicating whether write operations are always allowed. ALWAYS_ALLOW_OVERWRITE: A boolean indicating whether overwriting files is always allowed. DEFAULT_SUFFIX: The default suffix for file names. DEFAULT_PREFIX: The default prefix for file names. DEFAULT_PREFIX_JOINER: The default joiner for prefix and core names. DEFAULT_APPENDNAMES: The default append names for file names. DEFAULT_APPENDNAMES_JOINER: The default joiner for append names. DEFAULT_READ_FUNC: The default function for reading files. DEFAULT_WRITE_FUNC: The default function for writing files. DEFAULT_VALUE_TYPE: The default type of the values stored in the files. DEFAULT_VALUE_INIT_FUNC: The default function for initializing values. MULTI_FILES: A boolean indicating whether the cluster contains multiple files. STRATEGY_ONLY_CACHE: The strategy for file operations when only using cache. STRATEGY_ONLY_FILE: The strategy for file operations when only using file. STRATEGY_CACHE_AND_FILE: The strategy for file operations when using both cache and file. Properties commonly used: * dataset_node: The dataset node that the cluster belongs to. * continuous: A boolean indicating whether the cluster is continuous. * num: The number of files in the cluster. * i_upper: The upper bound of the indices of the files in the cluster. Methods commonly used: * query_all_fileshandle: Queries all the file handles in the cluster. * read: Reads a file from the cluster. * write: Writes a file to the cluster. * modify_key: Modifies the key of a file in the cluster. * remove: Removes a file from the cluster. * merge_from: Merges the cluster from another cluster. * copy_from: Copies the cluster from another cluster. * append: Appends a file to the cluster. * clear: Clears the cluster. * make_continuous: Makes the cluster continuous.","title":"\u4e3e\u4e2a\u4f8b\u5b50\uff0c\u5982\u679c\u5728self.MemoryData\u4e2d\u67092\u4e2aFilesHandle\uff1a"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.ALWAYS_ALLOW_OVERWRITE","text":"ALWAYS_ALLOW_OVERWRITE = False","title":"ALWAYS_ALLOW_OVERWRITE"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.ALWAYS_ALLOW_WRITE","text":"ALWAYS_ALLOW_WRITE = False","title":"ALWAYS_ALLOW_WRITE"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.DEFAULT_APPENDNAMES","text":"DEFAULT_APPENDNAMES = None","title":"DEFAULT_APPENDNAMES"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.DEFAULT_APPENDNAMES_JOINER","text":"DEFAULT_APPENDNAMES_JOINER = None","title":"DEFAULT_APPENDNAMES_JOINER"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.DEFAULT_PREFIX","text":"DEFAULT_PREFIX = None","title":"DEFAULT_PREFIX"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.DEFAULT_PREFIX_JOINER","text":"DEFAULT_PREFIX_JOINER = None","title":"DEFAULT_PREFIX_JOINER"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.DEFAULT_READ_FUNC","text":"DEFAULT_READ_FUNC = None","title":"DEFAULT_READ_FUNC"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.DEFAULT_SUFFIX","text":"DEFAULT_SUFFIX = None","title":"DEFAULT_SUFFIX"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.DEFAULT_VALUE_INIT_FUNC","text":"DEFAULT_VALUE_INIT_FUNC = None","title":"DEFAULT_VALUE_INIT_FUNC"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.DEFAULT_VALUE_TYPE","text":"DEFAULT_VALUE_TYPE = None","title":"DEFAULT_VALUE_TYPE"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.DEFAULT_WRITE_FUNC","text":"DEFAULT_WRITE_FUNC = None","title":"DEFAULT_WRITE_FUNC"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.KEY_TYPE","text":"KEY_TYPE = int xyz","title":"KEY_TYPE"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.MULTI_FILES","text":"MULTI_FILES = False","title":"MULTI_FILES"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.MemoryData","text":"MemoryData : BinDict [ int , FHT ]","title":"MemoryData"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.STRATEGY_CACHE_AND_FILE","text":"STRATEGY_CACHE_AND_FILE = 2","title":"STRATEGY_CACHE_AND_FILE"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.STRATEGY_ONLY_CACHE","text":"STRATEGY_ONLY_CACHE = 0","title":"STRATEGY_ONLY_CACHE"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.STRATEGY_ONLY_FILE","text":"STRATEGY_ONLY_FILE = 1","title":"STRATEGY_ONLY_FILE"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._ELEM_BY_CACHE","text":"_ELEM_BY_CACHE = False","title":"_ELEM_BY_CACHE"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._FCT","text":"_FCT = TypeVar ( '_FCT' , bound = 'FilesCluster' )","title":"_FCT"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._FHT","text":"_FHT = TypeVar ( '_FHT' , bound = FilesHandle )","title":"_FHT"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._IS_ELEM","text":"_IS_ELEM = False","title":"_IS_ELEM"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._VDMT","text":"_VDMT = TypeVar ( '_VDMT' )","title":"_VDMT"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.continuous","text":"continuous","title":"continuous"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.data_continuous","text":"data_continuous","title":"data_continuous"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.data_i_upper","text":"data_i_upper","title":"data_i_upper"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.data_num","text":"data_num","title":"data_num"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.dataset_node","text":"dataset_node : DatasetNode","title":"dataset_node"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.elem_continuous","text":"elem_continuous","title":"elem_continuous"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.elem_i_upper","text":"elem_i_upper","title":"elem_i_upper"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.elem_num","text":"elem_num","title":"elem_num"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.i_upper","text":"i_upper","title":"i_upper"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.next_valid_data_i","text":"next_valid_data_i","title":"next_valid_data_i"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.next_valid_elem_i","text":"next_valid_elem_i","title":"next_valid_elem_i"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.next_valid_i","text":"next_valid_i","title":"next_valid_i"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.num","text":"num","title":"num"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.registerd","text":"registerd","title":"registerd"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.use_rely","text":"use_rely Check if use rely","title":"use_rely"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._change_dir","text":"Bases: _operation [ _FCT , _VDMT , _FHT ]","title":"_change_dir"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._change_dir.W_SYNC","text":"W_SYNC = True","title":"W_SYNC"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._change_dir.core_func","text":"core_func = os . rename","title":"core_func"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._change_dir.__init__","text":"__init__ ( files_cluster ) -> None","title":"__init__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._change_dir.check_value","text":"check_value ( value : str )","title":"check_value()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._change_dir.cvt_to_core_paras","text":"cvt_to_core_paras ( src_file_handle : FilesHandle , dst_file_handle : FilesHandle , value : FilesHandle , ** other_paras ) -> tuple","title":"cvt_to_core_paras()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._change_dir.get_FilesHandle","text":"get_FilesHandle ( src , dst , value : str )","title":"get_FilesHandle()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._change_dir.io_cache","text":"io_cache ( src_file_handle , dst_file_handle , value = None ) -> Any","title":"io_cache()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._modify_key","text":"Bases: IOMeta [ _FCT , _VDMT , _FHT ]","title":"_modify_key"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._modify_key.LOG_TYPE","text":"LOG_TYPE = IOStatusManager . LOG_MOVE","title":"LOG_TYPE"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._modify_key.READ","text":"READ = False","title":"READ"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._modify_key.W_SYNC","text":"W_SYNC = True","title":"W_SYNC"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._modify_key.core_func","text":"core_func = os . rename","title":"core_func"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._modify_key.__init__","text":"__init__ ( files_cluster ) -> None","title":"__init__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._modify_key.cvt_to_core_paras","text":"cvt_to_core_paras ( src_file_handle : FilesHandle , dst_file_handle : FilesHandle , value , ** other_paras ) -> tuple","title":"cvt_to_core_paras()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._modify_key.get_FilesHandle","text":"get_FilesHandle ( src , dst , value , ** other_paras )","title":"get_FilesHandle()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._modify_key.io_cache","text":"io_cache ( src_file_handle , dst_file_handle : FilesHandle , value = None ) -> Any","title":"io_cache()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._operation","text":"Bases: IOMeta [ _FCT , _VDMT , _FHT ]","title":"_operation"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._operation.LOG_TYPE","text":"LOG_TYPE = IOStatusManager . LOG_OPERATION","title":"LOG_TYPE"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._operation.READ","text":"READ = False","title":"READ"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._paste_file","text":"Bases: IOMeta [ _FCT , _VDMT , _FHT ]","title":"_paste_file"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._paste_file.LOG_TYPE","text":"LOG_TYPE = IOStatusManager . LOG_ADD","title":"LOG_TYPE"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._paste_file.PATH_EXISTS_REQUIRED","text":"PATH_EXISTS_REQUIRED = True","title":"PATH_EXISTS_REQUIRED"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._paste_file.READ","text":"READ = False","title":"READ"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._paste_file.core_func","text":"core_func = shutil . copy","title":"core_func"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._paste_file.__init__","text":"__init__ ( files_cluster ) -> None","title":"__init__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._paste_file.cvt_to_core_paras","text":"cvt_to_core_paras ( src_file_handle : FilesHandle , dst_file_handle : FilesHandle , value : FilesHandle , ** other_paras ) -> tuple","title":"cvt_to_core_paras()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._paste_file.get_FilesHandle","text":"get_FilesHandle ( src , dst , value , ** other_paras )","title":"get_FilesHandle()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._paste_file.io_cache","text":"io_cache ( src_file_handle , dst_file_handle : FilesHandle , value : FilesHandle = None ) -> Any","title":"io_cache()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._read","text":"Bases: IOMeta [ _FCT , _VDMT , _FHT ]","title":"_read"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._read.cvt_to_core_paras","text":"cvt_to_core_paras ( src_file_handle : FilesHandle , dst_file_handle : FilesHandle , value , ** other_paras ) -> tuple","title":"cvt_to_core_paras()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._read.get_FilesHandle","text":"get_FilesHandle ( src , dst , value , ** other_paras )","title":"get_FilesHandle()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._read.get_file_core_func","text":"get_file_core_func ( src_file_handle : FHT , dst_file_handle : FHT , value ) -> Callable","title":"get_file_core_func()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._read.io_cache","text":"io_cache ( src_file_handle : FilesHandle , dst_file_handle , value = None ) -> Any","title":"io_cache()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._remove","text":"Bases: IOMeta [ _FCT , _VDMT , _FHT ]","title":"_remove"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._remove.LOG_TYPE","text":"LOG_TYPE = IOStatusManager . LOG_REMOVE","title":"LOG_TYPE"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._remove.READ","text":"READ = False","title":"READ"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._remove.core_func","text":"core_func = os . remove","title":"core_func"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._remove.__init__","text":"__init__ ( files_cluster ) -> None","title":"__init__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._remove.check_dst","text":"check_dst ( dst )","title":"check_dst()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._remove.cvt_to_core_paras","text":"cvt_to_core_paras ( src_file_handle : FilesHandle , dst_file_handle : FilesHandle , value , ** other_paras ) -> tuple","title":"cvt_to_core_paras()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._remove.get_FilesHandle","text":"get_FilesHandle ( src , dst , value , ** other_paras )","title":"get_FilesHandle()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._remove.io_cache","text":"io_cache ( src_file_handle , dst_file_handle : FilesHandle , value = None ) -> Any","title":"io_cache()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._write","text":"Bases: IOMeta [ _FCT , _VDMT , _FHT ]","title":"_write"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._write.LOG_TYPE","text":"LOG_TYPE = IOStatusManager . LOG_ADD","title":"LOG_TYPE"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._write.PATH_EXISTS_REQUIRED","text":"PATH_EXISTS_REQUIRED = False","title":"PATH_EXISTS_REQUIRED"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._write.READ","text":"READ = False","title":"READ"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._write.cvt_to_core_paras","text":"cvt_to_core_paras ( src_file_handle : FilesHandle , dst_file_handle : FilesHandle , value , ** other_paras ) -> tuple","title":"cvt_to_core_paras()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._write.get_FilesHandle","text":"get_FilesHandle ( src , dst , value , ** other_paras )","title":"get_FilesHandle()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._write.get_file_core_func","text":"get_file_core_func ( src_file_handle , dst_file_handle : FilesHandle , value ) -> Callable [ ... , Any ]","title":"get_file_core_func()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._write.io_cache","text":"io_cache ( src_file_handle , dst_file_handle : FilesHandle , value = None ) -> Any","title":"io_cache()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.__contains__","text":"__contains__ ( i )","title":"__contains__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.__init__","text":"__init__ ( dataset_node : Union [ str , DatasetNode ], mapping_name : str , * args , flag_name = '' , ** kwargs ) -> None","title":"__init__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._clear_rely","text":"_clear_rely ()","title":"_clear_rely()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._get_rely","text":"_get_rely ( name )","title":"_get_rely()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._pop_fileshandle","text":"_pop_fileshandle ( data_i ) Pop the file handle for the given data index from the MemoryData dictionary. Args: data_i (int): The index of the data. Returns: object: The popped file handle.","title":"_pop_fileshandle()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._send_rely","text":"_send_rely ( rlt ) send parameters to the relying clusters","title":"_send_rely()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._set_fileshandle","text":"_set_fileshandle ( data_i , fileshandle : FHT ) Set the fileshandle for the given data index. Parameters: data_i (int): The index of the data. fileshandle (FHT): The fileshandle to be set. Returns: bool: True if the fileshandle is set successfully, False otherwise.","title":"_set_fileshandle()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._set_rely","text":"_set_rely ( relied : FilesCluster , rlt ) set relied parameters from the relied cluster, relied is the cluster that send the parameters, rlt is the parameters","title":"_set_rely()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._switch_io_operation","text":"_switch_io_operation ( io_data_func , io_elem_func )","title":"_switch_io_operation()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster._update_rely","text":"_update_rely ( name , rlt )","title":"_update_rely()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.cache_to_file","text":"cache_to_file ( data_i : int = None , * , force = False , ** other_paras )","title":"cache_to_file()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.change_dir","text":"change_dir ( dst : int , new_dir_name , * , force = False , ** other_paras ) -> None","title":"change_dir()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.clear","text":"clear ( * , force = False , clear_both = True )","title":"clear()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.clear_cache","text":"clear_cache ( * , force = False )","title":"clear_cache()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.clear_data","text":"clear_data ( * , force = False , clear_both = True )","title":"clear_data()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.clear_elem","text":"clear_elem ( * , force = False , clear_both = True )","title":"clear_elem()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.clear_files","text":"clear_files ( * , force = False )","title":"clear_files()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.copy_data_from","text":"copy_data_from ( src_data_map : FCT , * , cover = False , force = False )","title":"copy_data_from()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.copy_elem_from","text":"copy_elem_from ( src_data_map : FCT , * , cover = False , force = False )","title":"copy_elem_from()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.copy_from","text":"copy_from ( src_data_map : FCT , * , cover = False , force = False )","title":"copy_from()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.create_fh","text":"create_fh ( path )","title":"create_fh()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.create_fileshandle_in_iometa","text":"create_fileshandle_in_iometa ( src , dst , value , ** other_paras ) -> FHT","title":"create_fileshandle_in_iometa()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.cvt_key","text":"cvt_key ( key )","title":"cvt_key()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.data_keys","text":"data_keys ()","title":"data_keys()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.deformat_corename","text":"deformat_corename ( corename : str ) -> int Deformats the core name of the data. * recommended to be overridden in subclasses e.g.: \"000001\" -> 1 \"000309\" -> 309 Args: corename (str): The core name. Returns: int","title":"deformat_corename()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.elem_keys","text":"elem_keys ()","title":"elem_keys()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.file_to_cache","text":"file_to_cache ( data_i : int = None , * , save = True , force = False , auto_decide = True , ** other_paras )","title":"file_to_cache()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.format_corename","text":"format_corename ( data_i : int ) -> str Formats the core name of the data. * recommended to be overridden in subclasses e.g.: 1 -> \"000001\" 309 -> \"000309\" Args: data_i (int): The data index. Returns: str","title":"format_corename()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.from_cluster","text":"from_cluster ( cluster : FCT , dataset_node : DSNT = None , mapping_name = None , * args , flag_name = '' , ** kwargs ) -> FCT","title":"from_cluster()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.get_rely_io_parameters","text":"get_rely_io_parameters ()","title":"get_rely_io_parameters()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.has","text":"has ( i )","title":"has()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.has_data","text":"has_data ( elem_i )","title":"has_data()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.has_elem","text":"has_elem ( elem_i )","title":"has_elem()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.idx_unwrited","text":"idx_unwrited ( idx )","title":"idx_unwrited()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.init_attrs","text":"init_attrs ()","title":"init_attrs()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.init_io_metas","text":"init_io_metas ()","title":"init_io_metas()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.io_decorator","text":"io_decorator ( io_meta : IOMeta , force = False ) Decorator function for input/output operations. Args: io_meta (IOMeta): The metadata object for the input/output operation. force (bool): Flag indicating whether to force the operation. Defaults to False. Returns: function: The decorated function.","title":"io_decorator()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.keys","text":"keys ()","title":"keys()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.link_rely_on","text":"link_rely_on ( cluster : FilesCluster ) Links the current cluster to the specified cluster as a relying cluster.","title":"link_rely_on()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.link_rely_on--details","text":"The IO of the cluster may depend on other clusters. For example, the normalized pixel coordinates depend on the size of the image. In this case, you can use link_rely_on to set the cluster that self depends on. relying_clusters: those clusters that rely on self relied_clusters: those clusters that self relies on","title":"Details:"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.link_rely_on--args","text":"cluster (FilesCluster): The cluster to be linked as a relying cluster.","title":"Args:"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.load_and_process_data","text":"load_and_process_data ( key , value )","title":"load_and_process_data()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.load_postprocess","text":"load_postprocess ( data : dict )","title":"load_postprocess()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.matching_path","text":"matching_path ()","title":"matching_path()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.merge_MemoryData","text":"merge_MemoryData ( MemoryData : BinDict [ int , FHT ])","title":"merge_MemoryData()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.merge_data_from","text":"merge_data_from ( src_data_map : FCT , * , force = False )","title":"merge_data_from()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.merge_elem_from","text":"merge_elem_from ( src_data_map : FCT , * , force = False )","title":"merge_elem_from()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.merge_from","text":"merge_from ( src_data_map : FCT , * , force = False )","title":"merge_from()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.modify_data_key","text":"modify_data_key ( src : int , dst : int , * , force = False , ** other_paras ) -> None","title":"modify_data_key()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.modify_elem_key","text":"modify_elem_key ( src : int , dst : int , * , force = False , ** other_paras )","title":"modify_elem_key()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.modify_key","text":"modify_key ( src : int , dst : int , * , force = False , ** other_paras ) -> None","title":"modify_key()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.paste_file","text":"paste_file ( dst : int , file_handler : FilesHandle , * , force = False , ** other_paras ) -> None","title":"paste_file()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.query_all_fileshandle","text":"query_all_fileshandle () Returns all the file handles stored in the MemoryData dictionary. Returns: list: A list of file handles.","title":"query_all_fileshandle()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.query_fileshandle","text":"query_fileshandle ( data_i : int ) -> FHT Retrieve the fileshandle at the specified index from the MemoryData. Args: data_i (int): The index of the fileshandle to retrieve. Returns: FHT: The fileshandle at the specified index.","title":"query_fileshandle()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.query_fileshandle_from_iterable","text":"query_fileshandle_from_iterable ( iterable : Union [ Iterable , slice ]) -> Generator [ FHT , Any , None ] Queries fileshandle from an iterable or a slice. Args: iterable (Union[Iterable, slice]): An iterable or a slice. Yields: Generator[FHT, Any, None]: A generator that yields fileshandle. Returns: None","title":"query_fileshandle_from_iterable()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.read","text":"read ( src : int , * , force = False , ** other_paras ) -> VDMT","title":"read()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.read_data","text":"read_data ( src : int , * , force = False , ** other_paras ) -> VDMT","title":"read_data()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.read_elem","text":"read_elem ( src : int , * , force = False , ** other_paras )","title":"read_elem()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.rebuild","text":"rebuild ( force = False )","title":"rebuild()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.remove","text":"remove ( dst : int , remove_both = False , * , force = False , ** other_paras ) -> None","title":"remove()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.remove_data","text":"remove_data ( dst : int , remove_both = False , * , force = False , ** other_paras ) -> None","title":"remove_data()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.remove_elem","text":"remove_elem ( dst : int , * , force = False , ** other_paras )","title":"remove_elem()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.save_preprecess","text":"save_preprecess ( MemoryData : BinDict [ int , FHT ] = None )","title":"save_preprecess()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.unlink_rely_on","text":"unlink_rely_on ( cluster : FilesCluster ) Unlinks the cluster from relying.","title":"unlink_rely_on()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.unlink_rely_on--args","text":"cluster (FilesCluster): The cluster to be unlinked from relying.","title":"Args:"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.write","text":"write ( dst : int , value : VDMT , * , force = False , ** other_paras ) -> None","title":"write()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.write_data","text":"write_data ( dst : int , value : VDMT , * , force = False , ** other_paras ) -> None","title":"write_data()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesCluster.write_elem","text":"write_elem ( dst : int , value : VDMT , * , force = False , ** other_paras )","title":"write_elem()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle","text":"Bases: _RegisterInstance ['FilesHandle'] , Generic [ FCT , VDMT ]","title":"FilesHandle"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle--note","text":"A class representing a file handle for input/output operations. Its instance manages some attributes of one file or a group of files, depending on the value of the multi_files attribute. Its instance is immutable object, once created, it can't be changed. Parameters: cluster ( FCT ) \u2013 The cluster to which the file handle belongs. data_path ( str , default: '' ) \u2013 The top path to the file or directory. sub_dir ( str ) \u2013 The subdirectory of the file or directory. Defaults to \"\". corename ( str ) \u2013 The corename of the file or directory. Defaults to \"\". suffix ( str ) \u2013 The suffix of the file or directory. Defaults to \"\". _appendnames_obj \u2013 The _AppendNames object. Defaults to None. _prefix_obj \u2013 The _Prefix object. Defaults to None. read_func ( Optional [ Callable ] , default: None ) \u2013 The function to be used for reading the file. Defaults to None. write_func ( Optional [ Callable ] , default: None ) \u2013 The function to be used for writing the file. Defaults to None. cache_proxy \u2013 The cache proxy to be used. Defaults to None. Examples: >>> cluster = FilesCluster ( \"./top\" ) >>> fh = FilesHandle ( cluster , sub_dir = \"sub\" , corename = \"core\" , suffix = \".txt\" ) >>> fh . get_path () \"./top/sub/core.txt\" >>> fh2 = FilesHandle ( cluster , sub_dir = \"sub\" , corename = \"core\" , suffix = \".txt\" , prefix = \"prefix\" , appendnames = [ \"append1\" , \"append2\" ], prefix_joiner = \"-\" , appendnames_joiner = \"_\" ) >>> fh2 . get_path () ['./top/sub/prefix-core_append1.txt', './top/sub/prefix-core_append2.txt']","title":"Note"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.DEFAULT_APPENDNAMES","text":"DEFAULT_APPENDNAMES = None can be overrided by subclass","title":"DEFAULT_APPENDNAMES"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.DEFAULT_APPENDNAMES_JOINER","text":"DEFAULT_APPENDNAMES_JOINER = None can be overrided by subclass","title":"DEFAULT_APPENDNAMES_JOINER"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.DEFAULT_FILE_TYPE","text":"DEFAULT_FILE_TYPE = { '.json' : [ JsonIO . load_json , JsonIO . dump_json , dict ], '.npy' : [ partial ( np . load , allow_pickle = True ), partial ( np . save , allow_pickle = True ), None ], '.npz' : [ partial ( np . load , allow_pickle = True ), partial ( np . savez , allow_pickle = True ), None ], '.pkl' : [ deserialize_object , serialize_object , None ], '.txt' : [ read_file_as_str , write_str_to_file , None ], '.png' : [ cv2 . imread , cv2 . imwrite , None ], '.jpg' : [ cv2 . imread , cv2 . imwrite , None ], '.jpeg' : [ cv2 . imread , cv2 . imwrite , None ], '.bmp' : [ cv2 . imread , cv2 . imwrite , None ], '.tif' : [ cv2 . imread , cv2 . imwrite , None ]} some default file type and their read/write functions","title":"DEFAULT_FILE_TYPE"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.DEFAULT_PREFIX","text":"DEFAULT_PREFIX = None can be overrided by subclass","title":"DEFAULT_PREFIX"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.DEFAULT_PREFIX_JOINER","text":"DEFAULT_PREFIX_JOINER = None can be overrided by subclass","title":"DEFAULT_PREFIX_JOINER"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.DEFAULT_READ_FUNC","text":"DEFAULT_READ_FUNC = None can be overrided by subclass","title":"DEFAULT_READ_FUNC"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.DEFAULT_SUFFIX","text":"DEFAULT_SUFFIX = None can be overrided by subclass","title":"DEFAULT_SUFFIX"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.DEFAULT_VALUE_INIT_FUNC","text":"DEFAULT_VALUE_INIT_FUNC = None can be overrided by subclass","title":"DEFAULT_VALUE_INIT_FUNC"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.DEFAULT_VALUE_TYPE","text":"DEFAULT_VALUE_TYPE = None can be overrided by subclass","title":"DEFAULT_VALUE_TYPE"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.DEFAULT_WRITE_FUNC","text":"DEFAULT_WRITE_FUNC = None can be overrided by subclass","title":"DEFAULT_WRITE_FUNC"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.GET_INSTANCE_STRATEGY","text":"GET_INSTANCE_STRATEGY = 0 control the strategy of get_instance 0: return the inited instance, 1: return the original instance and cover the inited instance 2: return the original instance and not register it","title":"GET_INSTANCE_STRATEGY"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.INDENTITY_PARA_NAMES","text":"INDENTITY_PARA_NAMES = [ 'sub_dir' , 'corename' , 'suffix' , 'prefix' , 'appendnames' , 'prefix_joiner' , 'appendnames_joiner' , 'data_path' ]","title":"INDENTITY_PARA_NAMES"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.KW_FUNC_BIND_ARGS","text":"KW_FUNC_BIND_ARGS = 'func_bind_args'","title":"KW_FUNC_BIND_ARGS"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.KW_FUNC_BIND_KWARGS","text":"KW_FUNC_BIND_KWARGS = 'func_bind_kwargs'","title":"KW_FUNC_BIND_KWARGS"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.KW_FUNC_MODULE","text":"KW_FUNC_MODULE = 'func_module'","title":"KW_FUNC_MODULE"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.KW_FUNC_NAME","text":"KW_FUNC_NAME = 'func_name'","title":"KW_FUNC_NAME"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.KW_INIT_WITHOUT_CACHE","text":"KW_INIT_WITHOUT_CACHE = 'INIT_WITHOUT_CACHE'","title":"KW_INIT_WITHOUT_CACHE"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.KW_appendnames","text":"KW_appendnames = 'appendnames'","title":"KW_appendnames"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.KW_cache","text":"KW_cache = 'cache'","title":"KW_cache"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.KW_corename","text":"KW_corename = 'corename'","title":"KW_corename"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.KW_data_path","text":"KW_data_path = 'data_path'","title":"KW_data_path"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.KW_prefix","text":"KW_prefix = 'prefix'","title":"KW_prefix"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.KW_read_func","text":"KW_read_func = 'read_func'","title":"KW_read_func"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.KW_sub_dir","text":"KW_sub_dir = 'sub_dir'","title":"KW_sub_dir"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.KW_suffix","text":"KW_suffix = 'suffix'","title":"KW_suffix"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.KW_write_func","text":"KW_write_func = 'write_func'","title":"KW_write_func"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.LOAD_CACHE_ON_INIT","text":"LOAD_CACHE_ON_INIT = False can be overrided by subclass if True, load cache from disk when init","title":"LOAD_CACHE_ON_INIT"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.all_file_exist","text":"all_file_exist","title":"all_file_exist"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.all_file_not_exist","text":"all_file_not_exist","title":"all_file_not_exist"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.any_file_exist","text":"any_file_exist","title":"any_file_exist"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.any_file_not_exist","text":"any_file_not_exist","title":"any_file_not_exist"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.appendnames","text":"appendnames : Union [ list [ str ], str ]","title":"appendnames"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.appendnames_with_joiner","text":"appendnames_with_joiner : Union [ list [ str ], str ]","title":"appendnames_with_joiner"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.cache","text":"cache : Union [ VDMT , None ] Returns the cache of the instance. If is_readonly == True , returns a shallow copy of the cache object. Else, returns the cache object. Returns: Union[VDMT, None]: The cache object or a shallow copy of the cache object. \u2013","title":"cache"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.cache_proxy","text":"cache_proxy : CacheProxy [ VDMT ] = CacheProxy [ VDMT ]( cache , value_type , default_value_type )","title":"cache_proxy"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.empty","text":"empty Check if the object does not have cache and all files do not exist. Returns: bool ( True if the object is empty, False otherwise. ) \u2013","title":"empty"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.file_exist_status","text":"file_exist_status : list [ bool ] Returns: list[bool]: \u2013 A list of boolean values indicating whether each file exists.","title":"file_exist_status"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.full_directory","text":"full_directory the full directory of the file(s)","title":"full_directory"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.has_cache","text":"has_cache","title":"has_cache"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.is_closed","text":"is_closed self.cluster.closed","title":"is_closed"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.is_readonly","text":"is_readonly self.cluster.readonly","title":"is_readonly"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.multi_files","text":"multi_files","title":"multi_files"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.multi_files--code","text":"self.cluster.MULTI_FILES","title":"Code"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.multi_files--note","text":"multi_files is decided by self.cluster . It indicates how to deal with the appendnames. see :link: FilesCluster.MULTI_FILES , :link: FilesHandle.get_name , :link: FilesHandle.get_path","title":"Note"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.overwrite_forbidden","text":"overwrite_forbidden self.cluster.readonly","title":"overwrite_forbidden"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.prefix","text":"prefix : str","title":"prefix"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.prefix_with_joiner","text":"prefix_with_joiner : str","title":"prefix_with_joiner"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.read_func","text":"read_func = read_func","title":"read_func"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.synced","text":"synced Whether the cache is synced with the file(s).","title":"synced"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.synced--note","text":"Each FilesHandle instance corresponds to one (or more) files. When performing IO operations, you can directly perform IO operations on the files, or you can modify the cache of the FilesHandle instance in memory. See :link: IO_CTRL_STRATEGY for details. When only files are written, or only cache is modified, the data in file(s) and cache are asynchronous, and synced is False. To make synced be True , there are the following 3 methods: Call cache_to_file or file_to_cache of the FilesCluster instance (hereinafter referred to as cluster ) to which the FilesHandle instance belongs to manually synchronize data. Inherit `FilesCluster` and `FilesCluster._write` (assumed the subclasses to be named `NewFC`, `NewFC._write`), and rewrite the `W_SYNC` parameter of `NewFC._write` to True. This will modify the IO operation logic. When NewFC.write is called, `file(s)` and `cache` are written/modified synchronously. But please pay special attention: Frequent IO operations will consume a lot of resources, especially when the file is large. Therefore, when a large amount of data needs to be written, it is still recommended to modify `cache` first and then call `cache_to_file`. (Not recommended) When writing data, call set_io_ctrl_strategy of `cluster`.","title":"Note"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.valid","text":"valid self.cluster is not None","title":"valid"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.value_type","text":"value_type : type [ VDMT ]","title":"value_type"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.write_func","text":"write_func = write_func","title":"write_func"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.__eq__","text":"__eq__ ( o : object ) -> bool compare the identity_string of two FilesHandle objects","title":"__eq__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.__hash__","text":"__hash__ () hash(self.identity_string())","title":"__hash__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.__init__","text":"__init__ ( cluster : FCT , sub_dir : str , corename : str , suffix : str , * , prefix : Optional [ str ] = None , appendnames : Union [ str , list [ str ]] = None , prefix_joiner : Optional [ str ] = None , appendnames_joiner : Optional [ str ] = None , data_path : str = '' , read_func : Optional [ Callable ] = None , write_func : Optional [ Callable ] = None , cache = None , value_type : Optional [ type [ VDMT ]] = None ) -> None Initialize the IOAbstract class. Parameters: cluster ( FCT ) \u2013 The cluster object. sub_dir ( str ) \u2013 The sub-directory. corename ( str ) \u2013 The core name. suffix ( str ) \u2013 The suffix. prefix ( Optional [ str ] , default: None ) \u2013 The prefix. Defaults to None. appendnames ( Union [ str , list [ str ]] , default: None ) \u2013 The append names. Defaults to None. prefix_joiner ( Optional [ str ] , default: None ) \u2013 The prefix joiner. Defaults to None. appendnames_joiner ( Optional [ str ] , default: None ) \u2013 The append names joiner. Defaults to None. data_path ( str , default: '' ) \u2013 The data path. Defaults to \"\". read_func ( Optional [ Callable ] , default: None ) \u2013 The read function. Defaults to None. write_func ( Optional [ Callable ] , default: None ) \u2013 The write function. Defaults to None. cache \u2013 The cache. Defaults to None. value_type ( Optional [ type [ VDMT ]] , default: None ) \u2013 The value type. Defaults to None. Returns: None \u2013","title":"__init__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.__init_subclass__","text":"__init_subclass__ ( ** kwargs )","title":"__init_subclass__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.__repr__","text":"__repr__ () -> str","title":"__repr__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.__setattr__","text":"__setattr__ ( name , value )","title":"__setattr__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle._default_parse_file_name","text":"_default_parse_file_name ( file_name : str , prefix_joiner : str , appendnames_joiner : str , _extract_corename_func : Optional [ Callable ] = None ) Parses the given file name and extracts corename see :link: _parse_one_path_to_paras , :link: _parse_path_to_name Parameters: file_name ( str ) \u2013 The file name to be parsed. prefix_joiner ( str ) \u2013 The character or string used to join the prefix with the rest of the file name. appendnames_joiner ( str ) \u2013 The character or string used to join the core name with the append name. _extract_corename_func ( Optional [ Callable ] , default: None ) \u2013 Optional function to extract the core name from the file name. Used for custom parsing. Returns: tuple ( A tuple containing the following components: ) \u2013 sub_dir (str): The sub-directory of the file. corename (str): The core name of the file. suffix (str): The file suffix. prefix (str): The prefix of the file name. appendname (str): The append name of the file. _prefix_joiner: The prefix joiner used. _appendnames_joiner: The append names joiner used. Examples: >>> FilesHandle . _default_parse_file_name ( \"sub_dir/pre_corename-append.txt\" , \"_\" , \"-\" ) >>> ( 'sub_dir' , 'corename' , '.txt' , 'pre' , 'append' , '_' , '-' )","title":"_default_parse_file_name()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle._parse_one_path_to_paras","text":"_parse_one_path_to_paras ( cluster : FilesCluster , path : str , prefix_joiner : str , appendnames_joiner : str ) Parses a single path to extract various parameters. see :link: _parse_path_to_name and :link: _default_parse_file_name for more details. Parameters: cluster ( FilesCluster ) \u2013 The FilesCluster object. path ( str ) \u2013 The path to be parsed. prefix_joiner ( str ) \u2013 The prefix joiner. appendnames_joiner ( str ) \u2013 The append names joiner. Returns: tuple ( ) \u2013 A tuple containing the following parameters: - sub_dir (str): The sub directory. - corename (str): The core name. - suffix (str): The suffix. - prefix (str): The prefix. - appendname (str): The append name. - prefix_joiner: The prefix joiner. - appendnames_joiner: The append names joiner.","title":"_parse_one_path_to_paras()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle._parse_path_to_name","text":"_parse_path_to_name ( cluster : FilesCluster , path : T_MUITLSTR ) -> T_MUITLSTR Parses the given path or list of paths to extract the filename(s) relative to the data_path of the cluster. see :link: _parse_one_path_to_paras see :link: _parse_one_path_to_paras and :link: _default_parse_file_name , Parameters: cluster ( FilesCluster ) \u2013 The FilesCluster object. path ( T_MUITLSTR ) \u2013 The path(s) to be parsed. Returns: T_MUITLSTR ( ) \u2013 The filename(s) relative to the data_path of the cluster. Raises: AssertionError: \u2013 If the path is not a subpath of the data_path. AssertionError: \u2013 If the path is not a string or a list of strings.","title":"_parse_path_to_name()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle._set_synced","text":"_set_synced ( synced : bool = True ) Set the synchronization status of the cache. Parameters: synced ( bool , default: True ) \u2013","title":"_set_synced()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle._set_synced--note","text":"DO NOT call this function directly, use cache_to_file or file_to_cache instead. Returns: None","title":"Note"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle._unsafe_get_cache","text":"_unsafe_get_cache () -> Union [ VDMT , None ] Get cache without any check NOT recommended, use with caution","title":"_unsafe_get_cache()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.add_appendname","text":"add_appendname ( appendname )","title":"add_appendname()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.as_dict","text":"as_dict () convert the FilesHandle to a dict Returns: dict \u2013","title":"as_dict()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.clear_notfound","text":"clear_notfound () clear those files which are not found","title":"clear_notfound()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.create_new_and_cover","text":"create_new_and_cover () Creates a new instance of the class by setting the GET_INSTANCE_STRATEGY to 1 . GET_INSTANCE_STRATEGY will automatically be reset to 0 after a new instance is created. the new instance will cover the old instance with the same identity_string. Returns: cls ( ) \u2013 The modified class with the GET_INSTANCE_STRATEGY attribute set to 1 . Examples: >>> path = \"./sub/core.txt\" >>> cluster = FilesCluster ( \"./top\" ) >>> fh = FilesHandle . from_path ( cluster , path ) # OK >>> fh2 = FilesHandle . from_path ( cluster , path ) # OK, fh and fh2 are the same instance >>> fh3 = FilesHandle . create_new_and_cover () . from_path ( cluster , path ) # OK, fh3 is a new instance, and it is registered and covers the old instance. >>> FilesHandle . has_instance ( fh3 ) True >>> FilesHandle . has_instance ( fh ) False","title":"create_new_and_cover()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.create_not_exist_fileshandle","text":"create_not_exist_fileshandle ( cluster : FCT ) Create a file handle for a non-existent file. Parameters: cluster ( FCT ) \u2013 The cluster object. Returns: FilesHandle \u2013 An instance of the class for the non-existent file.","title":"create_not_exist_fileshandle()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.create_temp","text":"create_temp () Creates a temporary instance of the class. This method sets the GET_INSTANCE_STRATEGY attribute of the class to 2 and returns the modified class. GET_INSTANCE_STRATEGY will automatically be reset to 0 after a new instance is created. the new instance will not be registered. Returns: cls ( ) \u2013 The modified class with the GET_INSTANCE_STRATEGY attribute set to 2 . Examples: >>> path = \"./sub/core.txt\" >>> cluster = FilesCluster ( \"./top\" ) >>> fh = FilesHandle . from_path ( cluster , path ) # OK >>> fh2 = FilesHandle . from_path ( cluster , path ) # OK, fh and fh2 are the same instance >>> fh3 = FilesHandle . create_temp () . from_path ( cluster , path ) # OK, fh3 is a new instance, and it is not registered.","title":"create_temp()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.erase_cache","text":"erase_cache () Erase the cache.","title":"erase_cache()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.erase_cache--note","text":"If self.is_readonly == True or self.is_closed == True , the cache will not be erased.","title":"Note"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.export_func","text":"export_func ( func : Union [ Callable , None ]) Export a function for serialization. If the function is unpickleable, it returns a dictionary containing","title":"export_func()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.export_func--args","text":"func (Callable or None): The function to be exported. Returns: Union[dict, Callable, None]: \u2013 If the function is unpickleable, it returns a dictionary containing information about the function. Otherwise, it returns the function itself.","title":"Args"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.from_dict","text":"from_dict ( cluster : FCT , dict_ : dict ) create a FilesHandle from a dict Returns: FilesHandle \u2013","title":"from_dict()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.from_fileshandle","text":"from_fileshandle ( cluster : FCT , file_handle : FilesHandle , * , sub_dir : Optional [ str ] = None , corename : Optional [ str ] = None , suffix : Optional [ str ] = None , prefix : Optional [ str ] = None , appendnames : Union [ str , list [ str ]] = None , prefix_joiner : Optional [ str ] = None , appendnames_joiner : Optional [ str ] = None , read_func : Optional [ Callable ] = None , write_func : Optional [ Callable ] = None , cache = None , value_type : Optional [ type ] = None ) Create an instance of the class from another fileshandle object. Parameters: cluster ( FCT ) \u2013 The cluster object. file_handle ( FilesHandle ) \u2013 The file handle object. sub_dir ( str , default: None ) \u2013 The sub-directory path. Defaults to None. corename ( str , default: None ) \u2013 The core name. Defaults to None. suffix ( str , default: None ) \u2013 The file suffix. Defaults to None. prefix ( str , default: None ) \u2013 The file prefix. Defaults to None. appendnames ( str or list [ str ] , default: None ) \u2013 The append names. Defaults to None. prefix_joiner ( str , default: None ) \u2013 The joiner for prefix and append names. Defaults to None. appendnames_joiner ( str , default: None ) \u2013 The joiner for append names. Defaults to None. read_func ( Callable , default: None ) \u2013 The read function. Defaults to None. write_func ( Callable , default: None ) \u2013 The write function. Defaults to None. cache ( optional , default: None ) \u2013 The cache object. Defaults to None. value_type ( type , default: None ) \u2013 The value type. Defaults to None. Returns: FilesHandle \u2013 An instance of the class.","title":"from_fileshandle()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.from_name","text":"from_name ( cluster : FCT , filename : Union [ str , list [ str ]], * , prefix_joiner : Optional [ str ] = None , appendnames_joiner : Optional [ str ] = None , read_func : Optional [ Callable ] = None , write_func : Optional [ Callable ] = None , cache = None , value_type : Optional [ type ] = None , _extract_corename_func : Optional [ Callable [[ str ], tuple [ str , str , str , str , str ]]] = None ) Create an instance of the class using the given file name. Parameters: cluster ( FCT ) \u2013 The FilesCluster object. filename ( Union [ str , List [ str ]] ) \u2013 The name of the file, can be a string or a list of strings. prefix_joiner ( Optional [ str ] , default: None ) \u2013 The joiner between prefix and corename. appendnames_joiner ( Optional [ str ] , default: None ) \u2013 The joiner between appendnames. read_func ( Optional [ Callable ] , default: None ) \u2013 The function to read the file. write_func ( Optional [ Callable ] , default: None ) \u2013 The function to write the file. cache ( any , default: None ) \u2013 The cache object. value_type ( Optional [ type ] , default: None ) \u2013 The type of the cache object. _extract_corename_func ( Optional [ Callable [[ str ], tuple [ str , str , str , str , str ]]] , default: None ) \u2013 The function to extract the corename, the function should return a tuple: (sub_dir, corename, suffix, prefix, appendname, _prefix_joiner, _appendnames_joiner) Returns: FilesHandle \u2013 An instance of the class. Raises: AssertionError \u2013 If the filename is not a string or a list of strings. If the sub_dir, corename, suffix, prefix, or appendname are not the same for all filenames in the list. Examples: >>> instance = FilesHandle . from_name ( cluster , \"filename.txt\" ) >>> instance = FilesHandle . from_name ( cluster , [ \"file_1.txt\" , \"file_2.txt\" ], appendnames_joiner = \"_\" )","title":"from_name()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.from_path","text":"from_path ( cluster : FCT , path : Union [ str , list [ str ]], * , prefix_joiner : Optional [ str ] = None , appendnames_joiner : Optional [ str ] = None , read_func : Optional [ Callable ] = None , write_func : Optional [ Callable ] = None , cache : Optional = None , value_type : Optional [ type ] = None , _extract_corename_func : Optional [ Callable [[ str ], tuple [ str , str , str , str , str ]]] = None ) -> Any Create a fileshandle object from a file path or a list of file paths. Parameters: cluster ( FCT ) \u2013 The cluster object. path ( Union [ str , list [ str ]] ) \u2013 The file path or a list of file paths. prefix_joiner ( Optional [ str ] , default: None ) \u2013 The prefix joiner. Defaults to None. appendnames_joiner ( Optional [ str ] , default: None ) \u2013 The append names joiner. Defaults to None. read_func ( Optional [ Callable ] , default: None ) \u2013 The read function. Defaults to None. write_func ( Optional [ Callable ] , default: None ) \u2013 The write function. Defaults to None. cache ( Optional , default: None ) \u2013 The cache object. Defaults to None. value_type ( Optional [ type ] , default: None ) \u2013 The value type. Defaults to None. _extract_corename_func ( Optional [ Callable [[ str ], tuple [ str , str , str , str , str ]]] , default: None ) \u2013 The extract core name function. Defaults to None. Returns: Any ( The fileshandle object. ) \u2013","title":"from_path()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.gen_identity_name","text":"gen_identity_name ()","title":"gen_identity_name()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.gen_identity_string","text":"gen_identity_string ()","title":"gen_identity_string()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.get_default_file_type","text":"get_default_file_type ( file : str ) Get the default file type for a given file. If the file type is not found in the DEFAULT_FILE_TYPE dictionary, None is returned. Parameters: file ( str ) \u2013 The file name or path. Returns: tuple ( ) \u2013 A tuple containing the read function, write function, and value type associated with the file type. If the file type is not found in the DEFAULT_FILE_TYPE dictionary, None is returned for all three values.","title":"get_default_file_type()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.get_dir","text":"get_dir () the full directory of the file(s)","title":"get_dir()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.get_instance","text":"get_instance ( identity_string , orig_obj : FilesHandle ) Get an instance of the class based on the specified identity string and original object.","title":"get_instance()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.get_instance--note","text":"the strategy is controled by GET_INSTANCE_STRATEGY 0: return the inited instance, 1: return the original instance and cover the inited instance 2: return the original instance and not register it Parameters: identity_string \u2013 The identity string. orig_obj ( FilesHandle ) \u2013 The original object. Returns: FilesHandle ( ) \u2013 The instance of the class. Raises: ValueError: \u2013 If GET_INSTANCE_STRATEGY is not 0, 1, or 2.","title":"Note"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.get_key","text":"get_key () Get its key in the self.cluster.MemoryData","title":"get_key()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.get_name","text":"get_name ( get_list : bool = False ) -> Union [ list [ str ], str ] Returns the name of the file(s). Parameters: get_list ( bool , default: False ) \u2013 If True, returns a list of names. Defaults to False. If multi_files is True, returns a list of names regardless of the value of get_list .","title":"get_name()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.get_name--returns","text":"Union[list[str], str]: The name(s) of the file(s).","title":"Returns:"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.get_path","text":"get_path ( get_list = False ) -> Union [ list [ str ], str ] Returns the path of the file(s) associated with the object. Parameters: get_list \u2013 If True, returns a list of paths. Defaults to False. If multi_files is True, returns a list of paths regardless of the value of get_list . Returns: Union[list[str], str]: \u2013 The path(s) of the file(s).","title":"get_path()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.has_not_inited","text":"has_not_inited ()","title":"has_not_inited()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.immutable_attr_same_as","text":"immutable_attr_same_as ( object : FilesHandle ) -> bool Check if the immutable attributes of the current object are the same as another FilesHandle object.","title":"immutable_attr_same_as()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.immutable_attr_same_as--immutable-attributes-include","text":"data_path sub_dir corename suffix prefix appendnames read_func write_func value_type Parameters: object ( FilesHandle ) \u2013 The FilesHandle object to compare with. Returns: bool ( ) \u2013 True if the immutable attributes are the same, False otherwise.","title":"Immutable attributes include"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.import_func","text":"import_func ( import_obj ) Import and return a function based on the given import object. Parameters: import_obj \u2013 The import object, which can be a dictionary or a callable. Returns: The imported function. \u2013 Raises: ValueError: \u2013 If the import object is not a dictionary or a callable. It suggests installing the module if the module name is provided in the import object.","title":"import_func()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.init_additional_hook","text":"init_additional_hook ()","title":"init_additional_hook()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.init_identity","text":"init_identity ( cluster : FCT , sub_dir : str , corename : str , suffix : str , * , prefix : Optional [ str ] = None , appendnames : Optional [ Union [ str , list [ str ]]] = None , prefix_joiner : Optional [ str ] = None , appendnames_joiner : Optional [ str ] = None , data_path = '' , read_func : Optional [ Callable ] = None , write_func : Optional [ Callable ] = None , cache = None , value_type : Optional [ type ] = None ) principle: the parameter of identity can not be changed once it has been inited","title":"init_identity()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.init_input_hook","text":"init_input_hook ( * , sub_dir , corename , suffix , prefix , appendnames , prefix_joiner , appendnames_joiner , data_path , read_func , write_func , cache , value_type ) Initializes the input hook with the specified parameters. This method can be overridden by subclasses to customize the input hook.","title":"init_input_hook()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.init_input_hook--args","text":"sub_dir (str): The sub-directory where the data is located. corename (str): The core name of the data file. suffix (str): The suffix of the data file. prefix (str): The prefix of the data file. appendnames (List[str]): The list of names to append to the data file. prefix_joiner (str): The joiner used to concatenate the prefix and appendnames. appendnames_joiner (str): The joiner used to concatenate the appendnames. data_path (str): The top dir to the data file. read_func (callable): The function used to read the data file. write_func (callable): The function used to write the data file. cache (bool): Flag indicating whether to cache the data. value_type (type): The type of the data values. Returns: Tuple[str, str, str, str, List[str], str, str, str, callable, callable, bool, type]: The initialized input hook parameters. \u2013","title":"Args"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.read","text":"read () -> Union [ VDMT , list [ VDMT ], None ] Reads data from the specified path using the read function. If self.read_func is None , returns None . Returns: Union[VDMT, list[VDMT], None]: \u2013 The read data, or None if the path does not exist.","title":"read()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.register","text":"register ( identity_string , obj : FilesHandle )","title":"register()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.remove_appendname","text":"remove_appendname ( appendname )","title":"remove_appendname()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.set_cache","text":"set_cache ( cache ) Set the cache for the IOAbstract object. Parameters: cache \u2013","title":"set_cache()"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.set_cache--note","text":"If is_readonly == True or is_closed == True , the cache will not be set. Returns: None \u2013","title":"Note"},{"location":"md/data/IOAbstract/#data.IOAbstract.FilesHandle.set_inited","text":"set_inited ()","title":"set_inited()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta","text":"Bases: ABC , Generic [ FCT , VDMT , FHT ] This class represents the abstract base class for input/output (IO) operations. Pre-process/post-process input and output, format conversion, and perform IO operations. Need to be used in combination with FilesCluster.io_decorator Attributes: READ (bool): Flag indicating if the IO operation is a read operation. PATH_EXISTS_REQUIRED (bool): Flag indicating if the existence of paths is required. LOG_TYPE: The log type for IO operations. WARNING_INFO (str): Information about the warning. W_SYNC (bool): Flag indicating if the write operation should be synchronous. OPER_ELEM (bool): Flag indicating if the operation is performed on individual elements. Methods: init (self, files_cluster: FCT): Initializes the IOMeta object. _set_ctrl_flag(self, ctrl_strategy=IO_CTRL_STRATEGY.CACHE_IDPNDT, io_raw=False): Sets the control flags for IO operations. _clear_ctrl_flag(self): Clears the control flags for IO operations. enter (self): Enters the control mode. exit (self, exc_type, exc_value, traceback): Exits the control mode. _set_synced_flag(self, src_handle: FilesHandle, dst_handle: FilesHandle, synced=False): Sets the synced flag for file handles. key_type(self): Returns the key type of the files cluster. multi_files(self): Returns whether the files cluster contains multiple files. cache_priority(self): Returns the cache priority. strict_priority_mode(self): Returns the strict priority mode. write_synchronous(self): Returns whether the write operation is synchronous. io_raw(self): Returns whether the IO operation is raw. _FCMemoryData(self): Returns the memory data of the files cluster. get_FilesHandle(self, src, dst, value, other_paras): Gets the file handles for the IO operation. _query_fileshandle(self, data_i: int): Queries the file handle for the given data index. get_file_core_func(self, src_file_handle: FHT, dst_file_handle: FHT, value): Gets the core function for the file handles. progress_FilesHandle(self, src_file_handle: FHT, dst_file_handle: FHT, postprocessed_value, other_paras): Progresses the file handles after the IO operation. io_cache(self, src_file_handle: FHT, dst_file_handle: FHT, value=None): Performs the IO operation with caching. cvt_to_core_paras(self, src_file_handle: FHT, dst_file_handle: FHT, value): Converts the parameters for the core function. preprogress_value(self, value, other_paras): Preprocesses the value before the IO operation. postprogress_value(self, value, other_paras): Postprocesses the value after the IO operation. format_value(self, value: Optional[VDMT]): Formats the value before the IO operation. inv_format_value(self, formatted_value): Inversely formats the value after the IO operation. core_func_hook(self, core_args): Hook function for the core function. operate_elem(self, src, dst, value, other_paras): Performs the operation on individual elements. gather_mutil_results(self, results: list): Gathers multiple results. split_value_as_mutil(self, core_values): Splits the value into multiple core values. assert_path_exists(self, path): Asserts that the path exists. io_file(self, src_file_handle, dst_file_handle, value: Optional[VDMT] = None): Performs the IO operation on a file. Methods (abstract): get_FilesHandle(self, src, dst, value, **other_paras): Gets the file handles for the IO operation. io_cache cvt_to_core_paras Methods recommended to be overridden: get_file_core_func: Gets the core function of the file handles. preprogress_value: Preprocesses the value before the I operation. postprogress_value: Postprocesses the value after the O operation. format_value: Formats the value before the I operation. inv_format_value: Inversely formats the value after the O operation. core_func_hook: Hook function for the core function. Methods need to be overridden if OPER_ELEM : operate_elem Methods need to be overridden if the files cluster contains multiple files: gather_mutil_results split_value_as_mutil","title":"IOMeta"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.LOG_TYPE","text":"LOG_TYPE = IOStatusManager . LOG_READ","title":"LOG_TYPE"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.OPER_ELEM","text":"OPER_ELEM = False","title":"OPER_ELEM"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.PATH_EXISTS_REQUIRED","text":"PATH_EXISTS_REQUIRED = True","title":"PATH_EXISTS_REQUIRED"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.READ","text":"READ = True","title":"READ"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.WARNING_INFO","text":"WARNING_INFO = 'no description'","title":"WARNING_INFO"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.W_SYNC","text":"W_SYNC = False","title":"W_SYNC"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta._FCMemoryData","text":"_FCMemoryData : BinDict [ int , FHT ]","title":"_FCMemoryData"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.cache_priority","text":"cache_priority","title":"cache_priority"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.core_func","text":"core_func : Optional [ Callable ] = None","title":"core_func"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.core_func_binded_paras","text":"core_func_binded_paras = {}","title":"core_func_binded_paras"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.ctrl_mode","text":"ctrl_mode = False","title":"ctrl_mode"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.files_cluster","text":"files_cluster : FCT = files_cluster","title":"files_cluster"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.io_raw","text":"io_raw","title":"io_raw"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.key_type","text":"key_type","title":"key_type"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.multi_files","text":"multi_files","title":"multi_files"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.save_memory_after_writing","text":"save_memory_after_writing = False","title":"save_memory_after_writing"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.strict_priority_mode","text":"strict_priority_mode","title":"strict_priority_mode"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.write_synchronous","text":"write_synchronous","title":"write_synchronous"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.__call__","text":"__call__ ( * , src = None , dst = None , value = None , ** other_paras ) -> Any Make the IOMeta object callable. Args: src: The source parameter. dst: The destination parameter. value: The value parameter. **other_paras: Additional parameters. Returns: The result of the call. Raises: None.","title":"__call__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.__enter__","text":"__enter__ ()","title":"__enter__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.__exit__","text":"__exit__ ( exc_type , exc_value , traceback )","title":"__exit__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.__init__","text":"__init__ ( files_cluster : FCT ) -> None","title":"__init__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta._clear_ctrl_flag","text":"_clear_ctrl_flag ()","title":"_clear_ctrl_flag()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta._query_fileshandle","text":"_query_fileshandle ( data_i : int ) -> FHT","title":"_query_fileshandle()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta._set_ctrl_flag","text":"_set_ctrl_flag ( ctrl_strategy = IO_CTRL_STRATEGY . CACHE_IDPNDT , io_raw = False )","title":"_set_ctrl_flag()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta._set_synced_flag","text":"_set_synced_flag ( src_handle : FilesHandle , dst_handle : FilesHandle , synced = False )","title":"_set_synced_flag()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.assert_path_exists","text":"assert_path_exists ( path : T_MUITLSTR ) Asserts that the given path or paths exist. Args: path (str or list[str]): The path or paths to check. Raises: IOMetaPriorityError: If the path or any of the paths do not exist and PATH_EXISTS_REQUIRED is True.","title":"assert_path_exists()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.check_dst","text":"check_dst ( dst ) Check if the given destination is of the correct type. Parameters: dst (self.key_type): The destination to be checked. Returns: bool: True if the destination is of the correct type, False otherwise.","title":"check_dst()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.check_src","text":"check_src ( src ) Check if the given source is valid. Parameters: src (self.key_type): The source to be checked. Returns: bool: True if the source is valid, False otherwise.","title":"check_src()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.check_value","text":"check_value ( value : Any )","title":"check_value()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.core_func_hook","text":"core_func_hook ( * core_args ) This is a hook function that can be overridden in subclasses. It is called after the core function is executed. Parameters: *core_args: Variable number of arguments passed to the core_func. Returns: None","title":"core_func_hook()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.cvt_to_core_paras","text":"cvt_to_core_paras ( src_file_handle : FHT , dst_file_handle : FHT , value ) -> tuple Convert the given source file handle and destination file handle to core parameters. Args: src_file_handle (FilesHandle): The source file handle. dst_file_handle (FilesHandle): The destination file handle. value: The value to be converted. Returns: path: The path or paths that the core function will use. *core_values: The core values that the core function will use.","title":"cvt_to_core_paras()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.execute_core_func","text":"execute_core_func ( core_func , * core_args , ** other_paras ) Executes the core function with the given arguments and parameters. Args: core_func: The core function to be executed. core_args: The arguments to be passed to the core function. other_paras: Other parameters to be passed to the core function. Returns: The result of the core function execution.","title":"execute_core_func()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.format_value","text":"format_value ( value : Optional [ VDMT ]) -> Any Formats the value before the O operation. the difference between format_value and preprogress_value is that: preprogress_value has additional parameters: **other_paras , which allows more flexible preprocessing, such as resize an image. format_value need no additional parameters. It is used to format the value to the type that the core function can handle, such as converting a numpy array to a tensor. Args: value (Optional[VDMT]): The value to be formatted. Returns: Any: The formatted value.","title":"format_value()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.gather_mutil_results","text":"gather_mutil_results ( results : list )","title":"gather_mutil_results()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.gather_mutil_results--warning-must-be-overridden-if-selfmulti_files-true","text":"Gathers multiple results into a single result. Args: results (list): A list of results to be gathered. Raises: NotImplementedError: This method is not implemented and should be overridden in a subclass.","title":"WARNING: must be overridden if self.multi_files = True"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.get_FilesHandle","text":"get_FilesHandle ( src , dst , value , ** other_paras ) -> tuple [ FHT , FHT ]","title":"get_FilesHandle()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.get_file_core_func","text":"get_file_core_func ( src_file_handle : FHT , dst_file_handle : FHT , value ) -> Callable This method returns the file core function. Args: src_file_handle (FilesHandle): The source file handle. dst_file_handle (FilesHandle): The destination file handle. value: The value. Returns: Callable: The file core function.","title":"get_file_core_func()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.inv_format_value","text":"inv_format_value ( formatted_value ) -> VDMT Inversely formats the value after the I operation. the difference between inv_format_value and postprogress_value see :link: format_value Args: formatted_value: The formatted value to be inverse formatted. Returns: The inverse formatted value.","title":"inv_format_value()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.io","text":"io ( src_handle : FilesHandle , dst_handle : FilesHandle , preprocessed_value ) Perform input/output operations on the given source and destination handles. IO operations have a sequential order. Try to perform IO on the file and cache (or cache first and then the file) in sequence. the first operation is called 'priority', and the second operation is called 'secondary'. If 'priority' fails, continue to execute 'secondary', otherwise the result will be returned directly. you may control the strategy of the IO operations by setting the control flags by _set_ctrl_flag method: * self.cache_priority : If True, the cache will be used first. * self.strict_priority_mode : If True, an exception will be raised if the priority fails. * self.write_synchronous : If True, both file and cache will be written synchronously. * self.io_raw : If True, the IO operation will be raw.","title":"io()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.io--tip","text":"You should pay attention to the definition of :link: cache_priority , :link: self.strict_priority_mode and :link: self.write_synchronous , see their docs for details","title":"Tip"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.io--args","text":"src_handle (FilesHandle): The source handle for the input operation. dst_handle (FilesHandle): The destination handle for the output operation. preprocessed_value: The preprocessed value to be used in the operations.","title":"Args:"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.io--returns","text":"The result of the input/output operations.","title":"Returns:"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.io_cache","text":"io_cache ( src_file_handle : FHT , dst_file_handle : FHT , value = None ) -> Any","title":"io_cache()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.io_file","text":"io_file ( src_file_handle : FilesHandle , dst_file_handle : FilesHandle , value : Optional [ VDMT ] = None ) -> Any Perform file input/output operation. Args: src_file_handle: The source file handle. dst_file_handle: The destination file handle. value: Optional value to be used in the operation. Returns: The result of the file operation. Raises: IOMetaPriorityError: If core_func is None.","title":"io_file()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.is_overwriting","text":"is_overwriting ( dst : int )","title":"is_overwriting()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.operate_elem","text":"operate_elem ( src , dst , value , ** other_paras )","title":"operate_elem()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.operate_elem--warning-must-be-overridden-if-oper_elem-true","text":"Perform an operation on the elements. Args: src: The source element. dst: The destination element. value: The value to be used in the operation. **other_paras: Additional parameters for the operation. Raises: NotImplementedError: If the method is not implemented.","title":"WARNING: must be overridden if OPER_ELEM = True"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.postprogress_value","text":"postprogress_value ( value , ** other_paras ) -> Any Postprocesses the value after the I operation.","title":"postprogress_value()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.postprogress_value--see-also","text":"the difference between inv_format_value and postprogress_value see :link: format_value Args: value: The value to be processed. **other_paras: Additional parameters. Returns: The processed value.","title":"See Also"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.preprogress_value","text":"preprogress_value ( value , ** other_paras ) -> Any Preprocesses the value before the O operation.","title":"preprogress_value()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.preprogress_value--see-also","text":"the difference between format_value and preprogress_value see :link: format_value Args: value: The value to be preprocessed. **other_paras: Additional parameters for preprocessing. Returns: The preprocessed value.","title":"See Also"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.progress_FilesHandle","text":"progress_FilesHandle ( src_file_handle : FHT , dst_file_handle : FHT , postprocessed_value , ** other_paras ) -> tuple [ FHT ]","title":"progress_FilesHandle()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.split_value_as_mutil","text":"split_value_as_mutil ( * core_values )","title":"split_value_as_mutil()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMeta.split_value_as_mutil--warning-must-be-overridden-if-selfmulti_files-true","text":"Splits the given core values into multiple values. Args: *core_values: The core values to be split. Raises: NotImplementedError: This method is not implemented and should be overridden in a subclass.","title":"WARNING: must be overridden if self.multi_files = True"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMetaParameterError","text":"Bases: ValueError","title":"IOMetaParameterError"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOMetaPriorityError","text":"Bases: ValueError","title":"IOMetaPriorityError"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager","text":"Manages the status and operations related to input/output (IO) operations. Attributes: WRITING_MARK ( str ) \u2013 The file extension used to mark a writing operation. LOG_READ ( int ) \u2013 Log type for read operation. LOG_ADD ( int ) \u2013 Log type for add operation. LOG_REMOVE ( int ) \u2013 Log type for remove operation. LOG_CHANGE ( int ) \u2013 Log type for change operation. LOG_MOVE ( int ) \u2013 Log type for move operation. LOG_OPERATION ( int ) \u2013 Log type for generic operation. LOG_KN ( list ) \u2013 List of valid log types. _DEBUG ( bool ) \u2013 Flag to enable debug mode. __closed ( bool ) \u2013 Flag indicating if the IOStatusManager object is closed. __readonly ( bool ) \u2013 Flag indicating if the IOStatusManager object is read-only. __wait_writing ( bool ) \u2013 Flag indicating if the IOStatusManager object is waiting for writing or a writing process is executing. __overwrite_allowed ( bool ) \u2013 Flag indicating if overwriting is allowed. __writer ( _Writer ) \u2013 The writer object for performing IO operations.","title":"IOStatusManager"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.LOG_ADD","text":"LOG_ADD = 1","title":"LOG_ADD"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.LOG_CHANGE","text":"LOG_CHANGE = 3","title":"LOG_CHANGE"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.LOG_KN","text":"LOG_KN = [ LOG_READ , LOG_ADD , LOG_REMOVE , LOG_CHANGE , LOG_MOVE , LOG_OPERATION ]","title":"LOG_KN"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.LOG_MOVE","text":"LOG_MOVE = 4","title":"LOG_MOVE"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.LOG_OPERATION","text":"LOG_OPERATION = 5","title":"LOG_OPERATION"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.LOG_READ","text":"LOG_READ = 0","title":"LOG_READ"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.LOG_REMOVE","text":"LOG_REMOVE = 2","title":"LOG_REMOVE"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.WRITING_MARK","text":"WRITING_MARK = '.writing'","title":"WRITING_MARK"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager._DEBUG","text":"_DEBUG = False","title":"_DEBUG"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.closed","text":"closed Flag indicating if the IOStatusManager object is closed. Any IO operation will not be executed if the IOStatusManager object is closed.","title":"closed"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.is_writing","text":"is_writing Flag indicating if the IOStatusManager object is writing. See :link: wait_writing , :link: stop_writing , :link: start_writing","title":"is_writing"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.opened","text":"opened Flag indicating if the IOStatusManager object is opened.","title":"opened"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.overwrite_allowed","text":"overwrite_allowed Flag indicating if the IOStatusManager object allows overwriting. See :link: set_overwrite_allowed , :link: set_overwrite_forbidden , :link: overwrite_forbidden","title":"overwrite_allowed"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.overwrite_forbidden","text":"overwrite_forbidden Flag indicating if the IOStatusManager object doesn't allow overwriting. See :link: set_overwrite_allowed , :link: set_overwrite_forbidden , :link: overwrite_allowed","title":"overwrite_forbidden"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.readonly","text":"readonly Flag indicating if the IOStatusManager object is read-only. Any write operation will not be executed if the IOStatusManager object is read-only.","title":"readonly"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.wait_writing","text":"wait_writing Flag indicating if the IOStatusManager object is wait_writing. see :link: is_writing , :link: stop_writing , :link: start_writing Examples: >>> object = FilesCluster ( ... ) >>> object . wait_writing # True True >>> with object . get_writer () as writer : >>> object . wait_writing # False >>> ... >>> object . wait_writing # True True","title":"wait_writing"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.writable","text":"writable Flag indicating if the IOStatusManager object is writable.","title":"writable"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager._Empty_Writer","text":"Bases: _Writer A subclass of _Writer that represents an empty writer. Attributes: None \u2013 Methods: Name Description None","title":"_Empty_Writer"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager._Empty_Writer.__enter__","text":"__enter__ () A subclass of _Writer that represents an empty writer. Attributes: None \u2013 Functions: Name Description None","title":"__enter__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager._Empty_Writer.__exit__","text":"__exit__ ( exc_type , exc_value , traceback ) Called when exiting the empty writer context. Parameters: exc_type ( type ) \u2013 The type of the exception raised, if any. exc_value ( Exception ) \u2013 The exception raised, if any. traceback ( traceback ) \u2013 The traceback object associated with the exception. Returns: None \u2013 Raises: Exception \u2013 If an exception was raised.","title":"__exit__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager._IOContext","text":"Context manager for managing the IO context. Attributes: DEFAULT_INPUT_OPEN ( bool ) \u2013 Default value for input open flag. DEFAULT_INPUT_WRITABLE ( bool ) \u2013 Default value for input writable flag. DEFAULT_INPUT_OVERWRITE_ALLOWED ( bool ) \u2013 Default value for input overwrite allowed flag. Methods: Name Description __init__ : Initializes the _IOContext object. reset_input : Resets the input flags to their default values. set_input : Sets the input flags to the specified values. enter_hook : Hook method called when entering the context. exit_hook : Hook method called when exiting the context.","title":"_IOContext"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager._IOContext.DEFAULT_INPUT_OPEN","text":"DEFAULT_INPUT_OPEN = False","title":"DEFAULT_INPUT_OPEN"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager._IOContext.DEFAULT_INPUT_OVERWRITE_ALLOWED","text":"DEFAULT_INPUT_OVERWRITE_ALLOWED = False","title":"DEFAULT_INPUT_OVERWRITE_ALLOWED"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager._IOContext.DEFAULT_INPUT_WRITABLE","text":"DEFAULT_INPUT_WRITABLE = False","title":"DEFAULT_INPUT_WRITABLE"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager._IOContext.obj","text":"obj : IOStatusManager = obj","title":"obj"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager._IOContext.orig_closed","text":"orig_closed : bool = True","title":"orig_closed"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager._IOContext.orig_overwrite_allowed","text":"orig_overwrite_allowed : bool = False","title":"orig_overwrite_allowed"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager._IOContext.orig_readonly","text":"orig_readonly : bool = True","title":"orig_readonly"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager._IOContext.working","text":"working = False","title":"working"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager._IOContext.__enter__","text":"__enter__ () Called when entering the context. Returns: _IOContext \u2013 The _IOContext object.","title":"__enter__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager._IOContext.__exit__","text":"__exit__ ( exc_type , exc_value , traceback ) Called when exiting the context. Parameters: exc_type ( type ) \u2013 The type of exception that caused the context to be exited, if any. exc_value ( Exception ) \u2013 The instance of the exception that caused the context to be exited, if any. traceback ( traceback ) \u2013 A traceback object encapsulating the call stack at the point where the exception was raised, if any. Returns: bool \u2013 Indicates successful exit from the context.","title":"__exit__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager._IOContext.__init__","text":"__init__ ( obj : IOStatusManager ) -> None Initializes the _IOContext object. Parameters: obj ( IOStatusManager ) \u2013 The IOStatusManager object associated with this context.","title":"__init__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager._IOContext.enter_hook","text":"enter_hook () -> None Hook method called when entering the context.","title":"enter_hook()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager._IOContext.exit_hook","text":"exit_hook () Hook method called when exiting the context. Returns: bool \u2013 Indicates successful exit from the context.","title":"exit_hook()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager._IOContext.reset_input","text":"reset_input () -> None Resets the input flags to their default values.","title":"reset_input()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager._IOContext.set_input","text":"set_input ( open = False , writable = False , overwrite_allowed = False ) Sets the input flags to the specified values. Parameters: open ( bool , default: False ) \u2013 Flag indicating if the input should be opened. writable ( bool , default: False ) \u2013 Flag indicating if the input should be writable. overwrite_allowed ( bool , default: False ) \u2013 Flag indicating if overwriting is allowed. Returns: _IOContext \u2013 The _IOContext object.","title":"set_input()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager._Writer","text":"Bases: _IOContext Context manager for managing the writer context. Attributes: DEFAULT_INPUT_OPEN ( bool ) \u2013 Default value for input open flag. DEFAULT_INPUT_WRITABLE ( bool ) \u2013 Default value for input writable flag. Methods: Name Description allow_overwriting Sets the input overwrite allowed flag.","title":"_Writer"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager._Writer.DEFAULT_INPUT_OPEN","text":"DEFAULT_INPUT_OPEN = True","title":"DEFAULT_INPUT_OPEN"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager._Writer.DEFAULT_INPUT_WRITABLE","text":"DEFAULT_INPUT_WRITABLE = True","title":"DEFAULT_INPUT_WRITABLE"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager._Writer.allow_overwriting","text":"allow_overwriting ( overwrite_allowed = True ) Sets the input overwrite allowed flag. Parameters: overwrite_allowed ( bool , default: True ) \u2013 Flag indicating if overwriting is allowed. Default is True. Returns: _Writer \u2013 The _Writer object.","title":"allow_overwriting()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.__init__","text":"__init__ () -> None Initializes the IOStatusManager object. Parameters: None \u2013 Returns: None \u2013","title":"__init__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.close","text":"close ( closed : bool = True ) Close the IOAbstract object. all the io operation will not be executed. Parameters: closed ( bool , default: True ) \u2013 Flag indicating whether the object should be closed. Defaults to True.","title":"close()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.close_hook","text":"close_hook () called when close is called * recommend to override this method","title":"close_hook()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.get_writer","text":"get_writer ( valid = True ) Returns a writer object for performing IO operations. Parameters: valid ( bool , default: True ) \u2013 Flag indicating if the writer is valid. If valid is True, return self.__writer, else return self._Empty_Writer(self). An _Empty_Writer will do nothing when entering and exiting the context. Default is True. Returns: _Writer or _Empty_Writer \u2013 The writer object. Examples: >>> with self . get_writer () as writer : >>> for ... : >>> ... >>> with self . get_writer () . allow_overwriting () as writer : >>> ...","title":"get_writer()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.get_writing_mark_file","text":"get_writing_mark_file () -> str Returns the file path for the writing mark file. Parameters: None \u2013 Returns: str \u2013 The file path for the writing mark file.","title":"get_writing_mark_file()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.identity_string","text":"identity_string () -> str Returns a string representation of the IOStatusManager object. Parameters: None \u2013 Returns: str \u2013 The string representation of the IOStatusManager object.","title":"identity_string()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.is_closed","text":"is_closed ( with_warning = False ) Method to check if the cluster is closed.","title":"is_closed()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.is_readonly","text":"is_readonly ( with_warning = False ) Method to check if the cluster is read-only.","title":"is_readonly()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.load_from_mark_file","text":"load_from_mark_file () Loads data from the writing mark file. Parameters: None \u2013 Returns: result (list): \u2013 The loaded data from the writing mark file. Raises: AssertionError: If the format of the mark file is incorrect. \u2013","title":"load_from_mark_file()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.log_to_mark_file","text":"log_to_mark_file ( log_type , src = None , dst = None , value = None ) Log the specified information to a mark file. Parameters: log_type \u2013 The type of log, should be one of [LOG_READ, LOG_ADD, LOG_REMOVE, LOG_CHANGE, LOG_MOVE, LOG_OPERATION] src \u2013 The source of the log. Defaults to None. dst \u2013 The destination of the log. Defaults to None. value \u2013 The value associated with the log. Defaults to None.","title":"log_to_mark_file()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.mark_exist","text":"mark_exist () Checks if the writing mark file exists. Parameters: None \u2013 Returns: bool \u2013 True if the writing mark file exists, False otherwise.","title":"mark_exist()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.open","text":"open ( opened : bool = True ) Open the IOAbstract object. Parameters: opened ( bool , default: True ) \u2013 If True, opens the object. If False, closes the object. Defaults to True. Returns: None \u2013","title":"open()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.open_hook","text":"open_hook () called when open is called * recommend to override this method","title":"open_hook()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.readonly_hook","text":"readonly_hook () called when set_readonly is called * recommend to override this method","title":"readonly_hook()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.remove_mark","text":"remove_mark () Removes the writing mark file. Parameters: None \u2013 Returns: None \u2013","title":"remove_mark()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.reopen","text":"reopen () Reopens the file or resource for reading or writing. This method first closes the file or resource using the close() method, and then opens it again using the open() method.","title":"reopen()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.set_overwrite_allowed","text":"set_overwrite_allowed ( overwrite_allowed : bool = True ) set the overwrite_allowed flag for the object. See :link: set_overwrite_forbidden , :link: overwrite_allowed , :link: overwrite_forbidden Examples: >>> object = FilesCluster ( ... ) >>> object . set_overwrite_forbidden () # set overwrite_forbidden >>> with object . get_writer () as writer : >>> object . write ( 0 , ... ) # OK >>> object . write ( 0 , ... ) # raise ClusterIONotExecutedWarning >>> object . set_overwrite_allowed () # set overwrite_allowed >>> with object . get_writer () as writer : >>> object . write ( 0 , ... ) # OK >>> object . write ( 0 , ... ) # OK","title":"set_overwrite_allowed()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.set_overwrite_allowed_hook","text":"set_overwrite_allowed_hook () called when set_overwrite_allowed is called * recommend to override this method","title":"set_overwrite_allowed_hook()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.set_overwrite_forbidden","text":"set_overwrite_forbidden ( overwrite_forbidden : bool = True ) set the overwrite_forbidden flag for the object. See :link: set_overwrite_allowed , :link: overwrite_allowed , :link: overwrite_forbidden","title":"set_overwrite_forbidden()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.set_overwrite_forbidden_hook","text":"set_overwrite_forbidden_hook () called when set_overwrite_forbidden is called * recommend to override this method","title":"set_overwrite_forbidden_hook()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.set_readonly","text":"set_readonly ( readonly : bool = True ) Set the readonly flag for the object. Parameters: readonly ( bool , default: True ) \u2013 Whether the object should be set as readonly or not. Default is True. Examples: >>> object = FilesCluster ( ... ) >>> object . set_readonly () # set readonly >>> object . read ( 0 ) # OK >>> object . write ( 0 , ... ) # raise ClusterIONotExecutedWarning","title":"set_readonly()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.set_writable","text":"set_writable ( writable : bool = True ) Set the writable flag for the object. Parameters: writable ( bool , default: True ) \u2013 Whether the object should be set as writable or not. Default is True. Warns: NOT recommend to use this method. use `get_writer` instead. \u2013 Examples: NOT recommend: >>> object = FilesCluster ( ... ) >>> object . set_writable () # set writable >>> object . read ( 0 ) # OK >>> object . write ( 0 , ... ) # OK >>> object . set_readonly () # set readonly recommend: >>> object = FilesCluster ( ... ) >>> with object . get_writer () as writer : >>> object . read ( 0 ) # OK >>> object . write ( 0 , ... ) # OK","title":"set_writable()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.start_writing","text":"start_writing ( start_writing : bool = True , overwrite_allowed : bool = False ) start_writing_hook wiil be called see :link: stop_writing , :link: wait_writing , :link: is_writing","title":"start_writing()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.start_writing_hook","text":"start_writing_hook () called when start_writing is called * recommend to override this method","title":"start_writing_hook()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.stop_writing","text":"stop_writing ( stop_writing : bool = True ) Set the stop_writing flag for the object. stop_writing_hook wiil be called see :link: start_writing , :link: wait_writing , :link: is_writing Examples: NOT recommend: >>> object = FilesCluster ( ... ) >>> object . set_writable () # set writable >>> object . start_writing () # set start_writing >>> object . read ( 0 ) # OK >>> object . write ( 0 , ... ) # OK >>> object . stop_writing () # set stop_writing >>> object . set_readonly () # set readonly recommend: >>> object = FilesCluster ( ... ) >>> with object . get_writer () as writer : >>> object . read ( 0 ) # OK >>> object . write ( 0 , ... ) # OK","title":"stop_writing()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.stop_writing_hook","text":"stop_writing_hook () called when stop_writing is called * recommend to override this method","title":"stop_writing_hook()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusManager.writable_hook","text":"writable_hook () called when set_writable is called * recommend to override this method","title":"writable_hook()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IOStatusWarning","text":"Bases: Warning","title":"IOStatusWarning"},{"location":"md/data/IOAbstract/#data.IOAbstract.IO_CTRL_STRATEGY","text":"Enum representing different IO control strategies.","title":"IO_CTRL_STRATEGY"},{"location":"md/data/IOAbstract/#data.IOAbstract.IO_CTRL_STRATEGY--note","text":"there are 3 control flags for DataMapping : cache_priority , strict_priority_mode , write_synchronous cache_priority IO operations have 2 destinations: cache and file(s). Cache is in memory, and file(s) is on disk. You can read from(write to) cache or file(s). They each have their own advantages under different conditions. When the file is large, such as an image or a video, it is recommended to read from(write to) the file(s) directly. Because reading from(writing to) the file(s) directly will not consume memory. cache_priority is recommended to be False in this case. When the file is small, such as a configuration file, it is recommended to read from(write to) the cache. Because reading from(writing to) the cache is faster than reading from(writing to) the file(s). Or if the file contains a large amounts of pieces of data, like a json/xml file, If the file is written to the disk when each piece of data is written, a lot of resources will be consumed. In this case, it is recommended to write to the cache first, and then write to the file(s) in batches. cache_priority is recommended to be True in this case. strict_priority_mode When strict_priority_mode is False . If the one set as priority fails to perform a read (or write) operation, it will try to perform a read (or write) operation on the other one. If failed again, it will raise an exception. When strict_priority_mode is True . When the priority fails, it will raise an exception without trying the other one. write_synchronous When write_synchronous is False . If the cache is modified, it will not be written to the file immediately. The same goes for files. When write_synchronous is True . If the cache is modified, it will be written to the file immediately. The same goes for files. Attributes: CACHE_PRIORITY \u2013 Set Cache as Priority FILE_PRIORITY \u2013 Set File as Priority STRICT_PRIORITY_MODE \u2013 Set strict_priority_mode NON_STRICT_PRIORITY_MODE \u2013 Clear strict_priority_mode WRITE_SYNCHRONOUS \u2013 Set write_synchronous WRITE_ASYNCHRONOUS \u2013 Clear write_synchronous Methods: Name Description get_ctrl_flag Get control flags based on the strategy. get_ctrl_strategy Get strategy based on control flags.","title":"Note"},{"location":"md/data/IOAbstract/#data.IOAbstract.IO_CTRL_STRATEGY.CACHE_IDPNDT","text":"CACHE_IDPNDT = 4 CACHE_PRIORITY, NON_STRICT_PRIORITY_MODE, WRITE_ASYNCHRONOUS","title":"CACHE_IDPNDT"},{"location":"md/data/IOAbstract/#data.IOAbstract.IO_CTRL_STRATEGY.CACHE_PRIORITY","text":"CACHE_PRIORITY = 4","title":"CACHE_PRIORITY"},{"location":"md/data/IOAbstract/#data.IOAbstract.IO_CTRL_STRATEGY.CACHE_STRICK_IDPNDT","text":"CACHE_STRICK_IDPNDT = 6 CACHE_PRIORITY, STRICT_PRIORITY_MODE, WRITE_ASYNCHRONOUS","title":"CACHE_STRICK_IDPNDT"},{"location":"md/data/IOAbstract/#data.IOAbstract.IO_CTRL_STRATEGY.CACHE_STRICK_SYNC","text":"CACHE_STRICK_SYNC = 7 CACHE_PRIORITY, STRICT_PRIORITY_MODE, WRITE_SYNCHRONOUS","title":"CACHE_STRICK_SYNC"},{"location":"md/data/IOAbstract/#data.IOAbstract.IO_CTRL_STRATEGY.CACHE_SYNC","text":"CACHE_SYNC = 5 CACHE_PRIORITY, NON_STRICT_PRIORITY_MODE, WRITE_SYNCHRONOUS","title":"CACHE_SYNC"},{"location":"md/data/IOAbstract/#data.IOAbstract.IO_CTRL_STRATEGY.FILE_IDPNDT","text":"FILE_IDPNDT = 0 FILE_PROIRITY, NON_STRICT_PRIORITY_MODE, WRITE_ASYNCHRONOUS","title":"FILE_IDPNDT"},{"location":"md/data/IOAbstract/#data.IOAbstract.IO_CTRL_STRATEGY.FILE_PROIRITY","text":"FILE_PROIRITY = 0","title":"FILE_PROIRITY"},{"location":"md/data/IOAbstract/#data.IOAbstract.IO_CTRL_STRATEGY.FILE_STRICK_IDPNDT","text":"FILE_STRICK_IDPNDT = 2 FILE_PROIRITY, STRICT_PRIORITY_MODE, WRITE_ASYNCHRONOUS","title":"FILE_STRICK_IDPNDT"},{"location":"md/data/IOAbstract/#data.IOAbstract.IO_CTRL_STRATEGY.FILE_STRICK_SYNC","text":"FILE_STRICK_SYNC = 3 FILE_PROIRITY, STRICT_PRIORITY_MODE, WRITE_SYNCHRONOUS","title":"FILE_STRICK_SYNC"},{"location":"md/data/IOAbstract/#data.IOAbstract.IO_CTRL_STRATEGY.FILE_SYNC","text":"FILE_SYNC = 1 FILE_PROIRITY, NON_STRICT_PRIORITY_MODE, WRITE_SYNCHRONOUS","title":"FILE_SYNC"},{"location":"md/data/IOAbstract/#data.IOAbstract.IO_CTRL_STRATEGY.NON_STRICT_PRIORITY_MODE","text":"NON_STRICT_PRIORITY_MODE = 0","title":"NON_STRICT_PRIORITY_MODE"},{"location":"md/data/IOAbstract/#data.IOAbstract.IO_CTRL_STRATEGY.STRICT_PRIORITY_MODE","text":"STRICT_PRIORITY_MODE = 2","title":"STRICT_PRIORITY_MODE"},{"location":"md/data/IOAbstract/#data.IOAbstract.IO_CTRL_STRATEGY.WRITE_ASYNCHRONOUS","text":"WRITE_ASYNCHRONOUS = 0","title":"WRITE_ASYNCHRONOUS"},{"location":"md/data/IOAbstract/#data.IOAbstract.IO_CTRL_STRATEGY.WRITE_SYNCHRONOUS","text":"WRITE_SYNCHRONOUS = 1","title":"WRITE_SYNCHRONOUS"},{"location":"md/data/IOAbstract/#data.IOAbstract.IO_CTRL_STRATEGY.get_ctrl_flag","text":"get_ctrl_flag ( strategy : int ) return cache_priority, strict_priority_mode, write_synchronous Examples: >>> IO_CTRL_STRATEGY . get_ctrl_flag ( IO_CTRL_STRATEGY . CACHE_IDPNDT ) (True, False, False) >>> IO_CTRL_STRATEGY . get_ctrl_flag ( IO_CTRL_STRATEGY . CACHE_PRIORITY | IO_CTRL_STRATEGY . STRICT_PRIORITY_MODE | IO_CTRL_STRATEGY . WRITE_SYNCHRONOUS ) (True, True, True)","title":"get_ctrl_flag()"},{"location":"md/data/IOAbstract/#data.IOAbstract.IO_CTRL_STRATEGY.get_ctrl_strategy","text":"get_ctrl_strategy ( cache_priority : bool , strict_priority_mode : bool , write_synchronous : bool ) Get the control strategy based on the given parameters. Parameters: cache_priority ( bool ) \u2013 The priority of cache. strict_priority_mode ( bool ) \u2013 The mode of strict priority. write_synchronous ( bool ) \u2013 The mode of write synchronization. Returns: int ( ) \u2013 The control strategy calculated based on the given parameters.","title":"get_ctrl_strategy()"},{"location":"md/data/IOAbstract/#data.IOAbstract.KeyNotFoundError","text":"Bases: KeyError","title":"KeyNotFoundError"},{"location":"md/data/IOAbstract/#data.IOAbstract.Node","text":"Bases: Generic [ NODE ] A class representing a node in a tree structure.","title":"Node"},{"location":"md/data/IOAbstract/#data.IOAbstract.Node.CHILD_TYPE","text":"CHILD_TYPE : Optional [ type [ Node ]] = None","title":"CHILD_TYPE"},{"location":"md/data/IOAbstract/#data.IOAbstract.Node.PARENT_TYPE","text":"PARENT_TYPE : Optional [ type [ Node ]] = None","title":"PARENT_TYPE"},{"location":"md/data/IOAbstract/#data.IOAbstract.Node._children","text":"_children : tuple [ NODE ] Get the children nodes of the current node.","title":"_children"},{"location":"md/data/IOAbstract/#data.IOAbstract.Node.follow_parent","text":"follow_parent = True","title":"follow_parent"},{"location":"md/data/IOAbstract/#data.IOAbstract.Node.linked_with_children","text":"linked_with_children = True","title":"linked_with_children"},{"location":"md/data/IOAbstract/#data.IOAbstract.Node.parent","text":"parent : Union [ NODE , None ] Get the parent node of the current node.","title":"parent"},{"location":"md/data/IOAbstract/#data.IOAbstract.Node.__init__","text":"__init__ () -> None Initializes a Node object.","title":"__init__()"},{"location":"md/data/IOAbstract/#data.IOAbstract.Node._add_child","text":"_add_child ( child_node : Node ) Add a child node to the current node.","title":"_add_child()"},{"location":"md/data/IOAbstract/#data.IOAbstract.Node._move_node","text":"_move_node ( new_parent : NODE ) Move the current node to a new parent node.","title":"_move_node()"},{"location":"md/data/IOAbstract/#data.IOAbstract.Node._remove_child","text":"_remove_child ( child_node : Node ) Parameters: child_node ( Node ) \u2013 Remove a child node from the current node.","title":"_remove_child()"},{"location":"md/data/IOAbstract/#data.IOAbstract.Node._set_parent","text":"_set_parent ( parent ) Set the parent node of the current node.","title":"_set_parent()"},{"location":"md/data/IOAbstract/#data.IOAbstract.Node.downward_postorder_propagate","text":"downward_postorder_propagate ( func ) Decorator to propagate a function call to the leaves of the node in a downward postorder traversal.","title":"downward_postorder_propagate()"},{"location":"md/data/IOAbstract/#data.IOAbstract.Node.downward_preorder_propagate","text":"downward_preorder_propagate ( func ) Decorator to propagate a function call to the leaves of the node in a downward preorder traversal.","title":"downward_preorder_propagate()"},{"location":"md/data/IOAbstract/#data.IOAbstract.Node.upward_postorder_propagate","text":"upward_postorder_propagate ( func ) Decorator to propagate a function call to the ancestors of the node in a backtracking postorder traversal.","title":"upward_postorder_propagate()"},{"location":"md/data/IOAbstract/#data.IOAbstract.Node.upward_preorder_propagate","text":"upward_preorder_propagate ( func ) Decorator to propagate a function call to the ancestors of the node in a backtracking preorder traversal.","title":"upward_preorder_propagate()"},{"location":"md/data/IOAbstract/#data.IOAbstract._AppendNames","text":"Bases: dict [ str , Union [ List [ str ], str ]] A class representing a configuration for appending names with options for a list of appendable names and a joiner. Parameters: appendnames ( list of str , default: None ) \u2013 The list of names to be appended, by default an empty list. joiner ( str , default: '_' ) \u2013 The joiner to be used, by default \"_\". Attributes: KW_APPENDNAMES ( str ) \u2013 Keyword for the appendnames attribute. KW_JOINER ( str ) \u2013 Keyword for the joiner attribute. Methods: Name Description joiner : str Getter for the joiner attribute. appendnames : list of str Getter for the appendnames attribute. get_with_joiner Returns a list of names with the joiner added. extend Extends the appendnames attribute with new names. add_appendname Adds an appendname to the list if it does not already exist. remove_appendname Removes an appendname from the list if it exists. conditional_return Conditionally returns either the list of names or the first name based on the value of mutil_file. __repr__ Returns a string representation of the AppendNames object. from_dict Creates an AppendNames object from a dictionary. as_dict Returns the AppendNames object as a dictionary. Examples: >>> append_names_instance = _AppendNames ( appendnames = [ \"name1\" , \"name2\" ], joiner = \"-\" ) >>> print ( append_names_instance . get_with_joiner ()) [\"-name1\", \"-name2\"] >>> append_names_dict = { 'appendnames' : [ 'item1' , 'item2' ], 'joiner' : '+' } >>> new_append_names_instance = _AppendNames . from_dict ( append_names_dict ) >>> print ( new_append_names_instance ) \"AppendNames({'appendnames': ['item1', 'item2'], 'joiner': '+'})\"","title":"_AppendNames"},{"location":"md/data/IOAbstract/#data.IOAbstract._AppendNames.KW_APPENDNAMES","text":"KW_APPENDNAMES = 'appendnames'","title":"KW_APPENDNAMES"},{"location":"md/data/IOAbstract/#data.IOAbstract._AppendNames.KW_JOINER","text":"KW_JOINER = 'joiner'","title":"KW_JOINER"},{"location":"md/data/IOAbstract/#data.IOAbstract._AppendNames.appendnames","text":"appendnames : List [ str ] Getter for the appendnames attribute. Returns: list of str \u2013 The current list of appendable names.","title":"appendnames"},{"location":"md/data/IOAbstract/#data.IOAbstract._AppendNames.joiner","text":"joiner : str Getter for the joiner attribute. Returns: str \u2013 The current joiner value.","title":"joiner"},{"location":"md/data/IOAbstract/#data.IOAbstract._AppendNames.__init__","text":"__init__ ( appendnames : List [ str ] = None , joiner : str = '_' ) -> None Initialize the AppendNames object. Parameters: appendnames ( list of str , default: None ) \u2013 The list of names to be appended, by default an empty list. joiner ( str , default: '_' ) \u2013 The joiner to be used, by default \"_\".","title":"__init__()"},{"location":"md/data/IOAbstract/#data.IOAbstract._AppendNames.__repr__","text":"__repr__ () -> str Returns a string representation of the AppendNames object. Returns: str \u2013 A string representation of the AppendNames object.","title":"__repr__()"},{"location":"md/data/IOAbstract/#data.IOAbstract._AppendNames.add_appendname","text":"add_appendname ( appendname : str ) -> bool Adds an appendname to the list if it does not already exist. Parameters: appendname ( str ) \u2013 The name to be added to the appendnames list. Returns: bool \u2013 True if the name was added, False if it already existed.","title":"add_appendname()"},{"location":"md/data/IOAbstract/#data.IOAbstract._AppendNames.as_dict","text":"as_dict () -> dict Returns the AppendNames object as a dictionary. Returns: dict \u2013 A dictionary representation of the AppendNames object.","title":"as_dict()"},{"location":"md/data/IOAbstract/#data.IOAbstract._AppendNames.conditional_return","text":"conditional_return ( mutil_file : bool , list_like : List [ str ]) -> Union [ str , List [ str ]] Conditionally returns either the list of names or the first name based on the value of mutil_file. Parameters: mutil_file ( bool ) \u2013 A boolean flag indicating whether to return the full list or just the first item. list_like ( list of str ) \u2013 The list of names. Returns: Union [ str , List [ str ]] \u2013 Either the full list or the first item based on the value of mutil_file.","title":"conditional_return()"},{"location":"md/data/IOAbstract/#data.IOAbstract._AppendNames.extend","text":"extend ( names : Union [ str , Iterable [ str ]]) -> None Extends the appendnames attribute with new names. Parameters: names ( str or iterable of str ) \u2013 The names to be added to the appendnames list.","title":"extend()"},{"location":"md/data/IOAbstract/#data.IOAbstract._AppendNames.from_dict","text":"from_dict ( dict_ : dict ) -> _AppendNames Creates an AppendNames object from a dictionary. Parameters: dict_ ( dict ) \u2013 The dictionary containing the appendnames and joiner values. Returns: _AppendNames \u2013 A new AppendNames object created from the provided dictionary.","title":"from_dict()"},{"location":"md/data/IOAbstract/#data.IOAbstract._AppendNames.get_with_joiner","text":"get_with_joiner () -> List [ str ] Returns a list of names with the joiner added. Returns: list of str \u2013 The result of concatenating the joiner with each name in the appendnames list.","title":"get_with_joiner()"},{"location":"md/data/IOAbstract/#data.IOAbstract._AppendNames.remove_appendname","text":"remove_appendname ( appendname : str ) -> bool Removes an appendname from the list if it exists. Parameters: appendname ( str ) \u2013 The name to be removed from the appendnames list. Returns: bool \u2013 True if the name was removed, False if it did not exist.","title":"remove_appendname()"},{"location":"md/data/IOAbstract/#data.IOAbstract._Prefix","text":"Bases: dict [ str , str ] A class representing a prefix configuration with options for prefix and joiner. Parameters: prefix ( str , default: '' ) \u2013 The prefix to be used, by default an empty string. joiner ( Any , default: '' ) \u2013 The joiner to be used, by default an empty string. Attributes: KW_PREFIX ( str ) \u2013 Keyword for the prefix attribute. KW_JOINER ( str ) \u2013 Keyword for the joiner attribute. Methods: Name Description prefix : str Getter and setter for the prefix attribute. joiner : Any Getter and setter for the joiner attribute. get_with_joiner Returns the concatenation of prefix and joiner. __repr__ Returns a string representation of the Prefix object. as_dict Returns the Prefix object as a dictionary. from_dict Creates a Prefix object from a dictionary. Examples: >>> prefix_instance = _Prefix ( prefix = \"abc\" , joiner = \"-\" ) >>> print ( prefix_instance . get_with_joiner ()) \"abc-\" >>> prefix_dict = { 'prefix' : 'xyz' , 'joiner' : '_' } >>> new_prefix_instance = _Prefix . from_dict ( prefix_dict ) >>> print ( new_prefix_instance ) \"Prefix(xyz, _)\"","title":"_Prefix"},{"location":"md/data/IOAbstract/#data.IOAbstract._Prefix.KW_JOINER","text":"KW_JOINER = 'joiner'","title":"KW_JOINER"},{"location":"md/data/IOAbstract/#data.IOAbstract._Prefix.KW_PREFIX","text":"KW_PREFIX = 'prefix'","title":"KW_PREFIX"},{"location":"md/data/IOAbstract/#data.IOAbstract._Prefix.joiner","text":"joiner : str Getter for the joiner attribute. Returns: str \u2013 The current joiner value.","title":"joiner"},{"location":"md/data/IOAbstract/#data.IOAbstract._Prefix.prefix","text":"prefix : str Getter for the prefix attribute. Returns: str \u2013 The current prefix value.","title":"prefix"},{"location":"md/data/IOAbstract/#data.IOAbstract._Prefix.__init__","text":"__init__ ( prefix : str = '' , joiner : str = '' ) -> None Initialize the Prefix object. Parameters: prefix ( str , default: '' ) \u2013 The prefix to be used, by default an empty string. joiner ( Any , default: '' ) \u2013 The joiner to be used, by default an empty string.","title":"__init__()"},{"location":"md/data/IOAbstract/#data.IOAbstract._Prefix.__repr__","text":"__repr__ () -> str Returns a string representation of the Prefix object. Returns: str \u2013 A string representation of the Prefix object.","title":"__repr__()"},{"location":"md/data/IOAbstract/#data.IOAbstract._Prefix.as_dict","text":"as_dict () -> dict Returns the Prefix object as a dictionary. Returns: dict \u2013 A dictionary representation of the Prefix object.","title":"as_dict()"},{"location":"md/data/IOAbstract/#data.IOAbstract._Prefix.from_dict","text":"from_dict ( dict_ : dict ) -> _Prefix Creates a Prefix object from a dictionary. Parameters: dict_ ( dict ) \u2013 The dictionary containing the prefix and joiner values. Returns: _Prefix \u2013 A new Prefix object created from the provided dictionary.","title":"from_dict()"},{"location":"md/data/IOAbstract/#data.IOAbstract._Prefix.get_with_joiner","text":"get_with_joiner () -> str Returns the concatenation of prefix and joiner. Returns: str \u2013 The result of concatenating prefix and joiner.","title":"get_with_joiner()"},{"location":"md/data/IOAbstract/#data.IOAbstract._RegisterInstance","text":"Bases: ABC , Generic [ RGSITEM ] A base class for registering instances with unique identities. Every instance of a subclass of _RegisterInstance will be registered in _RegisterInstance._registry with its identity_string. Attributes: _registry (dict[str, RGSITEM]) \u2013 A dictionary to store registered instances. INDENTITY_PARA_NAMES (list) \u2013 A list of parameter names that define the identity of an instance.","title":"_RegisterInstance"},{"location":"md/data/IOAbstract/#data.IOAbstract._RegisterInstance.INDENTITY_PARA_NAMES","text":"INDENTITY_PARA_NAMES = []","title":"INDENTITY_PARA_NAMES"},{"location":"md/data/IOAbstract/#data.IOAbstract._RegisterInstance._registry","text":"_registry : dict [ str , RGSITEM ] = {}","title":"_registry"},{"location":"md/data/IOAbstract/#data.IOAbstract._RegisterInstance.__new__","text":"__new__ ( * args , ** kwargs )","title":"__new__()"},{"location":"md/data/IOAbstract/#data.IOAbstract._RegisterInstance.__setattr__","text":"__setattr__ ( name : str , value ) -> Any","title":"__setattr__()"},{"location":"md/data/IOAbstract/#data.IOAbstract._RegisterInstance.gen_identity_name","text":"gen_identity_name () generate the identity_name of an instance","title":"gen_identity_name()"},{"location":"md/data/IOAbstract/#data.IOAbstract._RegisterInstance.gen_identity_string","text":"gen_identity_string () generate the identity_string of an instance","title":"gen_identity_string()"},{"location":"md/data/IOAbstract/#data.IOAbstract._RegisterInstance.get_instance","text":"get_instance ( identity_string , obj ) get an instance by identity_string. the strategy of getting is defined by the subclass","title":"get_instance()"},{"location":"md/data/IOAbstract/#data.IOAbstract._RegisterInstance.has_instance","text":"has_instance ( obj : _RegisterInstance ) if an instance has been registered Parameters: obj ( _RegisterInstance ) \u2013 the instance to be checked","title":"has_instance()"},{"location":"md/data/IOAbstract/#data.IOAbstract._RegisterInstance.identity_name","text":"identity_name ()","title":"identity_name()"},{"location":"md/data/IOAbstract/#data.IOAbstract._RegisterInstance.identity_name--note","text":"indentity_string() might be too long, so sometime we need a short name to represent it. If you are sure there will be no ambiguity, you can use identity_name() to distinguish different instances.","title":"Note"},{"location":"md/data/IOAbstract/#data.IOAbstract._RegisterInstance.identity_string","text":"identity_string ()","title":"identity_string()"},{"location":"md/data/IOAbstract/#data.IOAbstract._RegisterInstance.identity_string--note","text":"identity_string returns a string that can uniquely identify an instance","title":"Note"},{"location":"md/data/IOAbstract/#data.IOAbstract._RegisterInstance.init_identity","text":"init_identity ( * args , ** kwargs ) principle: the parameter of identity can not be changed once it has been inited","title":"init_identity()"},{"location":"md/data/IOAbstract/#data.IOAbstract._RegisterInstance.register","text":"register ( identity_string , obj ) register an instance with its identity_string. the strategy of registering is defined by the subclass","title":"register()"},{"location":"md/data/IOAbstract/#data.IOAbstract.get_func_name","text":"get_func_name ( obj , func ) Get the name of a function within an object. Parameters: obj ( object ) \u2013 The object containing the function. func ( function ) \u2013 The function to get the name of. Returns: str or None \u2013 The name of the function if found, None otherwise.","title":"get_func_name()"},{"location":"md/data/IOAbstract/#data.IOAbstract.get_function_args","text":"get_function_args ( function , * exclude : str ) Get the arguments of a function, excluding specified arguments. Parameters: function ( function ) \u2013 The function to get the arguments of. *exclude ( str , default: () ) \u2013 The arguments to exclude. Returns: rlt \u2013 The signature of the function, excluding specified arguments.","title":"get_function_args()"},{"location":"md/data/IOAbstract/#data.IOAbstract.get_with_priority","text":"get_with_priority ( * args : Optional [ T ]) -> T Returns the first non-None argument from the given arguments. Parameters: *args ( Optional [ T ] , default: () ) \u2013 The arguments to check for non-None values. Returns: T \u2013 The first non-None argument, or None if all arguments are None.","title":"get_with_priority()"},{"location":"md/data/IOAbstract/#data.IOAbstract.is_subpath","text":"is_subpath ( child_path , parent_path ) Check if a path is a subpath of another path. Parameters: child_path ( str ) \u2013 The path to check if it is a subpath. parent_path ( str ) \u2013 The parent path to compare against. Returns: bool \u2013 True if the child_path is a subpath of the parent_path, False otherwise.","title":"is_subpath()"},{"location":"md/data/IOAbstract/#data.IOAbstract.method_exit_hook_decorator","text":"method_exit_hook_decorator ( cls , func : Callable , exit_hook_func , enter_condition_func = None ) Decorator function that adds an exit hook to a method based on an enter condition. Parameters: cls ( class ) \u2013 The class to which the method belongs. func ( callable ) \u2013 The method to be decorated. exit_hook_func ( callable ) \u2013 The exit hook function to be called after the method execution. enter_condition_func ( callable , default: None ) \u2013 The enter condition function to determine if the method should be executed. Defaults to None. Returns: callable \u2013 The decorated method.","title":"method_exit_hook_decorator()"},{"location":"md/data/IOAbstract/#data.IOAbstract.parse_kw","text":"parse_kw ( ** kwargs ) -> list [ dict [ str , Any ]] Parses keyword arguments into a list of dictionaries. Parameters: **kwargs ( dict [ str , Any ] , default: {} ) \u2013 The keyword arguments to be parsed. Returns: list [ dict [ str , Any ]] \u2013 The parsed keyword arguments.","title":"parse_kw()"},{"location":"md/data/_mkdoctest/","text":"_mkdoctest A title: 1 title: 2 title: 3 1 2 title: 4 sub sub 1 2 func func ( a : int , b : B ) title Parameters: a ( int ) \u2013 12345 b ( `B` ) \u2013 An instance of :class: B . Returns: int \u2013 12345 Examples: >>> example_function ( 2 , 3 ) 5 B","title":"_mkdoctest"},{"location":"md/data/_mkdoctest/#_mkdoctest","text":"","title":"_mkdoctest"},{"location":"md/data/_mkdoctest/#data._mkdoctest.A","text":"","title":"A"},{"location":"md/data/_mkdoctest/#data._mkdoctest.A--title-1","text":"","title":"title: 1"},{"location":"md/data/_mkdoctest/#data._mkdoctest.A--title-2","text":"","title":"title: 2"},{"location":"md/data/_mkdoctest/#data._mkdoctest.A--title-3","text":"1 2","title":"title: 3"},{"location":"md/data/_mkdoctest/#data._mkdoctest.A--title-4","text":"","title":"title: 4"},{"location":"md/data/_mkdoctest/#data._mkdoctest.A--sub","text":"","title":"sub"},{"location":"md/data/_mkdoctest/#data._mkdoctest.A--sub_1","text":"1 2","title":"sub"},{"location":"md/data/_mkdoctest/#data._mkdoctest.A.func","text":"func ( a : int , b : B )","title":"func()"},{"location":"md/data/_mkdoctest/#data._mkdoctest.A.func--title","text":"Parameters: a ( int ) \u2013 12345 b ( `B` ) \u2013 An instance of :class: B . Returns: int \u2013 12345 Examples: >>> example_function ( 2 , 3 ) 5","title":"title"},{"location":"md/data/_mkdoctest/#data._mkdoctest.B","text":"","title":"B"},{"location":"md/data/dataCluster/","text":"dataCluster DF module-attribute DF = TypeVar ( 'DF' , bound = 'DictFile' ) DFC module-attribute DFC = TypeVar ( 'DFC' , bound = 'DisunifiedFileCluster' ) DFH module-attribute DFH = TypeVar ( 'DFH' , bound = 'DisunifiedFilesHandle' ) DLC module-attribute DLC = TypeVar ( 'DLC' , bound = 'DictLikeCluster' ) DLFH module-attribute DLFH = TypeVar ( 'DLFH' , bound = 'DictLikeHandle' ) FHT module-attribute FHT = TypeVar ( 'FHT' , bound = FilesHandle ) INDADC module-attribute INDADC = TypeVar ( 'INDADC' , bound = 'IntArrayDictAsTxtCluster' ) IntArrayDict module-attribute IntArrayDict = dict [ int , np . ndarray ] NDAC module-attribute NDAC = TypeVar ( 'NDAC' , bound = 'NdarrayAsTxtCluster' ) UFC module-attribute UFC = TypeVar ( 'UFC' , bound = 'UnifiedFileCluster' ) UFH module-attribute UFH = TypeVar ( 'UFH' , bound = 'UnifiedFilesHandle' ) VDLT module-attribute VDLT = TypeVar ( 'VDLT' , bound = dict [ int , Any ]) VDMT module-attribute VDMT = TypeVar ( 'VDMT' ) VINDADC module-attribute VINDADC = TypeVar ( 'VINDADC' , bound = dict [ int , np . ndarray ]) VNDAC module-attribute VNDAC = TypeVar ( 'VNDAC' , bound = np . ndarray ) DictFile Bases: DisunifiedFileCluster [ DFH , DFC , DSNT , dict ] , Generic [ DFH , DFC , DSNT ] cache_priority instance-attribute cache_priority = True write_synchronous instance-attribute write_synchronous = True __contains__ __contains__ ( i ) __getitem__ __getitem__ ( key : str ) __init__ __init__ ( dataset_node : Union [ str , DatasetNode ], mapping_name : str , * args , flag_name = '' , file_name = '.json' , ** kwargs ) -> None __iter__ __iter__ () __len__ __len__ () __setitem__ __setitem__ ( key : str , value ) _set_fileshandle _set_fileshandle ( data_i , fileshandle : DFH ) clear clear ( * arg , ** kw ) get get ( * arg , ** kw ) has_info has_info ( key ) pop pop ( * arg , ** kw ) popitem popitem ( * arg , ** kw ) read_info read_info ( key ) setdefault setdefault ( * arg , ** kw ) update update ( * arg , ** kw ) write_info write_info ( key , value ) DictLikeCluster Bases: DisunifiedFileCluster [ DLFH , DLC , DSNT , VDLT ] , Generic [ DLFH , DLC , DSNT , VDLT ] FILESHANDLE_TYPE class-attribute instance-attribute FILESHANDLE_TYPE : type [ FilesHandle ] = DictLikeHandle SAVE_AFTER_CLOSE class-attribute instance-attribute SAVE_AFTER_CLOSE = 1 SAVE_IMMIDIATELY class-attribute instance-attribute SAVE_IMMIDIATELY = 0 SAVE_STREAMLY class-attribute instance-attribute SAVE_STREAMLY = 2 _ELEM_BY_CACHE class-attribute instance-attribute _ELEM_BY_CACHE = True _IS_ELEM class-attribute instance-attribute _IS_ELEM = True caches property caches save_mode property writable save_mode stream_writer instance-attribute stream_writer = self . StreamlyWriter ( self ) write_streamly property write_streamly StreamlyWriter Bases: _Writer obj instance-attribute obj : DictLikeCluster = self . obj streams instance-attribute streams : list [ JsonIO . Stream ] = [] __init__ __init__ ( cluster : DictLikeCluster ) -> None enter_hook enter_hook () exit_hook exit_hook () write write ( data_i : int , elem_i , value ) _modify_elem_key Bases: _modify_key ['DictLikeCluster', dict [ int , Any ], DictLikeHandle ] OPER_ELEM class-attribute instance-attribute OPER_ELEM = True operate_elem operate_elem ( src , dst , values : dict , ** other_paras ) _read_elem Bases: _read ['DictLikeCluster', dict [ int , Any ], DictLikeHandle ] OPER_ELEM class-attribute instance-attribute OPER_ELEM = True operate_elem operate_elem ( src , dst , value , ** other_paras ) _remove_elem Bases: _remove ['DictLikeCluster', dict [ int , Any ], DictLikeHandle ] OPER_ELEM class-attribute instance-attribute OPER_ELEM = True operate_elem operate_elem ( src , dst , value , ** other_paras ) _write_elem Bases: _write ['DictLikeCluster', dict [ int , Any ], DictLikeHandle ] OPER_ELEM class-attribute instance-attribute OPER_ELEM = True operate_elem operate_elem ( src , dst , values : dict [ int , Any ], ** other_paras ) Test staticmethod Test () __init__ __init__ ( dataset_node : Union [ str , DatasetNode ], mapping_name : str , * args , flag_name = '' , ** kwargs ) -> None _set_fileshandle _set_fileshandle ( data_i , fh : DictLikeHandle ) add_default_file add_default_file ( filename ) elem_keys elem_keys () from_cluster classmethod from_cluster ( cluster : DLC , dataset_node : DSNT = None , mapping_name = None , * args , flag_name = '' , ** kwargs ) -> DLC init_io_metas init_io_metas () modify_elem_key modify_elem_key ( src : int , dst : int , * , force = False , ** other_paras ) -> dict read_elem read_elem ( src : Union [ int , Iterable [ int ]], * , force = False , ** other_paras ) -> Union [ dict , list [ dict ]] remove_elem remove_elem ( dst : int , remove_both = False , * , force = False , ** other_paras ) -> dict save_without_cache save_without_cache () to spare memory, save without cache sort_elem sort_elem () write_elem write_elem ( dst : int , value : Union [ Any , dict [ int , Any ]], * , force = False , ** other_paras ) -> dict DictLikeHandle Bases: DisunifiedFilesHandle [ DLC , dict [ int , Any ]] , Generic [ DLC ] LOAD_CACHE_ON_INIT class-attribute instance-attribute LOAD_CACHE_ON_INIT = True elem_num property elem_num has_cache property has_cache erase_cache erase_cache () get_cache_at get_cache_at ( elem_i ) -> Union [ Any , None ] init_input_hook init_input_hook ( * , value_type , ** kw ) pop_cache_at pop_cache_at ( elem_i ) -> Union [ Any , None ] set_cache_at set_cache_at ( elem_i , value ) -> bool sort_cache sort_cache () DisunifiedFileCluster Bases: FilesCluster [ DFH , DFC , DSNT , VDMT ] , Generic [ DFH , DFC , DSNT , VDMT ] FILESHANDLE_TYPE class-attribute instance-attribute FILESHANDLE_TYPE = DisunifiedFilesHandle _FCT class-attribute instance-attribute _FCT = TypeVar ( '_FCT' , bound = 'DisunifiedFileCluster' ) _FHT class-attribute instance-attribute _FHT = TypeVar ( '_FHT' , bound = DisunifiedFilesHandle ) _VDMT class-attribute instance-attribute _VDMT = TypeVar ( '_VDMT' ) all_files_exist property all_files_exist file_names property file_names _read Bases: _read [ _FCT , _VDMT , _FHT ] get_file_core_func get_file_core_func ( src_file_handle : DisunifiedFilesHandle , dst_file_handle : DisunifiedFilesHandle , value ) -> Callable [ ... , Any ] _write Bases: _write [ _FCT , _VDMT , _FHT ] get_file_core_func get_file_core_func ( src_file_handle : DisunifiedFilesHandle , dst_file_handle : DisunifiedFilesHandle , value ) -> Callable [ ... , Any ] Test staticmethod Test () __init__ __init__ ( dataset_node : Union [ str , DatasetNode ], mapping_name : str , * args , flag_name = '' , fileshandle_list = None , ** kwargs ) -> None add_default_file add_default_file ( filename ) create_fileshandle_in_iometa create_fileshandle_in_iometa ( src : int , dst : int , value : Any , ** other_paras ) cvt_key cvt_key ( key : Union [ int , str , DisunifiedFilesHandle ]) rebuild rebuild ( force = False ) DisunifiedFilesHandle Bases: FilesHandle [ DFC , VDMT ] , Generic [ DFC , VDMT ] file property writable file IntArrayDictAsTxtCluster Bases: NdarrayAsTxtCluster [ UFH , INDADC , DSNT , IntArrayDict ] , Generic [ UFH , INDADC , DSNT ] DEFAULT_VALUE_TYPE class-attribute instance-attribute DEFAULT_VALUE_TYPE = dict read_inv_format staticmethod read_inv_format ( array : np . ndarray ) array: np.ndarray [N, 5] write_format staticmethod write_format ( value : IntArrayDict ) -> Any NdarrayAsTxtCluster Bases: UnifiedFileCluster [ UFH , NDAC , DSNT , VNDAC ] , Generic [ UFH , NDAC , DSNT , VNDAC ] DEFAULT_READ_FUNC class-attribute instance-attribute DEFAULT_READ_FUNC = np . loadtxt DEFAULT_SUFFIX class-attribute instance-attribute DEFAULT_SUFFIX = '.txt' DEFAULT_VALUE_TYPE class-attribute instance-attribute DEFAULT_VALUE_TYPE = np . ndarray DEFAULT_WRITE_FUNC class-attribute instance-attribute DEFAULT_WRITE_FUNC = np . savetxt array_shape instance-attribute array_shape : tuple [ int ] = array_shape if array_shape is not None else ( - 1 ) __init__ __init__ ( dataset_node : DSNT , mapping_name : str , suffix : str = None , * , flag_name = '' , read_func : Callable [[ str ], VDMT ] = None , write_func : Callable [[ str , VDMT ], None ] = None , value_type : Callable = None , filllen = 6 , fillchar = '0' , alternate_suffix : list = None , read_func_args = None , read_func_kwargs = None , write_func_args = None , write_func_kwargs = None , array_shape : tuple [ int ] = None , ** kwargs ) -> None read_inv_format staticmethod read_inv_format ( array : np . ndarray ) array: np.ndarray [N, 5] write_format staticmethod write_format ( value : np . ndarray ) -> Any SingleFile UnifiedFileCluster Bases: FilesCluster [ UFH , UFC , DSNT , VDMT ] , Generic [ UFH , UFC , DSNT , VDMT ] DEFAULT_READ_FUNC class-attribute instance-attribute DEFAULT_READ_FUNC = None DEFAULT_SUFFIX class-attribute instance-attribute DEFAULT_SUFFIX = None DEFAULT_VALUE_TYPE class-attribute instance-attribute DEFAULT_VALUE_TYPE = None DEFAULT_WRITE_FUNC class-attribute instance-attribute DEFAULT_WRITE_FUNC = None FILESHANDLE_TYPE class-attribute instance-attribute FILESHANDLE_TYPE = UnifiedFilesHandle _FCT class-attribute instance-attribute _FCT = TypeVar ( '_FCT' , bound = 'UnifiedFileCluster' ) _FHT class-attribute instance-attribute _FHT = TypeVar ( '_FHT' , bound = UnifiedFilesHandle ) _IS_ELEM class-attribute instance-attribute _IS_ELEM = True _VDMT class-attribute instance-attribute _VDMT = TypeVar ( '_VDMT' ) alternate_suffix instance-attribute alternate_suffix = alternate_suffix if alternate_suffix is not None else [] cache_priority instance-attribute cache_priority = False fillchar instance-attribute fillchar = fillchar filllen instance-attribute filllen = filllen read_func instance-attribute read_func = read_func suffix instance-attribute suffix = suffix value_type instance-attribute value_type = value_type write_func instance-attribute write_func = write_func _paste_file Bases: _paste_file [ _FCT , _VDMT , _FHT ] get_FilesHandle get_FilesHandle ( src , dst , value : UnifiedFilesHandle , ** other_paras ) _read Bases: _read [ _FCT , _VDMT , _FHT ] core_func property writable core_func _write Bases: _write [ _FCT , _VDMT , _FHT ] core_func property writable core_func get_FilesHandle get_FilesHandle ( src , dst , value , * , sub_dir = '' , ** other_paras ) ElementsTest staticmethod ElementsTest () __init__ __init__ ( dataset_node : DSNT , mapping_name : str , suffix : str = None , * , flag_name = '' , read_func : Callable [[ str ], VDMT ] = None , write_func : Callable [[ str , VDMT ], None ] = None , value_type : Callable = None , filllen = 6 , fillchar = '0' , alternate_suffix : list = None , read_func_args = None , read_func_kwargs = None , write_func_args = None , write_func_kwargs = None , ** kwargs ) -> None append append ( value : VDMT , * , sub_dir = '' , force = False , ** other_paras ) clear clear ( * , force = False , clear_both = True ) copy_from copy_from ( src : UFC , * , cover = False , force = False , only_cache = None , ** other_paras ) create_fileshandle_in_iometa create_fileshandle_in_iometa ( src , dst , value , * , sub_dir = '' , ** other_paras ) deformat_corename deformat_corename ( corename : str ) format_corename format_corename ( data_i : int ) init_io_metas init_io_metas () init the io_metas of the data cluster matching_path matching_path () try_get_default classmethod try_get_default ( file : str , read_func : Callable = None , write_func : Callable = None , value_type : Callable = None ) update_read_func_binded_paras update_read_func_binded_paras ( paras : dict [ str , Any ]) update_write_func_binded_paras update_write_func_binded_paras ( paras : dict [ str , Any ]) write write ( data_i : int , value : VDMT , * , sub_dir = '' , force = False , ** other_paras ) -> None UnifiedFilesHandle Bases: FilesHandle [ UFC , VDMT ] , Generic [ UFC , VDMT ] init_input_hook init_input_hook ( * , read_func = None , write_func = None , value_type = None , ** kwargs ) cache_to_file_decorator cache_to_file_decorator ( func )","title":"dataCluster"},{"location":"md/data/dataCluster/#datacluster","text":"","title":"dataCluster"},{"location":"md/data/dataCluster/#data.dataCluster.DF","text":"DF = TypeVar ( 'DF' , bound = 'DictFile' )","title":"DF"},{"location":"md/data/dataCluster/#data.dataCluster.DFC","text":"DFC = TypeVar ( 'DFC' , bound = 'DisunifiedFileCluster' )","title":"DFC"},{"location":"md/data/dataCluster/#data.dataCluster.DFH","text":"DFH = TypeVar ( 'DFH' , bound = 'DisunifiedFilesHandle' )","title":"DFH"},{"location":"md/data/dataCluster/#data.dataCluster.DLC","text":"DLC = TypeVar ( 'DLC' , bound = 'DictLikeCluster' )","title":"DLC"},{"location":"md/data/dataCluster/#data.dataCluster.DLFH","text":"DLFH = TypeVar ( 'DLFH' , bound = 'DictLikeHandle' )","title":"DLFH"},{"location":"md/data/dataCluster/#data.dataCluster.FHT","text":"FHT = TypeVar ( 'FHT' , bound = FilesHandle )","title":"FHT"},{"location":"md/data/dataCluster/#data.dataCluster.INDADC","text":"INDADC = TypeVar ( 'INDADC' , bound = 'IntArrayDictAsTxtCluster' )","title":"INDADC"},{"location":"md/data/dataCluster/#data.dataCluster.IntArrayDict","text":"IntArrayDict = dict [ int , np . ndarray ]","title":"IntArrayDict"},{"location":"md/data/dataCluster/#data.dataCluster.NDAC","text":"NDAC = TypeVar ( 'NDAC' , bound = 'NdarrayAsTxtCluster' )","title":"NDAC"},{"location":"md/data/dataCluster/#data.dataCluster.UFC","text":"UFC = TypeVar ( 'UFC' , bound = 'UnifiedFileCluster' )","title":"UFC"},{"location":"md/data/dataCluster/#data.dataCluster.UFH","text":"UFH = TypeVar ( 'UFH' , bound = 'UnifiedFilesHandle' )","title":"UFH"},{"location":"md/data/dataCluster/#data.dataCluster.VDLT","text":"VDLT = TypeVar ( 'VDLT' , bound = dict [ int , Any ])","title":"VDLT"},{"location":"md/data/dataCluster/#data.dataCluster.VDMT","text":"VDMT = TypeVar ( 'VDMT' )","title":"VDMT"},{"location":"md/data/dataCluster/#data.dataCluster.VINDADC","text":"VINDADC = TypeVar ( 'VINDADC' , bound = dict [ int , np . ndarray ])","title":"VINDADC"},{"location":"md/data/dataCluster/#data.dataCluster.VNDAC","text":"VNDAC = TypeVar ( 'VNDAC' , bound = np . ndarray )","title":"VNDAC"},{"location":"md/data/dataCluster/#data.dataCluster.DictFile","text":"Bases: DisunifiedFileCluster [ DFH , DFC , DSNT , dict ] , Generic [ DFH , DFC , DSNT ]","title":"DictFile"},{"location":"md/data/dataCluster/#data.dataCluster.DictFile.cache_priority","text":"cache_priority = True","title":"cache_priority"},{"location":"md/data/dataCluster/#data.dataCluster.DictFile.write_synchronous","text":"write_synchronous = True","title":"write_synchronous"},{"location":"md/data/dataCluster/#data.dataCluster.DictFile.__contains__","text":"__contains__ ( i )","title":"__contains__()"},{"location":"md/data/dataCluster/#data.dataCluster.DictFile.__getitem__","text":"__getitem__ ( key : str )","title":"__getitem__()"},{"location":"md/data/dataCluster/#data.dataCluster.DictFile.__init__","text":"__init__ ( dataset_node : Union [ str , DatasetNode ], mapping_name : str , * args , flag_name = '' , file_name = '.json' , ** kwargs ) -> None","title":"__init__()"},{"location":"md/data/dataCluster/#data.dataCluster.DictFile.__iter__","text":"__iter__ ()","title":"__iter__()"},{"location":"md/data/dataCluster/#data.dataCluster.DictFile.__len__","text":"__len__ ()","title":"__len__()"},{"location":"md/data/dataCluster/#data.dataCluster.DictFile.__setitem__","text":"__setitem__ ( key : str , value )","title":"__setitem__()"},{"location":"md/data/dataCluster/#data.dataCluster.DictFile._set_fileshandle","text":"_set_fileshandle ( data_i , fileshandle : DFH )","title":"_set_fileshandle()"},{"location":"md/data/dataCluster/#data.dataCluster.DictFile.clear","text":"clear ( * arg , ** kw )","title":"clear()"},{"location":"md/data/dataCluster/#data.dataCluster.DictFile.get","text":"get ( * arg , ** kw )","title":"get()"},{"location":"md/data/dataCluster/#data.dataCluster.DictFile.has_info","text":"has_info ( key )","title":"has_info()"},{"location":"md/data/dataCluster/#data.dataCluster.DictFile.pop","text":"pop ( * arg , ** kw )","title":"pop()"},{"location":"md/data/dataCluster/#data.dataCluster.DictFile.popitem","text":"popitem ( * arg , ** kw )","title":"popitem()"},{"location":"md/data/dataCluster/#data.dataCluster.DictFile.read_info","text":"read_info ( key )","title":"read_info()"},{"location":"md/data/dataCluster/#data.dataCluster.DictFile.setdefault","text":"setdefault ( * arg , ** kw )","title":"setdefault()"},{"location":"md/data/dataCluster/#data.dataCluster.DictFile.update","text":"update ( * arg , ** kw )","title":"update()"},{"location":"md/data/dataCluster/#data.dataCluster.DictFile.write_info","text":"write_info ( key , value )","title":"write_info()"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster","text":"Bases: DisunifiedFileCluster [ DLFH , DLC , DSNT , VDLT ] , Generic [ DLFH , DLC , DSNT , VDLT ]","title":"DictLikeCluster"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster.FILESHANDLE_TYPE","text":"FILESHANDLE_TYPE : type [ FilesHandle ] = DictLikeHandle","title":"FILESHANDLE_TYPE"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster.SAVE_AFTER_CLOSE","text":"SAVE_AFTER_CLOSE = 1","title":"SAVE_AFTER_CLOSE"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster.SAVE_IMMIDIATELY","text":"SAVE_IMMIDIATELY = 0","title":"SAVE_IMMIDIATELY"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster.SAVE_STREAMLY","text":"SAVE_STREAMLY = 2","title":"SAVE_STREAMLY"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster._ELEM_BY_CACHE","text":"_ELEM_BY_CACHE = True","title":"_ELEM_BY_CACHE"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster._IS_ELEM","text":"_IS_ELEM = True","title":"_IS_ELEM"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster.caches","text":"caches","title":"caches"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster.save_mode","text":"save_mode","title":"save_mode"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster.stream_writer","text":"stream_writer = self . StreamlyWriter ( self )","title":"stream_writer"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster.write_streamly","text":"write_streamly","title":"write_streamly"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster.StreamlyWriter","text":"Bases: _Writer","title":"StreamlyWriter"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster.StreamlyWriter.obj","text":"obj : DictLikeCluster = self . obj","title":"obj"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster.StreamlyWriter.streams","text":"streams : list [ JsonIO . Stream ] = []","title":"streams"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster.StreamlyWriter.__init__","text":"__init__ ( cluster : DictLikeCluster ) -> None","title":"__init__()"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster.StreamlyWriter.enter_hook","text":"enter_hook ()","title":"enter_hook()"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster.StreamlyWriter.exit_hook","text":"exit_hook ()","title":"exit_hook()"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster.StreamlyWriter.write","text":"write ( data_i : int , elem_i , value )","title":"write()"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster._modify_elem_key","text":"Bases: _modify_key ['DictLikeCluster', dict [ int , Any ], DictLikeHandle ]","title":"_modify_elem_key"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster._modify_elem_key.OPER_ELEM","text":"OPER_ELEM = True","title":"OPER_ELEM"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster._modify_elem_key.operate_elem","text":"operate_elem ( src , dst , values : dict , ** other_paras )","title":"operate_elem()"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster._read_elem","text":"Bases: _read ['DictLikeCluster', dict [ int , Any ], DictLikeHandle ]","title":"_read_elem"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster._read_elem.OPER_ELEM","text":"OPER_ELEM = True","title":"OPER_ELEM"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster._read_elem.operate_elem","text":"operate_elem ( src , dst , value , ** other_paras )","title":"operate_elem()"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster._remove_elem","text":"Bases: _remove ['DictLikeCluster', dict [ int , Any ], DictLikeHandle ]","title":"_remove_elem"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster._remove_elem.OPER_ELEM","text":"OPER_ELEM = True","title":"OPER_ELEM"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster._remove_elem.operate_elem","text":"operate_elem ( src , dst , value , ** other_paras )","title":"operate_elem()"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster._write_elem","text":"Bases: _write ['DictLikeCluster', dict [ int , Any ], DictLikeHandle ]","title":"_write_elem"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster._write_elem.OPER_ELEM","text":"OPER_ELEM = True","title":"OPER_ELEM"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster._write_elem.operate_elem","text":"operate_elem ( src , dst , values : dict [ int , Any ], ** other_paras )","title":"operate_elem()"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster.Test","text":"Test ()","title":"Test()"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster.__init__","text":"__init__ ( dataset_node : Union [ str , DatasetNode ], mapping_name : str , * args , flag_name = '' , ** kwargs ) -> None","title":"__init__()"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster._set_fileshandle","text":"_set_fileshandle ( data_i , fh : DictLikeHandle )","title":"_set_fileshandle()"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster.add_default_file","text":"add_default_file ( filename )","title":"add_default_file()"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster.elem_keys","text":"elem_keys ()","title":"elem_keys()"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster.from_cluster","text":"from_cluster ( cluster : DLC , dataset_node : DSNT = None , mapping_name = None , * args , flag_name = '' , ** kwargs ) -> DLC","title":"from_cluster()"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster.init_io_metas","text":"init_io_metas ()","title":"init_io_metas()"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster.modify_elem_key","text":"modify_elem_key ( src : int , dst : int , * , force = False , ** other_paras ) -> dict","title":"modify_elem_key()"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster.read_elem","text":"read_elem ( src : Union [ int , Iterable [ int ]], * , force = False , ** other_paras ) -> Union [ dict , list [ dict ]]","title":"read_elem()"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster.remove_elem","text":"remove_elem ( dst : int , remove_both = False , * , force = False , ** other_paras ) -> dict","title":"remove_elem()"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster.save_without_cache","text":"save_without_cache () to spare memory, save without cache","title":"save_without_cache()"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster.sort_elem","text":"sort_elem ()","title":"sort_elem()"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeCluster.write_elem","text":"write_elem ( dst : int , value : Union [ Any , dict [ int , Any ]], * , force = False , ** other_paras ) -> dict","title":"write_elem()"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeHandle","text":"Bases: DisunifiedFilesHandle [ DLC , dict [ int , Any ]] , Generic [ DLC ]","title":"DictLikeHandle"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeHandle.LOAD_CACHE_ON_INIT","text":"LOAD_CACHE_ON_INIT = True","title":"LOAD_CACHE_ON_INIT"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeHandle.elem_num","text":"elem_num","title":"elem_num"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeHandle.has_cache","text":"has_cache","title":"has_cache"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeHandle.erase_cache","text":"erase_cache ()","title":"erase_cache()"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeHandle.get_cache_at","text":"get_cache_at ( elem_i ) -> Union [ Any , None ]","title":"get_cache_at()"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeHandle.init_input_hook","text":"init_input_hook ( * , value_type , ** kw )","title":"init_input_hook()"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeHandle.pop_cache_at","text":"pop_cache_at ( elem_i ) -> Union [ Any , None ]","title":"pop_cache_at()"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeHandle.set_cache_at","text":"set_cache_at ( elem_i , value ) -> bool","title":"set_cache_at()"},{"location":"md/data/dataCluster/#data.dataCluster.DictLikeHandle.sort_cache","text":"sort_cache ()","title":"sort_cache()"},{"location":"md/data/dataCluster/#data.dataCluster.DisunifiedFileCluster","text":"Bases: FilesCluster [ DFH , DFC , DSNT , VDMT ] , Generic [ DFH , DFC , DSNT , VDMT ]","title":"DisunifiedFileCluster"},{"location":"md/data/dataCluster/#data.dataCluster.DisunifiedFileCluster.FILESHANDLE_TYPE","text":"FILESHANDLE_TYPE = DisunifiedFilesHandle","title":"FILESHANDLE_TYPE"},{"location":"md/data/dataCluster/#data.dataCluster.DisunifiedFileCluster._FCT","text":"_FCT = TypeVar ( '_FCT' , bound = 'DisunifiedFileCluster' )","title":"_FCT"},{"location":"md/data/dataCluster/#data.dataCluster.DisunifiedFileCluster._FHT","text":"_FHT = TypeVar ( '_FHT' , bound = DisunifiedFilesHandle )","title":"_FHT"},{"location":"md/data/dataCluster/#data.dataCluster.DisunifiedFileCluster._VDMT","text":"_VDMT = TypeVar ( '_VDMT' )","title":"_VDMT"},{"location":"md/data/dataCluster/#data.dataCluster.DisunifiedFileCluster.all_files_exist","text":"all_files_exist","title":"all_files_exist"},{"location":"md/data/dataCluster/#data.dataCluster.DisunifiedFileCluster.file_names","text":"file_names","title":"file_names"},{"location":"md/data/dataCluster/#data.dataCluster.DisunifiedFileCluster._read","text":"Bases: _read [ _FCT , _VDMT , _FHT ]","title":"_read"},{"location":"md/data/dataCluster/#data.dataCluster.DisunifiedFileCluster._read.get_file_core_func","text":"get_file_core_func ( src_file_handle : DisunifiedFilesHandle , dst_file_handle : DisunifiedFilesHandle , value ) -> Callable [ ... , Any ]","title":"get_file_core_func()"},{"location":"md/data/dataCluster/#data.dataCluster.DisunifiedFileCluster._write","text":"Bases: _write [ _FCT , _VDMT , _FHT ]","title":"_write"},{"location":"md/data/dataCluster/#data.dataCluster.DisunifiedFileCluster._write.get_file_core_func","text":"get_file_core_func ( src_file_handle : DisunifiedFilesHandle , dst_file_handle : DisunifiedFilesHandle , value ) -> Callable [ ... , Any ]","title":"get_file_core_func()"},{"location":"md/data/dataCluster/#data.dataCluster.DisunifiedFileCluster.Test","text":"Test ()","title":"Test()"},{"location":"md/data/dataCluster/#data.dataCluster.DisunifiedFileCluster.__init__","text":"__init__ ( dataset_node : Union [ str , DatasetNode ], mapping_name : str , * args , flag_name = '' , fileshandle_list = None , ** kwargs ) -> None","title":"__init__()"},{"location":"md/data/dataCluster/#data.dataCluster.DisunifiedFileCluster.add_default_file","text":"add_default_file ( filename )","title":"add_default_file()"},{"location":"md/data/dataCluster/#data.dataCluster.DisunifiedFileCluster.create_fileshandle_in_iometa","text":"create_fileshandle_in_iometa ( src : int , dst : int , value : Any , ** other_paras )","title":"create_fileshandle_in_iometa()"},{"location":"md/data/dataCluster/#data.dataCluster.DisunifiedFileCluster.cvt_key","text":"cvt_key ( key : Union [ int , str , DisunifiedFilesHandle ])","title":"cvt_key()"},{"location":"md/data/dataCluster/#data.dataCluster.DisunifiedFileCluster.rebuild","text":"rebuild ( force = False )","title":"rebuild()"},{"location":"md/data/dataCluster/#data.dataCluster.DisunifiedFilesHandle","text":"Bases: FilesHandle [ DFC , VDMT ] , Generic [ DFC , VDMT ]","title":"DisunifiedFilesHandle"},{"location":"md/data/dataCluster/#data.dataCluster.DisunifiedFilesHandle.file","text":"file","title":"file"},{"location":"md/data/dataCluster/#data.dataCluster.IntArrayDictAsTxtCluster","text":"Bases: NdarrayAsTxtCluster [ UFH , INDADC , DSNT , IntArrayDict ] , Generic [ UFH , INDADC , DSNT ]","title":"IntArrayDictAsTxtCluster"},{"location":"md/data/dataCluster/#data.dataCluster.IntArrayDictAsTxtCluster.DEFAULT_VALUE_TYPE","text":"DEFAULT_VALUE_TYPE = dict","title":"DEFAULT_VALUE_TYPE"},{"location":"md/data/dataCluster/#data.dataCluster.IntArrayDictAsTxtCluster.read_inv_format","text":"read_inv_format ( array : np . ndarray ) array: np.ndarray [N, 5]","title":"read_inv_format()"},{"location":"md/data/dataCluster/#data.dataCluster.IntArrayDictAsTxtCluster.write_format","text":"write_format ( value : IntArrayDict ) -> Any","title":"write_format()"},{"location":"md/data/dataCluster/#data.dataCluster.NdarrayAsTxtCluster","text":"Bases: UnifiedFileCluster [ UFH , NDAC , DSNT , VNDAC ] , Generic [ UFH , NDAC , DSNT , VNDAC ]","title":"NdarrayAsTxtCluster"},{"location":"md/data/dataCluster/#data.dataCluster.NdarrayAsTxtCluster.DEFAULT_READ_FUNC","text":"DEFAULT_READ_FUNC = np . loadtxt","title":"DEFAULT_READ_FUNC"},{"location":"md/data/dataCluster/#data.dataCluster.NdarrayAsTxtCluster.DEFAULT_SUFFIX","text":"DEFAULT_SUFFIX = '.txt'","title":"DEFAULT_SUFFIX"},{"location":"md/data/dataCluster/#data.dataCluster.NdarrayAsTxtCluster.DEFAULT_VALUE_TYPE","text":"DEFAULT_VALUE_TYPE = np . ndarray","title":"DEFAULT_VALUE_TYPE"},{"location":"md/data/dataCluster/#data.dataCluster.NdarrayAsTxtCluster.DEFAULT_WRITE_FUNC","text":"DEFAULT_WRITE_FUNC = np . savetxt","title":"DEFAULT_WRITE_FUNC"},{"location":"md/data/dataCluster/#data.dataCluster.NdarrayAsTxtCluster.array_shape","text":"array_shape : tuple [ int ] = array_shape if array_shape is not None else ( - 1 )","title":"array_shape"},{"location":"md/data/dataCluster/#data.dataCluster.NdarrayAsTxtCluster.__init__","text":"__init__ ( dataset_node : DSNT , mapping_name : str , suffix : str = None , * , flag_name = '' , read_func : Callable [[ str ], VDMT ] = None , write_func : Callable [[ str , VDMT ], None ] = None , value_type : Callable = None , filllen = 6 , fillchar = '0' , alternate_suffix : list = None , read_func_args = None , read_func_kwargs = None , write_func_args = None , write_func_kwargs = None , array_shape : tuple [ int ] = None , ** kwargs ) -> None","title":"__init__()"},{"location":"md/data/dataCluster/#data.dataCluster.NdarrayAsTxtCluster.read_inv_format","text":"read_inv_format ( array : np . ndarray ) array: np.ndarray [N, 5]","title":"read_inv_format()"},{"location":"md/data/dataCluster/#data.dataCluster.NdarrayAsTxtCluster.write_format","text":"write_format ( value : np . ndarray ) -> Any","title":"write_format()"},{"location":"md/data/dataCluster/#data.dataCluster.SingleFile","text":"","title":"SingleFile"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster","text":"Bases: FilesCluster [ UFH , UFC , DSNT , VDMT ] , Generic [ UFH , UFC , DSNT , VDMT ]","title":"UnifiedFileCluster"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster.DEFAULT_READ_FUNC","text":"DEFAULT_READ_FUNC = None","title":"DEFAULT_READ_FUNC"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster.DEFAULT_SUFFIX","text":"DEFAULT_SUFFIX = None","title":"DEFAULT_SUFFIX"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster.DEFAULT_VALUE_TYPE","text":"DEFAULT_VALUE_TYPE = None","title":"DEFAULT_VALUE_TYPE"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster.DEFAULT_WRITE_FUNC","text":"DEFAULT_WRITE_FUNC = None","title":"DEFAULT_WRITE_FUNC"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster.FILESHANDLE_TYPE","text":"FILESHANDLE_TYPE = UnifiedFilesHandle","title":"FILESHANDLE_TYPE"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster._FCT","text":"_FCT = TypeVar ( '_FCT' , bound = 'UnifiedFileCluster' )","title":"_FCT"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster._FHT","text":"_FHT = TypeVar ( '_FHT' , bound = UnifiedFilesHandle )","title":"_FHT"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster._IS_ELEM","text":"_IS_ELEM = True","title":"_IS_ELEM"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster._VDMT","text":"_VDMT = TypeVar ( '_VDMT' )","title":"_VDMT"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster.alternate_suffix","text":"alternate_suffix = alternate_suffix if alternate_suffix is not None else []","title":"alternate_suffix"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster.cache_priority","text":"cache_priority = False","title":"cache_priority"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster.fillchar","text":"fillchar = fillchar","title":"fillchar"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster.filllen","text":"filllen = filllen","title":"filllen"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster.read_func","text":"read_func = read_func","title":"read_func"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster.suffix","text":"suffix = suffix","title":"suffix"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster.value_type","text":"value_type = value_type","title":"value_type"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster.write_func","text":"write_func = write_func","title":"write_func"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster._paste_file","text":"Bases: _paste_file [ _FCT , _VDMT , _FHT ]","title":"_paste_file"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster._paste_file.get_FilesHandle","text":"get_FilesHandle ( src , dst , value : UnifiedFilesHandle , ** other_paras )","title":"get_FilesHandle()"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster._read","text":"Bases: _read [ _FCT , _VDMT , _FHT ]","title":"_read"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster._read.core_func","text":"core_func","title":"core_func"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster._write","text":"Bases: _write [ _FCT , _VDMT , _FHT ]","title":"_write"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster._write.core_func","text":"core_func","title":"core_func"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster._write.get_FilesHandle","text":"get_FilesHandle ( src , dst , value , * , sub_dir = '' , ** other_paras )","title":"get_FilesHandle()"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster.ElementsTest","text":"ElementsTest ()","title":"ElementsTest()"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster.__init__","text":"__init__ ( dataset_node : DSNT , mapping_name : str , suffix : str = None , * , flag_name = '' , read_func : Callable [[ str ], VDMT ] = None , write_func : Callable [[ str , VDMT ], None ] = None , value_type : Callable = None , filllen = 6 , fillchar = '0' , alternate_suffix : list = None , read_func_args = None , read_func_kwargs = None , write_func_args = None , write_func_kwargs = None , ** kwargs ) -> None","title":"__init__()"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster.append","text":"append ( value : VDMT , * , sub_dir = '' , force = False , ** other_paras )","title":"append()"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster.clear","text":"clear ( * , force = False , clear_both = True )","title":"clear()"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster.copy_from","text":"copy_from ( src : UFC , * , cover = False , force = False , only_cache = None , ** other_paras )","title":"copy_from()"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster.create_fileshandle_in_iometa","text":"create_fileshandle_in_iometa ( src , dst , value , * , sub_dir = '' , ** other_paras )","title":"create_fileshandle_in_iometa()"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster.deformat_corename","text":"deformat_corename ( corename : str )","title":"deformat_corename()"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster.format_corename","text":"format_corename ( data_i : int )","title":"format_corename()"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster.init_io_metas","text":"init_io_metas () init the io_metas of the data cluster","title":"init_io_metas()"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster.matching_path","text":"matching_path ()","title":"matching_path()"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster.try_get_default","text":"try_get_default ( file : str , read_func : Callable = None , write_func : Callable = None , value_type : Callable = None )","title":"try_get_default()"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster.update_read_func_binded_paras","text":"update_read_func_binded_paras ( paras : dict [ str , Any ])","title":"update_read_func_binded_paras()"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster.update_write_func_binded_paras","text":"update_write_func_binded_paras ( paras : dict [ str , Any ])","title":"update_write_func_binded_paras()"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFileCluster.write","text":"write ( data_i : int , value : VDMT , * , sub_dir = '' , force = False , ** other_paras ) -> None","title":"write()"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFilesHandle","text":"Bases: FilesHandle [ UFC , VDMT ] , Generic [ UFC , VDMT ]","title":"UnifiedFilesHandle"},{"location":"md/data/dataCluster/#data.dataCluster.UnifiedFilesHandle.init_input_hook","text":"init_input_hook ( * , read_func = None , write_func = None , value_type = None , ** kwargs )","title":"init_input_hook()"},{"location":"md/data/dataCluster/#data.dataCluster.cache_to_file_decorator","text":"cache_to_file_decorator ( func )","title":"cache_to_file_decorator()"},{"location":"md/data/dataset/","text":"dataset DST module-attribute DST = TypeVar ( 'DST' , bound = 'Dataset' ) FCT module-attribute FCT = TypeVar ( 'FCT' , bound = 'FilesCluster' ) VDST module-attribute VDST = TypeVar ( 'VDST' ) Dataset Bases: DatasetNode [ FCT , DST , VDST ] , Generic [ FCT , DST , VDST ] DEFAULT_SPLITER_NAME class-attribute instance-attribute DEFAULT_SPLITER_NAME = 'default' DEFAULT_SUBSETS class-attribute instance-attribute DEFAULT_SUBSETS = [ 'train' , 'val' ] SPLIT_PARA class-attribute instance-attribute SPLIT_PARA = { DEFAULT_SPLITER_NAME : DEFAULT_SUBSETS } active_spliter property active_spliter default_spliter property default_spliter default_train_idx_array property default_train_idx_array default_val_idx_array property default_val_idx_array split_mode property writable split_mode train_idx_array property train_idx_array val_idx_array property val_idx_array init_clusters_hook init_clusters_hook () Mix_Dataset Bases: Dataset [ FCT , DST , VDST ] BASIS_SPLITER_NAME class-attribute instance-attribute BASIS_SPLITER_NAME = 'basis' BASIS_SUBSETS class-attribute instance-attribute BASIS_SUBSETS = [ 'basic' , 'augment' ] REALITY_SPLITER_NAME class-attribute instance-attribute REALITY_SPLITER_NAME = 'reality' REALITY_SUBSETS class-attribute instance-attribute REALITY_SUBSETS = [ 'real' , 'sim' ] SPLIT_PARA class-attribute instance-attribute SPLIT_PARA = Dataset . SPLIT_PARA . copy () augment_idx_array property augment_idx_array basic_idx_array property basic_idx_array basis_spliter property basis_spliter real_idx_array property real_idx_array reality_spliter property reality_spliter sim_idx_array property sim_idx_array record_data_type record_data_type ( data_i , is_real , is_basic ) test_dataset test_dataset ()","title":"dataset"},{"location":"md/data/dataset/#dataset","text":"","title":"dataset"},{"location":"md/data/dataset/#data.dataset.DST","text":"DST = TypeVar ( 'DST' , bound = 'Dataset' )","title":"DST"},{"location":"md/data/dataset/#data.dataset.FCT","text":"FCT = TypeVar ( 'FCT' , bound = 'FilesCluster' )","title":"FCT"},{"location":"md/data/dataset/#data.dataset.VDST","text":"VDST = TypeVar ( 'VDST' )","title":"VDST"},{"location":"md/data/dataset/#data.dataset.Dataset","text":"Bases: DatasetNode [ FCT , DST , VDST ] , Generic [ FCT , DST , VDST ]","title":"Dataset"},{"location":"md/data/dataset/#data.dataset.Dataset.DEFAULT_SPLITER_NAME","text":"DEFAULT_SPLITER_NAME = 'default'","title":"DEFAULT_SPLITER_NAME"},{"location":"md/data/dataset/#data.dataset.Dataset.DEFAULT_SUBSETS","text":"DEFAULT_SUBSETS = [ 'train' , 'val' ]","title":"DEFAULT_SUBSETS"},{"location":"md/data/dataset/#data.dataset.Dataset.SPLIT_PARA","text":"SPLIT_PARA = { DEFAULT_SPLITER_NAME : DEFAULT_SUBSETS }","title":"SPLIT_PARA"},{"location":"md/data/dataset/#data.dataset.Dataset.active_spliter","text":"active_spliter","title":"active_spliter"},{"location":"md/data/dataset/#data.dataset.Dataset.default_spliter","text":"default_spliter","title":"default_spliter"},{"location":"md/data/dataset/#data.dataset.Dataset.default_train_idx_array","text":"default_train_idx_array","title":"default_train_idx_array"},{"location":"md/data/dataset/#data.dataset.Dataset.default_val_idx_array","text":"default_val_idx_array","title":"default_val_idx_array"},{"location":"md/data/dataset/#data.dataset.Dataset.split_mode","text":"split_mode","title":"split_mode"},{"location":"md/data/dataset/#data.dataset.Dataset.train_idx_array","text":"train_idx_array","title":"train_idx_array"},{"location":"md/data/dataset/#data.dataset.Dataset.val_idx_array","text":"val_idx_array","title":"val_idx_array"},{"location":"md/data/dataset/#data.dataset.Dataset.init_clusters_hook","text":"init_clusters_hook ()","title":"init_clusters_hook()"},{"location":"md/data/dataset/#data.dataset.Mix_Dataset","text":"Bases: Dataset [ FCT , DST , VDST ]","title":"Mix_Dataset"},{"location":"md/data/dataset/#data.dataset.Mix_Dataset.BASIS_SPLITER_NAME","text":"BASIS_SPLITER_NAME = 'basis'","title":"BASIS_SPLITER_NAME"},{"location":"md/data/dataset/#data.dataset.Mix_Dataset.BASIS_SUBSETS","text":"BASIS_SUBSETS = [ 'basic' , 'augment' ]","title":"BASIS_SUBSETS"},{"location":"md/data/dataset/#data.dataset.Mix_Dataset.REALITY_SPLITER_NAME","text":"REALITY_SPLITER_NAME = 'reality'","title":"REALITY_SPLITER_NAME"},{"location":"md/data/dataset/#data.dataset.Mix_Dataset.REALITY_SUBSETS","text":"REALITY_SUBSETS = [ 'real' , 'sim' ]","title":"REALITY_SUBSETS"},{"location":"md/data/dataset/#data.dataset.Mix_Dataset.SPLIT_PARA","text":"SPLIT_PARA = Dataset . SPLIT_PARA . copy ()","title":"SPLIT_PARA"},{"location":"md/data/dataset/#data.dataset.Mix_Dataset.augment_idx_array","text":"augment_idx_array","title":"augment_idx_array"},{"location":"md/data/dataset/#data.dataset.Mix_Dataset.basic_idx_array","text":"basic_idx_array","title":"basic_idx_array"},{"location":"md/data/dataset/#data.dataset.Mix_Dataset.basis_spliter","text":"basis_spliter","title":"basis_spliter"},{"location":"md/data/dataset/#data.dataset.Mix_Dataset.real_idx_array","text":"real_idx_array","title":"real_idx_array"},{"location":"md/data/dataset/#data.dataset.Mix_Dataset.reality_spliter","text":"reality_spliter","title":"reality_spliter"},{"location":"md/data/dataset/#data.dataset.Mix_Dataset.sim_idx_array","text":"sim_idx_array","title":"sim_idx_array"},{"location":"md/data/dataset/#data.dataset.Mix_Dataset.record_data_type","text":"record_data_type ( data_i , is_real , is_basic )","title":"record_data_type()"},{"location":"md/data/dataset/#data.dataset.test_dataset","text":"test_dataset ()","title":"test_dataset()"},{"location":"md/data/dataset_example/","text":"dataset_example BopFormat Bases: PostureDataset [ UnifiedFileCluster , 'BopFormat', ViewMeta ] info: rlt = { \"scene_camera\": {KW_CAM_K: array, KW_cam_R_w2c: array, KW_cam_t_w2c: array, KW_CAM_DS:float} \"scene_gt\": [{KW_GT_R: array, KW_GT_t: array, KW_GT_ID: int}, ...] } DEPTH_DIR class-attribute instance-attribute DEPTH_DIR = 'depth' GT_CAM_FILE class-attribute instance-attribute GT_CAM_FILE = GT_CAM_FILE_NAME + '.json' GT_CAM_FILE_NAME class-attribute instance-attribute GT_CAM_FILE_NAME = 'scene_camera' GT_FILE class-attribute instance-attribute GT_FILE = GT_FILE_NAME + '.json' GT_FILE_NAME class-attribute instance-attribute GT_FILE_NAME = 'scene_gt' GT_INFO_FILE class-attribute instance-attribute GT_INFO_FILE = GT_INFO_FILE_NAME + '.json' GT_INFO_FILE_NAME class-attribute instance-attribute GT_INFO_FILE_NAME = 'scene_gt_info' INFO class-attribute instance-attribute INFO = 'info' KW_CAM_DS class-attribute instance-attribute KW_CAM_DS = 'depth_scale' KW_CAM_K class-attribute instance-attribute KW_CAM_K = 'cam_K' KW_CAM_VL class-attribute instance-attribute KW_CAM_VL = 'view_level' KW_GT_ID class-attribute instance-attribute KW_GT_ID = 'obj_id' KW_GT_INFO_BBOX_OBJ class-attribute instance-attribute KW_GT_INFO_BBOX_OBJ = 'bbox_obj' KW_GT_INFO_BBOX_VIS class-attribute instance-attribute KW_GT_INFO_BBOX_VIS = 'bbox_visib' KW_GT_INFO_PX_COUNT_ALL class-attribute instance-attribute KW_GT_INFO_PX_COUNT_ALL = 'px_count_all' KW_GT_INFO_PX_COUNT_VIS class-attribute instance-attribute KW_GT_INFO_PX_COUNT_VIS = 'px_count_visib' KW_GT_INFO_PX_COUNT_VLD class-attribute instance-attribute KW_GT_INFO_PX_COUNT_VLD = 'px_count_valid' KW_GT_INFO_VISIB_FRACT class-attribute instance-attribute KW_GT_INFO_VISIB_FRACT = 'visib_fract' KW_GT_R class-attribute instance-attribute KW_GT_R = 'cam_R_m2c' KW_GT_t class-attribute instance-attribute KW_GT_t = 'cam_t_m2c' KW_cam_R_w2c class-attribute instance-attribute KW_cam_R_w2c = 'cam_R_w2c' KW_cam_t_w2c class-attribute instance-attribute KW_cam_t_w2c = 'cam_t_w2c' MASK_DIR class-attribute instance-attribute MASK_DIR = 'mask' RGB_DIR class-attribute instance-attribute RGB_DIR = 'rgb' init_clusters_hook init_clusters_hook () read read ( src : int , * , force = False , ** other_paras ) -> ViewMeta write write ( data_i : int , value : ViewMeta , * , force = False , ** other_paras ) MutilMaskCluster Bases: UnifiedFileCluster [ MutilMaskFilesHandle , 'MutilMaskCluster', 'BopFormat', dict [ int , ndarray ]] DEFAULT_APPENDNAMES_JOINER class-attribute instance-attribute DEFAULT_APPENDNAMES_JOINER = '_' DEFAULT_READ_FUNC class-attribute instance-attribute DEFAULT_READ_FUNC = cv2 . imread DEFAULT_SUFFIX class-attribute instance-attribute DEFAULT_SUFFIX = '.png' DEFAULT_WRITE_FUNC class-attribute instance-attribute DEFAULT_WRITE_FUNC = cv2 . imwrite KW_ID_SEQ class-attribute instance-attribute KW_ID_SEQ = 'id_seq' MULTI_FILES class-attribute instance-attribute MULTI_FILES = True _read Bases: _read ['MutilMaskCluster', dict [ int , ndarray ], MutilMaskFilesHandle ] gather_mutil_results gather_mutil_results ( results : list ) _write Bases: _write ['MutilMaskCluster', dict [ int , ndarray ], MutilMaskFilesHandle ] split_value_as_mutil split_value_as_mutil ( core_values : dict [ int , np . ndarray ]) _set_rely _set_rely ( relied : DictLikeHandle , rlt : dict ) rlt = { \"scene_camera\": {KW_CAM_K: array, KW_cam_R_w2c: array, KW_cam_t_w2c: array, KW_CAM_DS:float} \"scene_gt\": [{KW_GT_R: array, KW_GT_t: array, KW_GT_ID: int}, ...] } MutilMaskFilesHandle Bases: UnifiedFilesHandle PostureDataset Bases: Mix_Dataset [ FCT , DST , VDST ] POSTURE_SPLITER_NAME class-attribute instance-attribute POSTURE_SPLITER_NAME = 'posture' POSTURE_SUBSETS class-attribute instance-attribute POSTURE_SUBSETS = [ 'train' , 'val' ] SPLIT_PARA class-attribute instance-attribute SPLIT_PARA = Mix_Dataset . SPLIT_PARA . copy () posture_spliter property posture_spliter posture_train_idx_array property posture_train_idx_array posture_val_idx_array property posture_val_idx_array split_for_posture split_for_posture ( ratio = 0.15 , source : list [ int ] = None ) Only take ratio of the real data as the verification set VocFormat_6dPosture Bases: PostureDataset [ UnifiedFileCluster , 'VocFormat_6dPosture', ViewMeta ] KW_IMGAE_DIR class-attribute instance-attribute KW_IMGAE_DIR = 'images' default_spliter property default_spliter __init__ __init__ ( directory , * , flag_name = '' , parent : DatasetNode = None ) -> None copy_from_simplified copy_from_simplified ( src_dataset : VocFormat_6dPosture , * , cover = False , force = False ) deserialize_mask_dict staticmethod deserialize_mask_dict ( obj , mask_bytes_dict : dict [ int , bytes ]) file_to_cache_simple file_to_cache_simple ( * , force = False ) get_default_set_of get_default_set_of ( data_i ) init_clusters_hook init_clusters_hook () init_dataset_attr_hook init_dataset_attr_hook () read read ( src : int , * , force = False , ** other_paras ) -> ViewMeta serialize_mask_dict staticmethod serialize_mask_dict ( obj , mask_ndarray_dict : dict [ int , np . ndarray ]) write write ( data_i : int , value : ViewMeta , * , force = False , ** other_paras ) cxcywhLabelCluster Bases: IntArrayDictAsTxtCluster [ UnifiedFilesHandle , 'cxcywhLabelCluster', 'VocFormat_6dPosture'] KW_IMAGE_SIZE class-attribute instance-attribute KW_IMAGE_SIZE = 'image_size' KW_IO_RAW class-attribute instance-attribute KW_IO_RAW = 'raw' _read Bases: _read ['cxcywhLabelCluster', dict [ int , ndarray ], UnifiedFilesHandle ] postprogress_value postprogress_value ( value : np . ndarray , * , image_size = None , ** other_paras ) _write Bases: _write ['cxcywhLabelCluster', dict [ int , ndarray ], UnifiedFilesHandle ] preprogress_value preprogress_value ( value : dict [ int , np . ndarray ], * , image_size = None , ** other_paras ) _normedcxcywh_2_x1y1x2y2 staticmethod _normedcxcywh_2_x1y1x2y2 ( bbox_2d , img_size ) bbox_2d: np.ndarray [..., (cx, cy, w, h)] img_size: (w, h) _set_rely _set_rely ( relied : FilesCluster , rlt ) _x1y1x2y2_2_normedcxcywh staticmethod _x1y1x2y2_2_normedcxcywh ( bbox_2d , img_size ) bbox_2d: np.ndarray [..., (x1, x2, y1, y2)] img_size: (w, h) init_attrs init_attrs () read read ( src : int , * , sub_dir = None , image_size = None , force = False , ** other_paras ) -> dict [ int , np . ndarray ] write write ( data_i : int , value : dict [ int , np . ndarray ], * , sub_dir = None , image_size = None , force = False , ** other_paras )","title":"dataset_example"},{"location":"md/data/dataset_example/#dataset_example","text":"","title":"dataset_example"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat","text":"Bases: PostureDataset [ UnifiedFileCluster , 'BopFormat', ViewMeta ] info: rlt = { \"scene_camera\": {KW_CAM_K: array, KW_cam_R_w2c: array, KW_cam_t_w2c: array, KW_CAM_DS:float} \"scene_gt\": [{KW_GT_R: array, KW_GT_t: array, KW_GT_ID: int}, ...] }","title":"BopFormat"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat.DEPTH_DIR","text":"DEPTH_DIR = 'depth'","title":"DEPTH_DIR"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat.GT_CAM_FILE","text":"GT_CAM_FILE = GT_CAM_FILE_NAME + '.json'","title":"GT_CAM_FILE"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat.GT_CAM_FILE_NAME","text":"GT_CAM_FILE_NAME = 'scene_camera'","title":"GT_CAM_FILE_NAME"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat.GT_FILE","text":"GT_FILE = GT_FILE_NAME + '.json'","title":"GT_FILE"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat.GT_FILE_NAME","text":"GT_FILE_NAME = 'scene_gt'","title":"GT_FILE_NAME"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat.GT_INFO_FILE","text":"GT_INFO_FILE = GT_INFO_FILE_NAME + '.json'","title":"GT_INFO_FILE"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat.GT_INFO_FILE_NAME","text":"GT_INFO_FILE_NAME = 'scene_gt_info'","title":"GT_INFO_FILE_NAME"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat.INFO","text":"INFO = 'info'","title":"INFO"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat.KW_CAM_DS","text":"KW_CAM_DS = 'depth_scale'","title":"KW_CAM_DS"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat.KW_CAM_K","text":"KW_CAM_K = 'cam_K'","title":"KW_CAM_K"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat.KW_CAM_VL","text":"KW_CAM_VL = 'view_level'","title":"KW_CAM_VL"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat.KW_GT_ID","text":"KW_GT_ID = 'obj_id'","title":"KW_GT_ID"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat.KW_GT_INFO_BBOX_OBJ","text":"KW_GT_INFO_BBOX_OBJ = 'bbox_obj'","title":"KW_GT_INFO_BBOX_OBJ"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat.KW_GT_INFO_BBOX_VIS","text":"KW_GT_INFO_BBOX_VIS = 'bbox_visib'","title":"KW_GT_INFO_BBOX_VIS"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat.KW_GT_INFO_PX_COUNT_ALL","text":"KW_GT_INFO_PX_COUNT_ALL = 'px_count_all'","title":"KW_GT_INFO_PX_COUNT_ALL"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat.KW_GT_INFO_PX_COUNT_VIS","text":"KW_GT_INFO_PX_COUNT_VIS = 'px_count_visib'","title":"KW_GT_INFO_PX_COUNT_VIS"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat.KW_GT_INFO_PX_COUNT_VLD","text":"KW_GT_INFO_PX_COUNT_VLD = 'px_count_valid'","title":"KW_GT_INFO_PX_COUNT_VLD"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat.KW_GT_INFO_VISIB_FRACT","text":"KW_GT_INFO_VISIB_FRACT = 'visib_fract'","title":"KW_GT_INFO_VISIB_FRACT"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat.KW_GT_R","text":"KW_GT_R = 'cam_R_m2c'","title":"KW_GT_R"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat.KW_GT_t","text":"KW_GT_t = 'cam_t_m2c'","title":"KW_GT_t"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat.KW_cam_R_w2c","text":"KW_cam_R_w2c = 'cam_R_w2c'","title":"KW_cam_R_w2c"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat.KW_cam_t_w2c","text":"KW_cam_t_w2c = 'cam_t_w2c'","title":"KW_cam_t_w2c"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat.MASK_DIR","text":"MASK_DIR = 'mask'","title":"MASK_DIR"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat.RGB_DIR","text":"RGB_DIR = 'rgb'","title":"RGB_DIR"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat.init_clusters_hook","text":"init_clusters_hook ()","title":"init_clusters_hook()"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat.read","text":"read ( src : int , * , force = False , ** other_paras ) -> ViewMeta","title":"read()"},{"location":"md/data/dataset_example/#data.dataset_example.BopFormat.write","text":"write ( data_i : int , value : ViewMeta , * , force = False , ** other_paras )","title":"write()"},{"location":"md/data/dataset_example/#data.dataset_example.MutilMaskCluster","text":"Bases: UnifiedFileCluster [ MutilMaskFilesHandle , 'MutilMaskCluster', 'BopFormat', dict [ int , ndarray ]]","title":"MutilMaskCluster"},{"location":"md/data/dataset_example/#data.dataset_example.MutilMaskCluster.DEFAULT_APPENDNAMES_JOINER","text":"DEFAULT_APPENDNAMES_JOINER = '_'","title":"DEFAULT_APPENDNAMES_JOINER"},{"location":"md/data/dataset_example/#data.dataset_example.MutilMaskCluster.DEFAULT_READ_FUNC","text":"DEFAULT_READ_FUNC = cv2 . imread","title":"DEFAULT_READ_FUNC"},{"location":"md/data/dataset_example/#data.dataset_example.MutilMaskCluster.DEFAULT_SUFFIX","text":"DEFAULT_SUFFIX = '.png'","title":"DEFAULT_SUFFIX"},{"location":"md/data/dataset_example/#data.dataset_example.MutilMaskCluster.DEFAULT_WRITE_FUNC","text":"DEFAULT_WRITE_FUNC = cv2 . imwrite","title":"DEFAULT_WRITE_FUNC"},{"location":"md/data/dataset_example/#data.dataset_example.MutilMaskCluster.KW_ID_SEQ","text":"KW_ID_SEQ = 'id_seq'","title":"KW_ID_SEQ"},{"location":"md/data/dataset_example/#data.dataset_example.MutilMaskCluster.MULTI_FILES","text":"MULTI_FILES = True","title":"MULTI_FILES"},{"location":"md/data/dataset_example/#data.dataset_example.MutilMaskCluster._read","text":"Bases: _read ['MutilMaskCluster', dict [ int , ndarray ], MutilMaskFilesHandle ]","title":"_read"},{"location":"md/data/dataset_example/#data.dataset_example.MutilMaskCluster._read.gather_mutil_results","text":"gather_mutil_results ( results : list )","title":"gather_mutil_results()"},{"location":"md/data/dataset_example/#data.dataset_example.MutilMaskCluster._write","text":"Bases: _write ['MutilMaskCluster', dict [ int , ndarray ], MutilMaskFilesHandle ]","title":"_write"},{"location":"md/data/dataset_example/#data.dataset_example.MutilMaskCluster._write.split_value_as_mutil","text":"split_value_as_mutil ( core_values : dict [ int , np . ndarray ])","title":"split_value_as_mutil()"},{"location":"md/data/dataset_example/#data.dataset_example.MutilMaskCluster._set_rely","text":"_set_rely ( relied : DictLikeHandle , rlt : dict ) rlt = { \"scene_camera\": {KW_CAM_K: array, KW_cam_R_w2c: array, KW_cam_t_w2c: array, KW_CAM_DS:float} \"scene_gt\": [{KW_GT_R: array, KW_GT_t: array, KW_GT_ID: int}, ...] }","title":"_set_rely()"},{"location":"md/data/dataset_example/#data.dataset_example.MutilMaskFilesHandle","text":"Bases: UnifiedFilesHandle","title":"MutilMaskFilesHandle"},{"location":"md/data/dataset_example/#data.dataset_example.PostureDataset","text":"Bases: Mix_Dataset [ FCT , DST , VDST ]","title":"PostureDataset"},{"location":"md/data/dataset_example/#data.dataset_example.PostureDataset.POSTURE_SPLITER_NAME","text":"POSTURE_SPLITER_NAME = 'posture'","title":"POSTURE_SPLITER_NAME"},{"location":"md/data/dataset_example/#data.dataset_example.PostureDataset.POSTURE_SUBSETS","text":"POSTURE_SUBSETS = [ 'train' , 'val' ]","title":"POSTURE_SUBSETS"},{"location":"md/data/dataset_example/#data.dataset_example.PostureDataset.SPLIT_PARA","text":"SPLIT_PARA = Mix_Dataset . SPLIT_PARA . copy ()","title":"SPLIT_PARA"},{"location":"md/data/dataset_example/#data.dataset_example.PostureDataset.posture_spliter","text":"posture_spliter","title":"posture_spliter"},{"location":"md/data/dataset_example/#data.dataset_example.PostureDataset.posture_train_idx_array","text":"posture_train_idx_array","title":"posture_train_idx_array"},{"location":"md/data/dataset_example/#data.dataset_example.PostureDataset.posture_val_idx_array","text":"posture_val_idx_array","title":"posture_val_idx_array"},{"location":"md/data/dataset_example/#data.dataset_example.PostureDataset.split_for_posture","text":"split_for_posture ( ratio = 0.15 , source : list [ int ] = None ) Only take ratio of the real data as the verification set","title":"split_for_posture()"},{"location":"md/data/dataset_example/#data.dataset_example.VocFormat_6dPosture","text":"Bases: PostureDataset [ UnifiedFileCluster , 'VocFormat_6dPosture', ViewMeta ]","title":"VocFormat_6dPosture"},{"location":"md/data/dataset_example/#data.dataset_example.VocFormat_6dPosture.KW_IMGAE_DIR","text":"KW_IMGAE_DIR = 'images'","title":"KW_IMGAE_DIR"},{"location":"md/data/dataset_example/#data.dataset_example.VocFormat_6dPosture.default_spliter","text":"default_spliter","title":"default_spliter"},{"location":"md/data/dataset_example/#data.dataset_example.VocFormat_6dPosture.__init__","text":"__init__ ( directory , * , flag_name = '' , parent : DatasetNode = None ) -> None","title":"__init__()"},{"location":"md/data/dataset_example/#data.dataset_example.VocFormat_6dPosture.copy_from_simplified","text":"copy_from_simplified ( src_dataset : VocFormat_6dPosture , * , cover = False , force = False )","title":"copy_from_simplified()"},{"location":"md/data/dataset_example/#data.dataset_example.VocFormat_6dPosture.deserialize_mask_dict","text":"deserialize_mask_dict ( obj , mask_bytes_dict : dict [ int , bytes ])","title":"deserialize_mask_dict()"},{"location":"md/data/dataset_example/#data.dataset_example.VocFormat_6dPosture.file_to_cache_simple","text":"file_to_cache_simple ( * , force = False )","title":"file_to_cache_simple()"},{"location":"md/data/dataset_example/#data.dataset_example.VocFormat_6dPosture.get_default_set_of","text":"get_default_set_of ( data_i )","title":"get_default_set_of()"},{"location":"md/data/dataset_example/#data.dataset_example.VocFormat_6dPosture.init_clusters_hook","text":"init_clusters_hook ()","title":"init_clusters_hook()"},{"location":"md/data/dataset_example/#data.dataset_example.VocFormat_6dPosture.init_dataset_attr_hook","text":"init_dataset_attr_hook ()","title":"init_dataset_attr_hook()"},{"location":"md/data/dataset_example/#data.dataset_example.VocFormat_6dPosture.read","text":"read ( src : int , * , force = False , ** other_paras ) -> ViewMeta","title":"read()"},{"location":"md/data/dataset_example/#data.dataset_example.VocFormat_6dPosture.serialize_mask_dict","text":"serialize_mask_dict ( obj , mask_ndarray_dict : dict [ int , np . ndarray ])","title":"serialize_mask_dict()"},{"location":"md/data/dataset_example/#data.dataset_example.VocFormat_6dPosture.write","text":"write ( data_i : int , value : ViewMeta , * , force = False , ** other_paras )","title":"write()"},{"location":"md/data/dataset_example/#data.dataset_example.cxcywhLabelCluster","text":"Bases: IntArrayDictAsTxtCluster [ UnifiedFilesHandle , 'cxcywhLabelCluster', 'VocFormat_6dPosture']","title":"cxcywhLabelCluster"},{"location":"md/data/dataset_example/#data.dataset_example.cxcywhLabelCluster.KW_IMAGE_SIZE","text":"KW_IMAGE_SIZE = 'image_size'","title":"KW_IMAGE_SIZE"},{"location":"md/data/dataset_example/#data.dataset_example.cxcywhLabelCluster.KW_IO_RAW","text":"KW_IO_RAW = 'raw'","title":"KW_IO_RAW"},{"location":"md/data/dataset_example/#data.dataset_example.cxcywhLabelCluster._read","text":"Bases: _read ['cxcywhLabelCluster', dict [ int , ndarray ], UnifiedFilesHandle ]","title":"_read"},{"location":"md/data/dataset_example/#data.dataset_example.cxcywhLabelCluster._read.postprogress_value","text":"postprogress_value ( value : np . ndarray , * , image_size = None , ** other_paras )","title":"postprogress_value()"},{"location":"md/data/dataset_example/#data.dataset_example.cxcywhLabelCluster._write","text":"Bases: _write ['cxcywhLabelCluster', dict [ int , ndarray ], UnifiedFilesHandle ]","title":"_write"},{"location":"md/data/dataset_example/#data.dataset_example.cxcywhLabelCluster._write.preprogress_value","text":"preprogress_value ( value : dict [ int , np . ndarray ], * , image_size = None , ** other_paras )","title":"preprogress_value()"},{"location":"md/data/dataset_example/#data.dataset_example.cxcywhLabelCluster._normedcxcywh_2_x1y1x2y2","text":"_normedcxcywh_2_x1y1x2y2 ( bbox_2d , img_size ) bbox_2d: np.ndarray [..., (cx, cy, w, h)] img_size: (w, h)","title":"_normedcxcywh_2_x1y1x2y2()"},{"location":"md/data/dataset_example/#data.dataset_example.cxcywhLabelCluster._set_rely","text":"_set_rely ( relied : FilesCluster , rlt )","title":"_set_rely()"},{"location":"md/data/dataset_example/#data.dataset_example.cxcywhLabelCluster._x1y1x2y2_2_normedcxcywh","text":"_x1y1x2y2_2_normedcxcywh ( bbox_2d , img_size ) bbox_2d: np.ndarray [..., (x1, x2, y1, y2)] img_size: (w, h)","title":"_x1y1x2y2_2_normedcxcywh()"},{"location":"md/data/dataset_example/#data.dataset_example.cxcywhLabelCluster.init_attrs","text":"init_attrs ()","title":"init_attrs()"},{"location":"md/data/dataset_example/#data.dataset_example.cxcywhLabelCluster.read","text":"read ( src : int , * , sub_dir = None , image_size = None , force = False , ** other_paras ) -> dict [ int , np . ndarray ]","title":"read()"},{"location":"md/data/dataset_example/#data.dataset_example.cxcywhLabelCluster.write","text":"write ( data_i : int , value : dict [ int , np . ndarray ], * , sub_dir = None , image_size = None , force = False , ** other_paras )","title":"write()"},{"location":"md/data/dataset_format/","text":"dataset_format DCT module-attribute DCT = TypeVar ( 'DCT' , bound = '_DataCluster' ) DSNT module-attribute DSNT = TypeVar ( 'DSNT' , bound = 'DatasetNode' ) VDCT module-attribute VDCT = TypeVar ( 'VDCT' ) VDST module-attribute VDST = TypeVar ( 'VDST' ) ClusterDataIOError Bases: Exception __init__ __init__ ( * args : object ) -> None ClusterIONotExecutedWarning Bases: ClusterWarning __init__ __init__ ( * args : object ) -> None ClusterNotRecommendWarning Bases: ClusterWarning __init__ __init__ ( * args : object ) -> None ClusterParaWarning Bases: ClusterWarning __init__ __init__ ( * args : object ) -> None ClusterWarning Bases: Warning __init__ __init__ ( * args : object ) -> None DatasetFormat Bases: DatasetNode [ DCT , VDST ] Dataset Format A dataset manager, support mutiple data types. It is useful if you have a series of different data. For example, a sample contains an image and a set of bounding boxes. There is a one-to-one correspondence between them, and there are multiple sets of such data. properties inited : bool, if the dataset has been inited updated : bool, if the dataset has been updated, it can bes set. directory : str, the root directory of the dataset unfinished : bool, the last writing process of the dataset has not been completed clusters : list[_DataCluster], all clusters of the dataset opened_clusters : list[_DataCluster], all opened clusters of the dataset jsondict_map : dict[str, JsonDict], the map of jsondict elements_map : dict[str, Elements], the map of elements files_map : dict[str, FileCluster], the map of fileclusters data_num : int, the number of data in the dataset data_i_upper : int, the max index of the iterator virtual function read_one: Read one piece of data recommended to rewrite _init_clusters: init the clusters _write_jsondict: write one piece of data to jsondict _write_elementss: write one piece of data to elements _write_files: write one piece of data to files _update_dataset: update the dataset, it should be called when the dataset is updated not necessary to rewrite update_dataset: update the dataset, it should be called when the dataset is updated read_from_disk: read all data from disk as a generator write_to_disk: write one piece of data to disk start_writing: start writing stop_writing: stop writing clear: clear all data of the dataset close_all: close all clusters open_all : open all clusters set_all_readonly: set all file streams to read only set_all_writable: set all file streams to writable get_element_paths_of_one: get the paths of one piece of data getitem : get one piece of data setitem : set one piece of data iter : return the iterator of the dataset example read df1 = DatasetFormat(directory1) df2 = DatasetFormat(directory2) for data in self.read_from_disk(): ... write_to_disk : 1 df2.write_to_disk(data) \u00d7 this is wrong with df2.writer: # use context manager df2.write_to_disk(data) df2.clear() write_to_disk : 2 df2.start_writing() df2.write_to_disk(data) df2.stop_writing() write_one df2.write_one(data_i, data) ''' DEFAULT_SPLIT_TYPE class-attribute instance-attribute DEFAULT_SPLIT_TYPE = [ 'default' ] KW_TRAIN class-attribute instance-attribute KW_TRAIN = 'train' KW_VAL class-attribute instance-attribute KW_VAL = 'val' OVERVIEW class-attribute instance-attribute OVERVIEW = 'overview.json' SPLIT_DIR class-attribute instance-attribute SPLIT_DIR = 'ImageSets' default_train_idx_array property default_train_idx_array default_val_idx_array property default_val_idx_array split_default_rate instance-attribute split_default_rate = split_rate train_idx_array property train_idx_array val_idx_array property val_idx_array __init__ __init__ ( directory , split_rate = 0.75 , parent = None ) -> None init_dataset_attr_hook init_dataset_attr_hook () process_unfinished process_unfinished () stop_writing stop_writing () DatasetNode Bases: InstanceRegistry , WriteController , ABC , Generic [ DCT , VDST ] DatasetNode, only gather the clusters. have no i/o operations WRITING_MARK class-attribute instance-attribute WRITING_MARK = '.dfsw' clusters property clusters : list [ DCT ] data_clusters property data_clusters : list [ DCT ] data_i_upper property data_i_upper data_num property data_num elements_map property elements_map select the key-value pair whose value is Elements filecluster_map property filecluster_map select the key-value pair whose value is FileCluster inited property inited jsondict_map property jsondict_map select the key-value pair whose value is JsonDict opened_clusters property opened_clusters opened_data_clusters property opened_data_clusters parent_directory property parent_directory updated property writable updated __getitem__ __getitem__ ( data_i : Union [ int , slice ]) -> Union [ Generator [ VDST , Any , None ], VDST ] __init__ __init__ ( directory , parent : DatasetNode = None ) -> None __iter__ __iter__ () __len__ __len__ () __setattr__ __setattr__ ( name , value ) __setitem__ __setitem__ ( data_i : int , value ) _init_clusters _init_clusters () _init_identity_paramenter _init_identity_paramenter ( directory , * args , ** kwargs ) _update_dataset _update_dataset ( data_i = None ) _write_elements _write_elements ( data_i , data , subdir = '' , appname = '' ) _write_files _write_files ( data_i , data ) _write_jsondict _write_jsondict ( data_i , data ) add_child add_child ( child_node : DatasetNode ) calc_overview calc_overview ( data_i ) clear clear ( ignore_warning = False , force = False ) brief clear all data, defalut to ask before executing clear_invalid_data_i clear_invalid_data_i () close_all close_all ( value = True ) copyto copyto ( dst : str , asroot = True , cover = False ) gen_identity_string classmethod gen_identity_string ( directory , * args , ** kwargs ) get_all_clusters get_all_clusters ( _type : Union [ type , tuple [ type ]] = None , only_opened = False ) -> _ClusterMap [ DCT ] get_element_paths_of_one get_element_paths_of_one ( data_i : int ) brief get all paths of a data get_writing_mark_file get_writing_mark_file () identity_string identity_string () init_dataset_attr_hook init_dataset_attr_hook () init_overview init_overview () items items () keys keys () load_overview load_overview () move_node move_node ( new_parent : DatasetNode ) open_all open_all ( value = True ) parse_identity_string staticmethod parse_identity_string ( identity_string : str ) process_unfinished process_unfinished () read_from_disk read_from_disk ( with_data_i = False ) brief *generator Since the amount of data may be large, return one by one read_one abstractmethod read_one ( data_i , ** kwargs ) -> VDST remove_child remove_child ( child_node : DatasetNode ) remove_one remove_one ( data_i , * args , ** kwargs ) save_elements_data_info_map save_elements_data_info_map () save_overview save_overview () set_all_overwrite_allowed set_all_overwrite_allowed ( value = True ) set_all_readonly set_all_readonly ( value = True ) set_all_writable set_all_writable ( value = True ) set_elements_cache_priority set_elements_cache_priority ( mode : bool ) start_writing start_writing ( overwrite_allowed = False ) stop_writing stop_writing () update_dataset update_dataset ( data_i = None , f = False ) values values () write_one write_one ( data_i , data : VDST , ** kwargs ) write_to_disk write_to_disk ( data : VDST , data_i =- 1 ) brief write elements immediately, write basejsoninfo to cache, they will be dumped when exiting the context of self.writer NOTE For DatasetFormat, the write mode has only 'append'. If you need to modify, please call 'DatasetFormat.clear' to clear all data, and then write again. Elements Bases: _DataCluster [ DSNT , VDCT , 'Elements'] elements manager Returns None if accessing an data_id that does not exist will not write if the element is None it can be used as an iterator, the iterator will return (data_id, element) attr see _DataCluster * readfunc: Callable, how to read one element from disk, the parameter must be (path) * writefunc: Callable, how to write one element to disk, the parameter must be (path, element) * suffix: str, the suffix of the file * filllen: int, to generate the store path * fillchar: str, to generate the store path * _data_i_dir_map: dict[int, str], the map of data_id and directory name * data_i_upper: int, the max index of the iterator method len : return the number of elements iter : return the iterator next : return the next element read: read one element from disk with the logic of self.readfunc write: write one element to disk with the logic of self.writefunc format_path: format the path of the element clear: clear all data of the dict and clear directory APPNAMES_MAP_FILE class-attribute instance-attribute APPNAMES_MAP_FILE = 'data_i_appnames.elmm' CACHE_FILE class-attribute instance-attribute CACHE_FILE = 'cache.elmcache' DATA_INFO_MAP_FILE class-attribute instance-attribute DATA_INFO_MAP_FILE = 'data_info_map.elmm' DIR_MAP_FILE class-attribute instance-attribute DIR_MAP_FILE = 'data_i_dir_map.elmm' WRITING_MARK class-attribute instance-attribute WRITING_MARK = '.elmsw' _DCT class-attribute instance-attribute _DCT = TypeVar ( '_DCT' , bound = 'Elements' ) _VDCT class-attribute instance-attribute _VDCT = TypeVar ( '_VDCT' ) data_info_map property data_info_map DataInfoDict Bases: dict [ str , Union [ str , list , bool ]] appnames property writable appnames : tuple [ str ] cache property cache dir property writable dir : str empty property empty file_exist property writable file_exist has_cache property has_cache has_file property has_file : bool has_notfound property has_notfound __init__ __init__ ( * args , ** kwargs ) add_file add_file ( appname ) clear_notfound clear_notfound ( idx ) erase_cache erase_cache () get_cache get_cache () get_file_exist get_file_exist ( appname ) refresh_has_file refresh_has_file ( elem : Elements , data_i : int ) remove_file remove_file ( appname ) set_cache set_cache ( cache ) sort sort () DataInfoMap Bases: dict [ int , DataInfoDict ] directory instance-attribute directory = self . elements . directory elements instance-attribute elements = elmm path instance-attribute path = os . path . join ( self . elements . directory , self . elements . DATA_INFO_MAP_FILE ) __init__ __init__ ( elmm : Elements , * args , ** kwargs ) add_appname add_appname ( data_i , appname ) add_info add_info ( data_i , subdir , appnames : list [ str ] = None ) load staticmethod load ( elmm : Elements ) rebuild rebuild ( ignore_notfound = False ) remove_info remove_info ( data_i ) save save () _change_dir Bases: _WriteMeta [ _DCT , _VDCT ] IO_TYPE class-attribute instance-attribute IO_TYPE = WriteController . LOG_OPERATION __call__ __call__ ( data_i : int , dst_dir : str , * args , force = False , ** kwargs ) -> Any _call _call ( data_i : int , dst_dir : str , ** kwargs : Any ) check_key check_key ( key , ** kwargs ) -> bool check_value check_value ( value : str , ** kwargs ) -> bool is_overwriting is_overwriting ( data_i , value , ** kwargs ) _load_in Bases: _load_in [ _DCT , _VDCT ] __call__ __call__ ( data_i , value : VDCT , subdir = '' , * args , force = False , ** kwargs ) -> Any _call _call ( src : list [ str ], dst : int , subdir = '' , ** kwargs : Any ) check_key check_key ( src : list [ str ], ** kwargs ) -> bool check_value check_value ( dst : int , ** kwargs ) -> bool _move Bases: _move [ _DCT , _VDCT ] _call _call ( src : int , dst : int , * args , ** kwargs ) check_key check_key ( key , ** kwargs ) -> bool check_value check_value ( value , ** kwargs ) -> bool _read Bases: _read [ _DCT , _VDCT ] _call _call ( data_i , ** kwargs : Any ) _read_from_cache _read_from_cache ( data_i , ** kwargs ) _read_from_file _read_from_file ( data_i , ** kwargs ) _remove Bases: _remove [ _DCT , _VDCT ] _call _call ( data_i , value , ** kwargs : Any ) _write Bases: _write [ _DCT , _VDCT ] __call__ __call__ ( data_i , value : VDCT , subdir = '' , * args , force = False , ** kwargs ) -> Any _call _call ( data_i , value : VDCT , subdir = '' , ** kwargs : Any ) check_key check_key ( data_i , ** kwargs ) -> bool __getitem__ __getitem__ ( idx ) __init__ __init__ ( dataset_node : DSNT , sub_dir , register = True , name = '' , read_func : Callable = lambda : None , write_func : Callable = lambda , : None , suffix : str = '.txt' , filllen = 6 , fillchar = '0' , * , alternative_suffix : list [ str ] = []) -> None __iter__ __iter__ () __len__ __len__ () Count the total number of files in the directory __setitem__ __setitem__ ( idx , value ) _init_attr _init_attr ( read_func , write_func , suffix , filllen , fillchar , alternative_suffix = [], * args , ** kwargs ) _open _open () _stop_writing _stop_writing () _update_cluster_all _update_cluster_all ( * args , ** kwargs ) _update_cluster_inc _update_cluster_inc ( iometa : _IOMeta , data_i , value , subdir = '' , * args , ** kwargs ) auto_path auto_path ( data_i , _subdir = None , _appname = None , return_app = False , allow_mutil_appendname = True ) -> Union [ list [ str ], tuple [ str , list [ str ]]] auto find the path of data_i. if data_i has multiple appnames, raise IndexError if return_app is True, return subdir, appname, else return path if allow_mutil_appendname is True, the type of appname will be list[str], else str; and the type of path will be list[str], else str cache_to_data_info_map cache_to_data_info_map ( save = True , ** kwargs ) check_storage check_storage () clear_files_with_cache clear_files_with_cache () construct_value_func construct_value_func ( appnames : list [ str ], values : list ) -> VDCT copyto copyto ( dst : str , * args , ** kwargs ) format_base_name format_base_name ( data_i ) format_path format_path ( data_i , subdir = '' , appname = '' , directory = None , ** kwargs ) format the path of data_i get_file_path get_file_path ( data_i , * args , ** kwargs ) has_file_of has_file_of ( data_i , subdir , appname ) items items () keys keys () brief return a generator of data_i * Elements is not a dict, so it can't be used as a dict. parse_appnames_func parse_appnames_func ( value ) parse_path staticmethod parse_path ( directory , path : str ) parse the path to get data_i, subdir, appname, it is the reverse operation of format_path process_unfinished process_unfinished () save_data_info_map save_data_info_map ( ** kwargs ) unzip_cache unzip_cache ( force = False , ** kwargs ) unzip the cache to a dict values values () ElementsAmbiguousError Bases: ValueError __init__ __init__ ( * args : object ) -> None FileCluster Bases: _DataCluster [ DSNT , VDCT , 'FileCluster'] a cluster of multiple files, they may have different suffixes and i/o operations but they must be read/write together SingleFile class-attribute instance-attribute SingleFile = SingleFile all_exist property all_exist _load_in Bases: _load_in ['FileCluster', VDCT ] , Generic [ VDCT ] _call _call ( src_path : str , dst : int , ** kwargs : Any ) check_key check_key ( src : str , ** kwargs ) -> bool check_value check_value ( dst : int , ** kwargs ) -> bool _move Bases: _move ['FileCluster', VDCT ] , Generic [ VDCT ] __call__ __call__ ( src : int , dst : int , * args , force = False , ** kwargs ) _call _call ( key , value , ** kwargs : Any ) _read Bases: _read ['FileCluster', VDCT ] , Generic [ VDCT ] _call _call ( data_i , ** kwargs : Any ) -> VDCT _remove Bases: _remove ['FileCluster', VDCT ] , Generic [ VDCT ] _call _call ( data_i , ** kwargs : Any ) _write Bases: _write ['FileCluster', VDCT ] , Generic [ VDCT ] _call _call ( data_i , value : VDCT ) is_overwriting is_overwriting ( data_i , value , subdir = '' , ** kwargs ) __init__ __init__ ( dataset_node : DSNT , sub_dir , register = True , name = '' , singlefile_list : list [ SingleFile ] = []) -> None __len__ __len__ () _init_attr _init_attr ( singlefile : list [ SingleFile ], * args , ** kwargs ) _make_continuous _make_continuous ( * args , ** kwargs ) copyto copyto ( dst : str , cover = False , * args , ** kwargs ) filter_data_i filter_data_i ( data_i , return_index = False ) get_file get_file ( idx : Union [ int , str ]) get_file_path get_file_path ( data_i , * args , ** kwargs ) items items () keys keys () merge_from merge_from ( src : FileCluster , merge_funcs : Union [ list , Callable ] = [], * args , ** kwargs ) paths paths () read_all read_all () remove_file remove_file ( idx : Union [ int , str ]) update_file update_file ( singlefile : SingleFile ) values values () -> list [ SingleFile [ VDCT ]] write_all write_all ( values ) InstanceRegistry Bases: ABC _InstanceRegistry_inited instance-attribute _InstanceRegistry_inited = True _cluster_registry class-attribute instance-attribute _cluster_registry = {} _dataset_registry class-attribute instance-attribute _dataset_registry = {} _registry class-attribute instance-attribute _registry : dict = None __init__ __init__ () -> None __init_subclass__ __init_subclass__ ( ** kwargs ) -> None __new__ __new__ ( * args , ** kwargs ) _init_identity_paramenter abstractmethod _init_identity_paramenter () gen_identity_string abstractmethod classmethod gen_identity_string ( * args , ** kwargs ) identity_string abstractmethod identity_string () parse_identity_string abstractmethod staticmethod parse_identity_string ( identity_string ) IntArrayDictElement Bases: Elements [ DSNT , dict [ int , ndarray ]] array_fmt instance-attribute array_fmt = array_fmt if array_fmt else ' %.4f ' array_shape instance-attribute array_shape : tuple [ int ] = array_shape __init__ __init__ ( dataset_node : DSNT , sub_dir : str , array_shape : tuple [ int ], array_fmt : str = '' , register = True , name = '' , filllen = 6 , fillchar = '0' ) -> None _from_dict _from_dict ( dict_ : dict [ int , np . ndarray ]) dict_: dict[int, np.ndarray] _read_format _read_format ( array : np . ndarray , ** kwargs ) _read_func _read_func ( path , ** kwargs ) _to_dict _to_dict ( array : np . ndarray ) -> dict [ int , np . ndarray ] array: np.ndarray [N, 5] _write_format _write_format ( array : np . ndarray , ** kwargs ) _write_func _write_func ( path , intarraydict : dict [ int , np . ndarray ], ** kwargs ) JsonDict Bases: _DataCluster [ DSNT , VDCT , 'JsonDict'] , dict dict for base json it is a subclass of dict, so it can be used as a dict returns None if accessing an key that does not exist attr see _DataCluster method see _DataCluster * clear: clear all data of the dict and clear the json file SAVE_AFTER_CLOSE class-attribute instance-attribute SAVE_AFTER_CLOSE = 1 SAVE_IMMIDIATELY class-attribute instance-attribute SAVE_IMMIDIATELY = 0 SAVE_STREAMLY class-attribute instance-attribute SAVE_STREAMLY = 2 save_mode property writable save_mode write_streamly property write_streamly _Placeholder __init__ __init__ () -> None __init__ __init__ ( dataset_node : DSNT , sub_dir , register = True , name = '' , * args , ** kwargs ) __iter__ __iter__ () -> Iterator __len__ __len__ () -> int _clear _clear ( * args , ** kwargs ) _copyto _copyto ( dst : str , * args , ** kwargs ) _init_attr _init_attr ( * args , ** kwargs ) _make_continuous _make_continuous ( * args , ** kwargs ) _merge_one _merge_one ( src : JsonDict , k , * args , ** kwargs ) _read _read ( data_i , ** kwargs ) _remove _remove ( data_i , * args , ** kwargs ) _stop_writing _stop_writing () rewrite the method of WriteController _write _write ( data_i , value , ** kwargs ) items items () keys keys () reload reload ( value = {}) save save () sort sort ( * args , ** kwargs ) sort by keys start_writing start_writing ( overwrite_allowed = False ) rewrite the method of WriteController stop_writing stop_writing () rewrite the method of WriteController update update ( _m : Union [ dict , Iterable [ tuple ]] = None , ** kwargs ) values values () LinemodFormat Bases: PostureDatasetFormat DEPTH_DIR class-attribute instance-attribute DEPTH_DIR = 'depth' GT_CAM_FILE class-attribute instance-attribute GT_CAM_FILE = 'scene_camera.json' GT_FILE class-attribute instance-attribute GT_FILE = 'scene_gt.json' GT_INFO_FILE class-attribute instance-attribute GT_INFO_FILE = 'scene_gt_info.json' KW_CAM_DS class-attribute instance-attribute KW_CAM_DS = 'depth_scale' KW_CAM_K class-attribute instance-attribute KW_CAM_K = 'cam_K' KW_CAM_VL class-attribute instance-attribute KW_CAM_VL = 'view_level' KW_GT_ID class-attribute instance-attribute KW_GT_ID = 'obj_id' KW_GT_INFO_BBOX_OBJ class-attribute instance-attribute KW_GT_INFO_BBOX_OBJ = 'bbox_obj' KW_GT_INFO_BBOX_VIS class-attribute instance-attribute KW_GT_INFO_BBOX_VIS = 'bbox_visib' KW_GT_INFO_PX_COUNT_ALL class-attribute instance-attribute KW_GT_INFO_PX_COUNT_ALL = 'px_count_all' KW_GT_INFO_PX_COUNT_VIS class-attribute instance-attribute KW_GT_INFO_PX_COUNT_VIS = 'px_count_visib' KW_GT_INFO_PX_COUNT_VLD class-attribute instance-attribute KW_GT_INFO_PX_COUNT_VLD = 'px_count_valid' KW_GT_INFO_VISIB_FRACT class-attribute instance-attribute KW_GT_INFO_VISIB_FRACT = 'visib_fract' KW_GT_R class-attribute instance-attribute KW_GT_R = 'cam_R_m2c' KW_GT_t class-attribute instance-attribute KW_GT_t = 'cam_t_m2c' MASK_DIR class-attribute instance-attribute MASK_DIR = 'mask' RGB_DIR class-attribute instance-attribute RGB_DIR = 'rgb' _MasksElements Bases: Elements ['LinemodFormat', dict [ int , ndarray ]] _read _read ( data_i , ** kwargs ) -> dict [ int , np . ndarray ] _write _write ( data_i , value : dict [ int , ndarray ], subdir = '' , appname = '' , ** kwargs ) id_format id_format ( class_id ) _init_clusters _init_clusters () _write_elements _write_elements ( data_i : int , viewmeta : ViewMeta , subdir = '' , appname = '' ) _write_jsondict _write_jsondict ( data_i : int , viewmeta : ViewMeta ) read_one read_one ( data_i , ** kwargs ) Mix_VocFormat Bases: VocFormat BASIS_SUBSETS class-attribute instance-attribute BASIS_SUBSETS = [ 'basic' , 'augment' ] DEFAULT_SPLIT_TYPE class-attribute instance-attribute DEFAULT_SPLIT_TYPE = [ 'default' , 'posture' , 'reality' , 'basis' ] IMGAE_DIR class-attribute instance-attribute IMGAE_DIR = 'images' MODE_DETECTION class-attribute instance-attribute MODE_DETECTION = 0 MODE_POSTURE class-attribute instance-attribute MODE_POSTURE = 1 REALITY_SUBSETS class-attribute instance-attribute REALITY_SUBSETS = [ 'real' , 'sim' ] basis_spliter property basis_spliter default_spliter property default_spliter posture_spliter property posture_spliter posture_train_idx_list property posture_train_idx_list posture_val_idx_list property posture_val_idx_list reality_spliter property reality_spliter spliter_name instance-attribute spliter_name = self . DEFAULT_SPLIT_TYPE [ 1 ] __init__ __init__ ( directory , split_rate = 0.75 , parent = None ) -> None _init_clusters _init_clusters () gen_posture_log gen_posture_log ( ratio = 0.15 , source : list [ int ] = None ) Only take ratio of the real data as the verification set record_data_type record_data_type ( data_i , is_real , is_basic ) PostureDatasetFormat Bases: DatasetFormat [ _DataCluster , ViewMeta ] _init_clusters _init_clusters () _write_elements _write_elements ( data_i : int , viewmeta : ViewMeta , subdir = '' , appname = '' ) calc_by_base calc_by_base ( mesh_dict : dict [ int , MeshMeta ], overwitre = False ) brief calculate data by base data, see ViewMeta.calc_by_base read_one read_one ( data_i , ** kwargs ) SingleFile Bases: Generic [ VDCT ] cluster instance-attribute cluster : FileCluster = None exist property exist path property path read_func instance-attribute read_func : Callable = read_func sub_path instance-attribute sub_path = sub_path write_func instance-attribute write_func : Callable = write_func __init__ __init__ ( sub_path : str , read_func : Callable , write_func : Callable ) -> None new_json_singlefile staticmethod new_json_singlefile ( sub_path : str ) new_npy_singlefile staticmethod new_npy_singlefile ( sub_path : str ) new_pickle_singlefile staticmethod new_pickle_singlefile ( sub_path : str ) new_txt_singlefile staticmethod new_txt_singlefile ( sub_path : str ) read read () -> VDCT set_cluster set_cluster ( cluster : FileCluster ) write write ( data ) Spliter Bases: FileCluster ['SpliterGroup', list [ int ]] SPLIT_FILE class-attribute instance-attribute SPLIT_FILE = 'split.json' SPLIT_FOR_DATATYPE class-attribute instance-attribute SPLIT_FOR_DATATYPE = 1 SPLIT_FOR_FILE class-attribute instance-attribute SPLIT_FOR_FILE = '__split_for.txt' SPLIT_FOR_TRAINING class-attribute instance-attribute SPLIT_FOR_TRAINING = 0 SPLIT_MODE_BASE class-attribute instance-attribute SPLIT_MODE_BASE = 'base' active_split property active_split data property data default_subsets property default_subsets exclusive property writable exclusive split_file instance-attribute split_file = SingleFile [ dict [ str , dict [ str , list [ int ]]]]( self . SPLIT_FILE , partial ( JsonIO . load_json , cvt_list_to_array = False ), partial ( JsonIO . dump_json , regard_list_as_array = True )) split_for instance-attribute split_for = self . split_for_file . read () split_for_file instance-attribute split_for_file = SingleFile [ tuple [ int , list [ str ]]]( self . SPLIT_FOR_FILE , self . load_split_for_info_func , self . save_split_for_info_func ) split_mode property writable split_mode split_mode_list property split_mode_list split_table instance-attribute split_table = self . SpliterTable ( self ) spliter_name property spliter_name subset_fileobjs_dict property subset_fileobjs_dict : dict [ str , SingleFile [ list [ int ]]] subsets property subsets total_num property total_num SpliterTable Bases: Table [ str , str , list [ int ]] spliter instance-attribute spliter = spliter __init__ __init__ ( spliter : Spliter ) __str__ __str__ () -> str gen_default_value gen_default_value () -> list [ int ] get_base_filter get_base_filter () qurey qurey ( data_i : int , return_key : bool = False ) __getitem__ __getitem__ ( key ) __init__ __init__ ( dataset_node : SpliterGroup , sub_dir : str , split_for = None , default_subsets : list = [], register = True , name = '' ) -> None add_split_mode add_split_mode ( mode : str , exist_ok : bool = False ) clear_idx clear_idx () gen_split staticmethod gen_split ( data_num : Union [ int , Iterable ], split_rate : Union [ float , Iterable [ float ], dict [ str , float ]], split_num : int ) get_idx_list get_idx_list ( subset : Union [ str , int ], split_mode = None ) -> list [ int ] get_one_subset get_one_subset ( data_i ) get_split get_split ( split_mode ) load load () load_split_for_info_func load_split_for_info_func ( path : str ) loadsplittxt_func loadsplittxt_func ( path : str ) print print () process_split_rate staticmethod process_split_rate ( split_rate : Union [ float , Iterable [ float ], dict [ str , float ]], split_num : Union [ int , list [ str ]]) read_idx_list read_idx_list ( subset : Union [ str , int ], split_mode = None ) -> tuple [ int ] remove_one remove_one ( idx ) remove_split_mode remove_split_mode ( mode : str , not_exist_ok : bool = False ) save save () save_split_for_info_func save_split_for_info_func ( path : str , value : int ) set_default_subsets set_default_subsets ( value : Union [ str , Iterable [ str ]]) set_exclusive set_exclusive ( value : bool ) set_one set_one ( data_i , subset , split_mode = None , sort = False ) set_one_by_rate set_one_by_rate ( data_i , split_rate , split_mode = None ) set_split_mode set_split_mode ( split_mode : int ) sort_all sort_all () SpliterGroup Bases: DatasetNode [ Spliter , VDST ] DEFAULT_SPLIT_TYPE class-attribute instance-attribute DEFAULT_SPLIT_TYPE = [ 'default' ] cluster_map instance-attribute cluster_map : _ClusterMap [ Spliter ] = self . cluster_map cur_spliter_name property writable cur_spliter_name cur_training_spliter property cur_training_spliter split_subdir property split_subdir spliter_name_list property spliter_name_list __getitem__ __getitem__ ( key ) __init__ __init__ ( directory , spliter_name_list : list , parent = None ) -> None _init_clusters _init_clusters () query_datatype_set query_datatype_set ( data_i : int ) -> dict [ str , Table [ str , str , bool ]] query_set query_set ( data_i : int , split_for : int = None ) -> dict [ str , Table [ str , str , bool ]] query_training_set query_training_set ( data_i ) -> dict [ str , Table [ str , str , bool ]] read_one read_one ( data_i , ** kwargs ) -> VDST record_set record_set ( data_i : int , set_ : dict [ str , Table [ str , str , bool ]]) remove_one remove_one ( idx ) save save () set_cur_spliter_name set_cur_spliter_name ( spliter_name : str ) VocFormat Bases: PostureDatasetFormat IMGAE_DIR class-attribute instance-attribute IMGAE_DIR = 'images' cxcywhLabelElement Bases: IntArrayDictElement default_image_size instance-attribute default_image_size = None skip instance-attribute skip = False _read Bases: _read cluster instance-attribute cluster : VocFormat . cxcywhLabelElement = cluster __call__ __call__ ( data_i , * args , force = False , image_size = None , ** kwargs : Any ) __init__ __init__ ( cluster ) -> None _call _call ( data_i , * , image_size = None , ** kwargs : Any ) _write Bases: _write cluster instance-attribute cluster : VocFormat . cxcywhLabelElement = cluster __call__ __call__ ( data_i , labels_dict : dict [ int , np . ndarray ], subdir = '' , * args , force = False , image_size = None , ** kwargs ) __init__ __init__ ( cluster ) -> None _call _call ( data_i , labels_dict : dict [ int , np . ndarray ], subdir = '' , * , image_size = None , ** kwargs ) __init__ __init__ ( dataset_node : Any , sub_dir : str , array_fmt : str = '' , register = True , name = '' , filllen = 6 , fillchar = '0' ) -> None _read_format _read_format ( labels : np . ndarray , image_size = None ) _reset_trigger _reset_trigger () _write_format _write_format ( labels : np . ndarray , image_size = None ) skip_once skip_once () __init__ __init__ ( directory , split_rate = 0.25 , parent = None ) -> None _init_clusters _init_clusters () _normedcxcywh_2_x1y1x2y2 staticmethod _normedcxcywh_2_x1y1x2y2 ( bbox_2d , img_size ) bbox_2d: np.ndarray [..., (cx, cy, w, h)] img_size: (w, h) _write_elements _write_elements ( data_i : int , viewmeta : ViewMeta , subdir = '' , appname = '' ) _x1y1x2y2_2_normedcxcywh staticmethod _x1y1x2y2_2_normedcxcywh ( bbox_2d , img_size ) bbox_2d: np.ndarray [..., (x1, x2, y1, y2)] img_size: (w, h) decide_default_set decide_default_set ( data_i ) get_default_set get_default_set ( data_i ) read_one read_one ( data_i , ** kwargs ) -> ViewMeta save_elements_data_info_map save_elements_data_info_map () synchronize_default_split synchronize_default_split () WriteController Bases: ABC control the write operation. the subclass of WriteController must implement : * start_writing * stop_writing LOG_APPEND class-attribute instance-attribute LOG_APPEND = 0 LOG_CHANGE class-attribute instance-attribute LOG_CHANGE = 2 LOG_KN class-attribute instance-attribute LOG_KN = [ LOG_APPEND , LOG_REMOVE , LOG_CHANGE , LOG_MOVE , LOG_OPERATION ] LOG_MOVE class-attribute instance-attribute LOG_MOVE = 3 LOG_OPERATION class-attribute instance-attribute LOG_OPERATION = 4 LOG_READ class-attribute instance-attribute LOG_READ = - 1 LOG_REMOVE class-attribute instance-attribute LOG_REMOVE = 1 WRITING_MARK class-attribute instance-attribute WRITING_MARK = '.writing' is_writing instance-attribute is_writing = False writer property writer __init__ __init__ () -> None get_writing_mark_file abstractmethod get_writing_mark_file () -> str load_from_mark_file load_from_mark_file () log_to_mark_file log_to_mark_file ( log_type , data_i , value = None ) mark_exist mark_exist () remove_mark remove_mark () start_writing start_writing ( overwrite_allowed = False ) stop_writing stop_writing () _ClusterMap Bases: dict [ str , DCT ] dataset_node instance-attribute dataset_node = dataset_node __init__ __init__ ( dataset_node : DatasetNode , * args , ** kwargs ) -> None __setitem__ __setitem__ ( __key : Any , __value : Any ) -> None _search_func staticmethod _search_func ( indetity_string : str ) add_cluster add_cluster ( cluster : DCT ) get_keywords get_keywords () remove_cluster remove_cluster ( cluster : DCT ) search search ( __key : Any , return_index = False ) setdefault setdefault ( __key : Any , __default : Any = ... ) -> Any update update ( __m , ** kwargs : Any ) -> None _DataCluster Bases: WriteController , InstanceRegistry , ABC , Generic [ DSNT , VDCT , DCT ] This is a private class representing a data cluster used for managing datasets with a specific format. attr self.dataset_node: DatasetNode self.closed: bool, Control the shielding of reading and writing, if it is true, the instance will not write, and the read will get None register: bool, whether to register to dataset_node _unfinished: bool, whether the data is unfinished _closed: bool, Indicates whether the cluster is closed or open. _readonly: bool, Indicates whether the cluster is read-only or write-enabled. changes_unsaved: bool, Indicates if any changes have been made to the cluster. directory: str, Directory path for the cluster. property overwrite_allowed: bool, Control the shielding of writing, cluster_data_num: int, the number of data in the cluster cluster_data_i_upper: int, the upper of the iterator, it is the max index of the iterator + 1 changed_since_opening: bool, Indicates whether the cluster has been modified since last opening. method abstract method: len : return the number of data in the cluster keys: return the keys of the cluster values: return the values of the cluster items: return the items of the cluster(key and value) _read: read data from the cluster _write: write data to the cluster _clear: clear all data of the cluster _copyto: copy the cluster to dst _merge: merge the cluster to self, the cluster must has the same type as self recommend to implement: _init_attr: initialize additional attributes specified by subclasses. _update_cluster_inc: update the incremental modification of the cluster after writing _update_cluster_all: update the state of the cluster after writing getitem : return the value of the key setitem : set the value of the key _open: operation when open the cluster _close: operation when close the cluster _start_writing: operation when start writing _stop_writing: operation when stop writing check_key: check if the key is valid not need to implement: iter : return the iterator of the cluster open: open the cluster for operation. close: close the cluster, preventing further operations. is_close: check if the cluster is closed. set_readonly: set the cluster as read-only or write-enabled. set_writable: set the cluster as writable or read-only. set_overwrite_allowed: set the cluster as writable or read-only. is_readonly: check if the cluster is read-only. is_writeable: check if the cluster is writable. is_overwrite_allowed: check if the cluster is writable. _read_decorator: decorator function to handle reading operations when the cluster is closed. _write_decorator: decorator function to handle writing operations when the cluster is closed or read-only. clear: clear any data in the cluster. Subclasses may implement _clear. read: read data from the cluster. Subclasses must implement _read. write: write data to the cluster. Subclasses must implement _write. copyto: copy the cluster to dst merge: merge the cluster to self, the cluster must has the same type as self start_writing: start writing stop_writing: stop writing repr : return the representation of the cluster register_to_format: register the cluster to dataset_node _DCT class-attribute instance-attribute _DCT = TypeVar ( '_DCT' , bound = '_DataCluster' ) _VDCT class-attribute instance-attribute _VDCT = TypeVar ( '_VDCT' ) _changed instance-attribute _changed = False _data_i_upper instance-attribute _data_i_upper = 0 _error_to_load instance-attribute _error_to_load = False _unfinished instance-attribute _unfinished = self . mark_exist () _unfinished_operation instance-attribute _unfinished_operation = self . dataset_node . _unfinished_operation changed_since_opening property writable changed_since_opening Indicates whether the cluster has been modified since last opening. cluster_data_i_upper property cluster_data_i_upper cluster_data_num property cluster_data_num continuous property continuous dataset_node instance-attribute dataset_node : DSNT = dataset_node directory instance-attribute directory = os . path . normpath ( os . path . join ( self . dataset_node . directory , self . sub_dir )) name instance-attribute name = name overwrite_allowed property overwrite_allowed Property that returns whether the cluster format allows write operations. register instance-attribute register = register sub_dir instance-attribute sub_dir = os . path . normpath ( sub_dir ) _Force force instance-attribute force = force obj instance-attribute obj : _DataCluster = obj orig_closed instance-attribute orig_closed = None orig_overwrite_allowed instance-attribute orig_overwrite_allowed = None orig_readonly instance-attribute orig_readonly = None writing instance-attribute writing = writing __enter__ __enter__ () __exit__ __exit__ ( exc_type , exc_value , traceback ) __init__ __init__ ( obj , force = False , writing = False ) -> None _load_in Bases: _WriteMeta [ _DCT , _VDCT ] IO_TYPE class-attribute instance-attribute IO_TYPE = WriteController . LOG_APPEND __call__ __call__ ( src , dst , * args , force = False , ** kwargs ) -> Any check_value check_value ( dst , ** kwargs ) -> bool is_overwriting is_overwriting ( src , dst , ** kwargs ) _move Bases: _WriteMeta [ _DCT , _VDCT ] IO_TYPE class-attribute instance-attribute IO_TYPE = WriteController . LOG_MOVE __call__ __call__ ( src , dst , * args , force = False , ** kwargs ) -> Any check_key check_key ( key , ** kwargs ) -> bool check_value check_value ( value , ** kwargs ) -> bool is_overwriting is_overwriting ( data_i , value , ** kwargs ) _read Bases: _ReadMeta [ _DCT , _VDCT ] check_key check_key ( key , ** kwargs ) -> bool _remove Bases: _WriteMeta [ _DCT , _VDCT ] IO_TYPE class-attribute instance-attribute IO_TYPE = WriteController . LOG_REMOVE __call__ __call__ ( key , * args , force = False , ** kwargs ) -> Any check_key check_key ( key , ** kwargs ) -> bool is_overwriting is_overwriting ( data_i , value , ** kwargs ) _write Bases: _WriteMeta [ _DCT , _VDCT ] IO_TYPE class-attribute instance-attribute IO_TYPE = WriteController . LOG_APPEND is_overwriting is_overwriting ( data_i , value , ** kwargs ) __getitem__ __getitem__ ( data_i : Union [ int , slice ]) __init__ __init__ ( dataset_node : DSNT , sub_dir : str , register = True , name = '' , * args , ** kwargs ) -> None Initialize the data cluster with the provided dataset_node, sub_dir, and registration flag. __iter__ __iter__ () -> Iterable [ VDCT ] __len__ abstractmethod __len__ () Returns the number of data in the cluster. __repr__ __repr__ () __setitem__ __setitem__ ( data_i , value : VDCT ) _close _close () _init_attr _init_attr ( * args , ** kwargs ) Method to initialize additional attributes specified by subclasses. _init_identity_paramenter _init_identity_paramenter ( dataset_node : DSNT , sub_dir : str , register = True , name = '' , * args , ** kwargs ) _open _open () Method to open the cluster for operation. _read_decorator _read_decorator ( iometa : _ReadMeta ) brief Decorator function to handle reading operations when the cluster is closed. if the cluster is closed, the decorated function will not be executed and return None. parameter func: Callable, the decorated function _start_writing _start_writing () _stop_writing _stop_writing () _update_cluster_all _update_cluster_all ( ** kwargs ) _update_cluster_inc _update_cluster_inc ( iometa : _IOMeta , data_i , value , ** kwargs ) update the state of the cluster after writing _write_decorator _write_decorator ( iometa : _WriteMeta ) brief Decorator function to handle writing operations when the cluster is closed or read-only. if the cluster is closed, the decorated function will not be executed and return None. if the cluster is read-only and the decorated function is a writing operation, the decorated function will not be executed and return None. parameter func: Callable, the decorated function check_key check_key ( key ) -> bool choose_unfinished_operation choose_unfinished_operation ( obj ) skip clear the unfinished data try to rollback the unfinished data exit\")) clear clear ( * , force = False , ignore_warning = False ) Method to clear any data in the cluster. Subclasses may implement this method. * it is dargerous close close () Method to close the cluster, preventing further operations. copyto abstractmethod copyto ( dst : str , * args , ** kwargs ) gen_identity_string classmethod gen_identity_string ( dataset_node : DatasetNode , sub_dir , name , * args , ** kwargs ) get_file_path abstractmethod get_file_path ( data_i , ** kwargs ) get_writing_mark_file get_writing_mark_file () identity_string identity_string () is_closed is_closed ( with_warning = False ) Method to check if the cluster is closed. is_opened is_opened () is_overwrite_allowed is_overwrite_allowed () is_readonly is_readonly ( with_warning = False ) Method to check if the cluster is read-only. is_writable is_writable () items abstractmethod items () -> Iterable [ tuple [ Any , VDCT ]] key_identity_string key_identity_string () keys abstractmethod keys () -> Iterable [ Any ] make_continuous make_continuous ( * args , ** kwargs ) merge_from merge_from ( src : _DataCluster , * args , ** kwargs ) open open () parse_identity_string staticmethod parse_identity_string ( identity_string ) process_unfinished process_unfinished () register_to_dataset register_to_dataset () set_overwrite_allowed set_overwrite_allowed ( overwrite_allowed = True ) Method to set the cluster as writable or read-only. set_readonly set_readonly ( readonly = True ) Method to set the cluster as read-only or write-enabled. set_writable set_writable ( writable = True ) Method to set the cluster as writable or read-only. start_writing start_writing ( overwrite_allowed = False ) rewrite the method of WriteController stop_writing stop_writing () rewrite the method of WriteController unregister_from_dataset unregister_from_dataset () values abstractmethod values () -> Iterable [ VDCT ] _IOMeta Bases: Generic [ DCT , VDCT ] the position parameter of 'record', '_call' , ' call ' must be the same IO_TYPE class-attribute instance-attribute IO_TYPE = WriteController . LOG_READ _kwargs instance-attribute _kwargs = {} cluster instance-attribute cluster : DCT = cluster warning_info instance-attribute warning_info : str = 'no description' __init__ __init__ ( cluster : DCT ) -> None check_key check_key ( key , ** kwargs ) -> bool check_value check_value ( value , ** kwargs ) -> bool record record ( ** kwargs ) _LinemodFormat_sub1 Bases: LinemodFormat rgb_elements instance-attribute rgb_elements = Elements ( self , 'rgb' , read_func = cv2 . imread , write_func = cv2 . imwrite , suffix = '.jpg' ) _MasksElements Bases: _MasksElements _read _read ( data_i , ** kwargs ) -> dict [ int , ndarray ] _write _write ( data_i , value : dict [ int , ndarray ], subdir = '' , appname = '' , ** kwargs ) __init__ __init__ ( directory , clear = False ) -> None read_one read_one ( data_i , ** kwargs ) _ReadMeta Bases: _IOMeta [ DCT , VDCT ] , ABC __call__ __call__ ( key , * args , force = False , ** kwargs ) -> VDCT _call abstractmethod _call ( key , ** kwargs : Any ) -> VDCT record record ( key , * args , ** kwargs ) _WriteMeta Bases: _IOMeta [ DCT , VDCT ] , ABC abstractmethod _call: the function to call when write is_overwriting: check if the data is overwriting recommend to implement check_key: check if the key is valid check_value: check if the value is valid __call__ __call__ ( key , value , * args , force = False , ** kwargs ) -> Any _call abstractmethod _call ( key , value , ** kwargs : Any ) is_overwriting abstractmethod is_overwriting ( key , value , ** kwargs ) record record ( key , value , ** kwargs ) _cvt_old_element_map _cvt_old_element_map ( dataset_node : DatasetNode , sub_dir : str , suffix : str ) as_dict as_dict ( ids , objs ) dataset_test dataset_test ( ds : DatasetNode , dst_ds : DatasetNode ) deserialize_object deserialize_object ( serialized_file_path ) get_mainname get_mainname ( path ) loadtxt_func loadtxt_func ( shape : tuple [ int ]) remove_duplicates remove_duplicates ( input_list ) savetxt_func savetxt_func ( fmt =... ) serialize_object serialize_object ( file_path , obj : dict ) zip_dict zip_dict ( ids : list [ int ], item : Union [ Iterable , None , Any ], func = lambda : x )","title":"dataset_format"},{"location":"md/data/dataset_format/#dataset_format","text":"","title":"dataset_format"},{"location":"md/data/dataset_format/#data.dataset_format.DCT","text":"DCT = TypeVar ( 'DCT' , bound = '_DataCluster' )","title":"DCT"},{"location":"md/data/dataset_format/#data.dataset_format.DSNT","text":"DSNT = TypeVar ( 'DSNT' , bound = 'DatasetNode' )","title":"DSNT"},{"location":"md/data/dataset_format/#data.dataset_format.VDCT","text":"VDCT = TypeVar ( 'VDCT' )","title":"VDCT"},{"location":"md/data/dataset_format/#data.dataset_format.VDST","text":"VDST = TypeVar ( 'VDST' )","title":"VDST"},{"location":"md/data/dataset_format/#data.dataset_format.ClusterDataIOError","text":"Bases: Exception","title":"ClusterDataIOError"},{"location":"md/data/dataset_format/#data.dataset_format.ClusterDataIOError.__init__","text":"__init__ ( * args : object ) -> None","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format.ClusterIONotExecutedWarning","text":"Bases: ClusterWarning","title":"ClusterIONotExecutedWarning"},{"location":"md/data/dataset_format/#data.dataset_format.ClusterIONotExecutedWarning.__init__","text":"__init__ ( * args : object ) -> None","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format.ClusterNotRecommendWarning","text":"Bases: ClusterWarning","title":"ClusterNotRecommendWarning"},{"location":"md/data/dataset_format/#data.dataset_format.ClusterNotRecommendWarning.__init__","text":"__init__ ( * args : object ) -> None","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format.ClusterParaWarning","text":"Bases: ClusterWarning","title":"ClusterParaWarning"},{"location":"md/data/dataset_format/#data.dataset_format.ClusterParaWarning.__init__","text":"__init__ ( * args : object ) -> None","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format.ClusterWarning","text":"Bases: Warning","title":"ClusterWarning"},{"location":"md/data/dataset_format/#data.dataset_format.ClusterWarning.__init__","text":"__init__ ( * args : object ) -> None","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetFormat","text":"Bases: DatasetNode [ DCT , VDST ]","title":"DatasetFormat"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetFormat--dataset-format","text":"A dataset manager, support mutiple data types. It is useful if you have a series of different data. For example, a sample contains an image and a set of bounding boxes. There is a one-to-one correspondence between them, and there are multiple sets of such data.","title":"Dataset Format"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetFormat--properties","text":"inited : bool, if the dataset has been inited updated : bool, if the dataset has been updated, it can bes set. directory : str, the root directory of the dataset unfinished : bool, the last writing process of the dataset has not been completed clusters : list[_DataCluster], all clusters of the dataset opened_clusters : list[_DataCluster], all opened clusters of the dataset jsondict_map : dict[str, JsonDict], the map of jsondict elements_map : dict[str, Elements], the map of elements files_map : dict[str, FileCluster], the map of fileclusters data_num : int, the number of data in the dataset data_i_upper : int, the max index of the iterator","title":"properties"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetFormat--virtual-function","text":"read_one: Read one piece of data","title":"virtual function"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetFormat--recommended-to-rewrite","text":"_init_clusters: init the clusters _write_jsondict: write one piece of data to jsondict _write_elementss: write one piece of data to elements _write_files: write one piece of data to files _update_dataset: update the dataset, it should be called when the dataset is updated","title":"recommended to rewrite"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetFormat--not-necessary-to-rewrite","text":"update_dataset: update the dataset, it should be called when the dataset is updated read_from_disk: read all data from disk as a generator write_to_disk: write one piece of data to disk start_writing: start writing stop_writing: stop writing clear: clear all data of the dataset close_all: close all clusters open_all : open all clusters set_all_readonly: set all file streams to read only set_all_writable: set all file streams to writable get_element_paths_of_one: get the paths of one piece of data getitem : get one piece of data setitem : set one piece of data iter : return the iterator of the dataset","title":"not necessary to rewrite"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetFormat--example","text":"read df1 = DatasetFormat(directory1) df2 = DatasetFormat(directory2) for data in self.read_from_disk(): ... write_to_disk : 1 df2.write_to_disk(data) \u00d7 this is wrong with df2.writer: # use context manager df2.write_to_disk(data) df2.clear() write_to_disk : 2 df2.start_writing() df2.write_to_disk(data) df2.stop_writing() write_one df2.write_one(data_i, data) '''","title":"example"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetFormat.DEFAULT_SPLIT_TYPE","text":"DEFAULT_SPLIT_TYPE = [ 'default' ]","title":"DEFAULT_SPLIT_TYPE"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetFormat.KW_TRAIN","text":"KW_TRAIN = 'train'","title":"KW_TRAIN"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetFormat.KW_VAL","text":"KW_VAL = 'val'","title":"KW_VAL"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetFormat.OVERVIEW","text":"OVERVIEW = 'overview.json'","title":"OVERVIEW"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetFormat.SPLIT_DIR","text":"SPLIT_DIR = 'ImageSets'","title":"SPLIT_DIR"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetFormat.default_train_idx_array","text":"default_train_idx_array","title":"default_train_idx_array"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetFormat.default_val_idx_array","text":"default_val_idx_array","title":"default_val_idx_array"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetFormat.split_default_rate","text":"split_default_rate = split_rate","title":"split_default_rate"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetFormat.train_idx_array","text":"train_idx_array","title":"train_idx_array"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetFormat.val_idx_array","text":"val_idx_array","title":"val_idx_array"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetFormat.__init__","text":"__init__ ( directory , split_rate = 0.75 , parent = None ) -> None","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetFormat.init_dataset_attr_hook","text":"init_dataset_attr_hook ()","title":"init_dataset_attr_hook()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetFormat.process_unfinished","text":"process_unfinished ()","title":"process_unfinished()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetFormat.stop_writing","text":"stop_writing ()","title":"stop_writing()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode","text":"Bases: InstanceRegistry , WriteController , ABC , Generic [ DCT , VDST ] DatasetNode, only gather the clusters. have no i/o operations","title":"DatasetNode"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.WRITING_MARK","text":"WRITING_MARK = '.dfsw'","title":"WRITING_MARK"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.clusters","text":"clusters : list [ DCT ]","title":"clusters"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.data_clusters","text":"data_clusters : list [ DCT ]","title":"data_clusters"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.data_i_upper","text":"data_i_upper","title":"data_i_upper"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.data_num","text":"data_num","title":"data_num"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.elements_map","text":"elements_map select the key-value pair whose value is Elements","title":"elements_map"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.filecluster_map","text":"filecluster_map select the key-value pair whose value is FileCluster","title":"filecluster_map"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.inited","text":"inited","title":"inited"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.jsondict_map","text":"jsondict_map select the key-value pair whose value is JsonDict","title":"jsondict_map"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.opened_clusters","text":"opened_clusters","title":"opened_clusters"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.opened_data_clusters","text":"opened_data_clusters","title":"opened_data_clusters"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.parent_directory","text":"parent_directory","title":"parent_directory"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.updated","text":"updated","title":"updated"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.__getitem__","text":"__getitem__ ( data_i : Union [ int , slice ]) -> Union [ Generator [ VDST , Any , None ], VDST ]","title":"__getitem__()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.__init__","text":"__init__ ( directory , parent : DatasetNode = None ) -> None","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.__iter__","text":"__iter__ ()","title":"__iter__()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.__len__","text":"__len__ ()","title":"__len__()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.__setattr__","text":"__setattr__ ( name , value )","title":"__setattr__()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.__setitem__","text":"__setitem__ ( data_i : int , value )","title":"__setitem__()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode._init_clusters","text":"_init_clusters ()","title":"_init_clusters()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode._init_identity_paramenter","text":"_init_identity_paramenter ( directory , * args , ** kwargs )","title":"_init_identity_paramenter()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode._update_dataset","text":"_update_dataset ( data_i = None )","title":"_update_dataset()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode._write_elements","text":"_write_elements ( data_i , data , subdir = '' , appname = '' )","title":"_write_elements()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode._write_files","text":"_write_files ( data_i , data )","title":"_write_files()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode._write_jsondict","text":"_write_jsondict ( data_i , data )","title":"_write_jsondict()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.add_child","text":"add_child ( child_node : DatasetNode )","title":"add_child()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.calc_overview","text":"calc_overview ( data_i )","title":"calc_overview()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.clear","text":"clear ( ignore_warning = False , force = False )","title":"clear()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.clear--brief","text":"clear all data, defalut to ask before executing","title":"brief"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.clear_invalid_data_i","text":"clear_invalid_data_i ()","title":"clear_invalid_data_i()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.close_all","text":"close_all ( value = True )","title":"close_all()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.copyto","text":"copyto ( dst : str , asroot = True , cover = False )","title":"copyto()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.gen_identity_string","text":"gen_identity_string ( directory , * args , ** kwargs )","title":"gen_identity_string()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.get_all_clusters","text":"get_all_clusters ( _type : Union [ type , tuple [ type ]] = None , only_opened = False ) -> _ClusterMap [ DCT ]","title":"get_all_clusters()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.get_element_paths_of_one","text":"get_element_paths_of_one ( data_i : int )","title":"get_element_paths_of_one()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.get_element_paths_of_one--brief","text":"get all paths of a data","title":"brief"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.get_writing_mark_file","text":"get_writing_mark_file ()","title":"get_writing_mark_file()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.identity_string","text":"identity_string ()","title":"identity_string()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.init_dataset_attr_hook","text":"init_dataset_attr_hook ()","title":"init_dataset_attr_hook()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.init_overview","text":"init_overview ()","title":"init_overview()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.items","text":"items ()","title":"items()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.keys","text":"keys ()","title":"keys()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.load_overview","text":"load_overview ()","title":"load_overview()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.move_node","text":"move_node ( new_parent : DatasetNode )","title":"move_node()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.open_all","text":"open_all ( value = True )","title":"open_all()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.parse_identity_string","text":"parse_identity_string ( identity_string : str )","title":"parse_identity_string()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.process_unfinished","text":"process_unfinished ()","title":"process_unfinished()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.read_from_disk","text":"read_from_disk ( with_data_i = False )","title":"read_from_disk()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.read_from_disk--brief","text":"*generator Since the amount of data may be large, return one by one","title":"brief"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.read_one","text":"read_one ( data_i , ** kwargs ) -> VDST","title":"read_one()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.remove_child","text":"remove_child ( child_node : DatasetNode )","title":"remove_child()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.remove_one","text":"remove_one ( data_i , * args , ** kwargs )","title":"remove_one()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.save_elements_data_info_map","text":"save_elements_data_info_map ()","title":"save_elements_data_info_map()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.save_overview","text":"save_overview ()","title":"save_overview()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.set_all_overwrite_allowed","text":"set_all_overwrite_allowed ( value = True )","title":"set_all_overwrite_allowed()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.set_all_readonly","text":"set_all_readonly ( value = True )","title":"set_all_readonly()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.set_all_writable","text":"set_all_writable ( value = True )","title":"set_all_writable()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.set_elements_cache_priority","text":"set_elements_cache_priority ( mode : bool )","title":"set_elements_cache_priority()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.start_writing","text":"start_writing ( overwrite_allowed = False )","title":"start_writing()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.stop_writing","text":"stop_writing ()","title":"stop_writing()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.update_dataset","text":"update_dataset ( data_i = None , f = False )","title":"update_dataset()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.values","text":"values ()","title":"values()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.write_one","text":"write_one ( data_i , data : VDST , ** kwargs )","title":"write_one()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.write_to_disk","text":"write_to_disk ( data : VDST , data_i =- 1 )","title":"write_to_disk()"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.write_to_disk--brief","text":"write elements immediately, write basejsoninfo to cache, they will be dumped when exiting the context of self.writer","title":"brief"},{"location":"md/data/dataset_format/#data.dataset_format.DatasetNode.write_to_disk--note","text":"For DatasetFormat, the write mode has only 'append'. If you need to modify, please call 'DatasetFormat.clear' to clear all data, and then write again.","title":"NOTE"},{"location":"md/data/dataset_format/#data.dataset_format.Elements","text":"Bases: _DataCluster [ DSNT , VDCT , 'Elements']","title":"Elements"},{"location":"md/data/dataset_format/#data.dataset_format.Elements--elements-manager","text":"Returns None if accessing an data_id that does not exist will not write if the element is None it can be used as an iterator, the iterator will return (data_id, element)","title":"elements manager"},{"location":"md/data/dataset_format/#data.dataset_format.Elements--attr","text":"see _DataCluster * readfunc: Callable, how to read one element from disk, the parameter must be (path) * writefunc: Callable, how to write one element to disk, the parameter must be (path, element) * suffix: str, the suffix of the file * filllen: int, to generate the store path * fillchar: str, to generate the store path * _data_i_dir_map: dict[int, str], the map of data_id and directory name * data_i_upper: int, the max index of the iterator","title":"attr"},{"location":"md/data/dataset_format/#data.dataset_format.Elements--method","text":"len : return the number of elements iter : return the iterator next : return the next element read: read one element from disk with the logic of self.readfunc write: write one element to disk with the logic of self.writefunc format_path: format the path of the element clear: clear all data of the dict and clear directory","title":"method"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.APPNAMES_MAP_FILE","text":"APPNAMES_MAP_FILE = 'data_i_appnames.elmm'","title":"APPNAMES_MAP_FILE"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.CACHE_FILE","text":"CACHE_FILE = 'cache.elmcache'","title":"CACHE_FILE"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DATA_INFO_MAP_FILE","text":"DATA_INFO_MAP_FILE = 'data_info_map.elmm'","title":"DATA_INFO_MAP_FILE"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DIR_MAP_FILE","text":"DIR_MAP_FILE = 'data_i_dir_map.elmm'","title":"DIR_MAP_FILE"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.WRITING_MARK","text":"WRITING_MARK = '.elmsw'","title":"WRITING_MARK"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._DCT","text":"_DCT = TypeVar ( '_DCT' , bound = 'Elements' )","title":"_DCT"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._VDCT","text":"_VDCT = TypeVar ( '_VDCT' )","title":"_VDCT"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.data_info_map","text":"data_info_map","title":"data_info_map"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoDict","text":"Bases: dict [ str , Union [ str , list , bool ]]","title":"DataInfoDict"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoDict.appnames","text":"appnames : tuple [ str ]","title":"appnames"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoDict.cache","text":"cache","title":"cache"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoDict.dir","text":"dir : str","title":"dir"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoDict.empty","text":"empty","title":"empty"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoDict.file_exist","text":"file_exist","title":"file_exist"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoDict.has_cache","text":"has_cache","title":"has_cache"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoDict.has_file","text":"has_file : bool","title":"has_file"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoDict.has_notfound","text":"has_notfound","title":"has_notfound"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoDict.__init__","text":"__init__ ( * args , ** kwargs )","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoDict.add_file","text":"add_file ( appname )","title":"add_file()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoDict.clear_notfound","text":"clear_notfound ( idx )","title":"clear_notfound()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoDict.erase_cache","text":"erase_cache ()","title":"erase_cache()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoDict.get_cache","text":"get_cache ()","title":"get_cache()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoDict.get_file_exist","text":"get_file_exist ( appname )","title":"get_file_exist()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoDict.refresh_has_file","text":"refresh_has_file ( elem : Elements , data_i : int )","title":"refresh_has_file()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoDict.remove_file","text":"remove_file ( appname )","title":"remove_file()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoDict.set_cache","text":"set_cache ( cache )","title":"set_cache()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoDict.sort","text":"sort ()","title":"sort()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoMap","text":"Bases: dict [ int , DataInfoDict ]","title":"DataInfoMap"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoMap.directory","text":"directory = self . elements . directory","title":"directory"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoMap.elements","text":"elements = elmm","title":"elements"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoMap.path","text":"path = os . path . join ( self . elements . directory , self . elements . DATA_INFO_MAP_FILE )","title":"path"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoMap.__init__","text":"__init__ ( elmm : Elements , * args , ** kwargs )","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoMap.add_appname","text":"add_appname ( data_i , appname )","title":"add_appname()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoMap.add_info","text":"add_info ( data_i , subdir , appnames : list [ str ] = None )","title":"add_info()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoMap.load","text":"load ( elmm : Elements )","title":"load()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoMap.rebuild","text":"rebuild ( ignore_notfound = False )","title":"rebuild()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoMap.remove_info","text":"remove_info ( data_i )","title":"remove_info()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.DataInfoMap.save","text":"save ()","title":"save()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._change_dir","text":"Bases: _WriteMeta [ _DCT , _VDCT ]","title":"_change_dir"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._change_dir.IO_TYPE","text":"IO_TYPE = WriteController . LOG_OPERATION","title":"IO_TYPE"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._change_dir.__call__","text":"__call__ ( data_i : int , dst_dir : str , * args , force = False , ** kwargs ) -> Any","title":"__call__()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._change_dir._call","text":"_call ( data_i : int , dst_dir : str , ** kwargs : Any )","title":"_call()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._change_dir.check_key","text":"check_key ( key , ** kwargs ) -> bool","title":"check_key()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._change_dir.check_value","text":"check_value ( value : str , ** kwargs ) -> bool","title":"check_value()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._change_dir.is_overwriting","text":"is_overwriting ( data_i , value , ** kwargs )","title":"is_overwriting()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._load_in","text":"Bases: _load_in [ _DCT , _VDCT ]","title":"_load_in"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._load_in.__call__","text":"__call__ ( data_i , value : VDCT , subdir = '' , * args , force = False , ** kwargs ) -> Any","title":"__call__()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._load_in._call","text":"_call ( src : list [ str ], dst : int , subdir = '' , ** kwargs : Any )","title":"_call()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._load_in.check_key","text":"check_key ( src : list [ str ], ** kwargs ) -> bool","title":"check_key()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._load_in.check_value","text":"check_value ( dst : int , ** kwargs ) -> bool","title":"check_value()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._move","text":"Bases: _move [ _DCT , _VDCT ]","title":"_move"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._move._call","text":"_call ( src : int , dst : int , * args , ** kwargs )","title":"_call()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._move.check_key","text":"check_key ( key , ** kwargs ) -> bool","title":"check_key()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._move.check_value","text":"check_value ( value , ** kwargs ) -> bool","title":"check_value()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._read","text":"Bases: _read [ _DCT , _VDCT ]","title":"_read"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._read._call","text":"_call ( data_i , ** kwargs : Any )","title":"_call()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._read._read_from_cache","text":"_read_from_cache ( data_i , ** kwargs )","title":"_read_from_cache()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._read._read_from_file","text":"_read_from_file ( data_i , ** kwargs )","title":"_read_from_file()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._remove","text":"Bases: _remove [ _DCT , _VDCT ]","title":"_remove"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._remove._call","text":"_call ( data_i , value , ** kwargs : Any )","title":"_call()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._write","text":"Bases: _write [ _DCT , _VDCT ]","title":"_write"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._write.__call__","text":"__call__ ( data_i , value : VDCT , subdir = '' , * args , force = False , ** kwargs ) -> Any","title":"__call__()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._write._call","text":"_call ( data_i , value : VDCT , subdir = '' , ** kwargs : Any )","title":"_call()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._write.check_key","text":"check_key ( data_i , ** kwargs ) -> bool","title":"check_key()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.__getitem__","text":"__getitem__ ( idx )","title":"__getitem__()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.__init__","text":"__init__ ( dataset_node : DSNT , sub_dir , register = True , name = '' , read_func : Callable = lambda : None , write_func : Callable = lambda , : None , suffix : str = '.txt' , filllen = 6 , fillchar = '0' , * , alternative_suffix : list [ str ] = []) -> None","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.__iter__","text":"__iter__ ()","title":"__iter__()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.__len__","text":"__len__ () Count the total number of files in the directory","title":"__len__()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.__setitem__","text":"__setitem__ ( idx , value )","title":"__setitem__()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._init_attr","text":"_init_attr ( read_func , write_func , suffix , filllen , fillchar , alternative_suffix = [], * args , ** kwargs )","title":"_init_attr()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._open","text":"_open ()","title":"_open()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._stop_writing","text":"_stop_writing ()","title":"_stop_writing()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._update_cluster_all","text":"_update_cluster_all ( * args , ** kwargs )","title":"_update_cluster_all()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements._update_cluster_inc","text":"_update_cluster_inc ( iometa : _IOMeta , data_i , value , subdir = '' , * args , ** kwargs )","title":"_update_cluster_inc()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.auto_path","text":"auto_path ( data_i , _subdir = None , _appname = None , return_app = False , allow_mutil_appendname = True ) -> Union [ list [ str ], tuple [ str , list [ str ]]] auto find the path of data_i. if data_i has multiple appnames, raise IndexError if return_app is True, return subdir, appname, else return path if allow_mutil_appendname is True, the type of appname will be list[str], else str; and the type of path will be list[str], else str","title":"auto_path()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.cache_to_data_info_map","text":"cache_to_data_info_map ( save = True , ** kwargs )","title":"cache_to_data_info_map()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.check_storage","text":"check_storage ()","title":"check_storage()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.clear_files_with_cache","text":"clear_files_with_cache ()","title":"clear_files_with_cache()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.construct_value_func","text":"construct_value_func ( appnames : list [ str ], values : list ) -> VDCT","title":"construct_value_func()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.copyto","text":"copyto ( dst : str , * args , ** kwargs )","title":"copyto()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.format_base_name","text":"format_base_name ( data_i )","title":"format_base_name()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.format_path","text":"format_path ( data_i , subdir = '' , appname = '' , directory = None , ** kwargs ) format the path of data_i","title":"format_path()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.get_file_path","text":"get_file_path ( data_i , * args , ** kwargs )","title":"get_file_path()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.has_file_of","text":"has_file_of ( data_i , subdir , appname )","title":"has_file_of()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.items","text":"items ()","title":"items()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.keys","text":"keys ()","title":"keys()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.keys--brief","text":"return a generator of data_i * Elements is not a dict, so it can't be used as a dict.","title":"brief"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.parse_appnames_func","text":"parse_appnames_func ( value )","title":"parse_appnames_func()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.parse_path","text":"parse_path ( directory , path : str ) parse the path to get data_i, subdir, appname, it is the reverse operation of format_path","title":"parse_path()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.process_unfinished","text":"process_unfinished ()","title":"process_unfinished()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.save_data_info_map","text":"save_data_info_map ( ** kwargs )","title":"save_data_info_map()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.unzip_cache","text":"unzip_cache ( force = False , ** kwargs ) unzip the cache to a dict","title":"unzip_cache()"},{"location":"md/data/dataset_format/#data.dataset_format.Elements.values","text":"values ()","title":"values()"},{"location":"md/data/dataset_format/#data.dataset_format.ElementsAmbiguousError","text":"Bases: ValueError","title":"ElementsAmbiguousError"},{"location":"md/data/dataset_format/#data.dataset_format.ElementsAmbiguousError.__init__","text":"__init__ ( * args : object ) -> None","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster","text":"Bases: _DataCluster [ DSNT , VDCT , 'FileCluster'] a cluster of multiple files, they may have different suffixes and i/o operations but they must be read/write together","title":"FileCluster"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster.SingleFile","text":"SingleFile = SingleFile","title":"SingleFile"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster.all_exist","text":"all_exist","title":"all_exist"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster._load_in","text":"Bases: _load_in ['FileCluster', VDCT ] , Generic [ VDCT ]","title":"_load_in"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster._load_in._call","text":"_call ( src_path : str , dst : int , ** kwargs : Any )","title":"_call()"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster._load_in.check_key","text":"check_key ( src : str , ** kwargs ) -> bool","title":"check_key()"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster._load_in.check_value","text":"check_value ( dst : int , ** kwargs ) -> bool","title":"check_value()"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster._move","text":"Bases: _move ['FileCluster', VDCT ] , Generic [ VDCT ]","title":"_move"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster._move.__call__","text":"__call__ ( src : int , dst : int , * args , force = False , ** kwargs )","title":"__call__()"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster._move._call","text":"_call ( key , value , ** kwargs : Any )","title":"_call()"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster._read","text":"Bases: _read ['FileCluster', VDCT ] , Generic [ VDCT ]","title":"_read"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster._read._call","text":"_call ( data_i , ** kwargs : Any ) -> VDCT","title":"_call()"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster._remove","text":"Bases: _remove ['FileCluster', VDCT ] , Generic [ VDCT ]","title":"_remove"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster._remove._call","text":"_call ( data_i , ** kwargs : Any )","title":"_call()"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster._write","text":"Bases: _write ['FileCluster', VDCT ] , Generic [ VDCT ]","title":"_write"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster._write._call","text":"_call ( data_i , value : VDCT )","title":"_call()"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster._write.is_overwriting","text":"is_overwriting ( data_i , value , subdir = '' , ** kwargs )","title":"is_overwriting()"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster.__init__","text":"__init__ ( dataset_node : DSNT , sub_dir , register = True , name = '' , singlefile_list : list [ SingleFile ] = []) -> None","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster.__len__","text":"__len__ ()","title":"__len__()"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster._init_attr","text":"_init_attr ( singlefile : list [ SingleFile ], * args , ** kwargs )","title":"_init_attr()"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster._make_continuous","text":"_make_continuous ( * args , ** kwargs )","title":"_make_continuous()"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster.copyto","text":"copyto ( dst : str , cover = False , * args , ** kwargs )","title":"copyto()"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster.filter_data_i","text":"filter_data_i ( data_i , return_index = False )","title":"filter_data_i()"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster.get_file","text":"get_file ( idx : Union [ int , str ])","title":"get_file()"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster.get_file_path","text":"get_file_path ( data_i , * args , ** kwargs )","title":"get_file_path()"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster.items","text":"items ()","title":"items()"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster.keys","text":"keys ()","title":"keys()"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster.merge_from","text":"merge_from ( src : FileCluster , merge_funcs : Union [ list , Callable ] = [], * args , ** kwargs )","title":"merge_from()"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster.paths","text":"paths ()","title":"paths()"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster.read_all","text":"read_all ()","title":"read_all()"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster.remove_file","text":"remove_file ( idx : Union [ int , str ])","title":"remove_file()"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster.update_file","text":"update_file ( singlefile : SingleFile )","title":"update_file()"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster.values","text":"values () -> list [ SingleFile [ VDCT ]]","title":"values()"},{"location":"md/data/dataset_format/#data.dataset_format.FileCluster.write_all","text":"write_all ( values )","title":"write_all()"},{"location":"md/data/dataset_format/#data.dataset_format.InstanceRegistry","text":"Bases: ABC","title":"InstanceRegistry"},{"location":"md/data/dataset_format/#data.dataset_format.InstanceRegistry._InstanceRegistry_inited","text":"_InstanceRegistry_inited = True","title":"_InstanceRegistry_inited"},{"location":"md/data/dataset_format/#data.dataset_format.InstanceRegistry._cluster_registry","text":"_cluster_registry = {}","title":"_cluster_registry"},{"location":"md/data/dataset_format/#data.dataset_format.InstanceRegistry._dataset_registry","text":"_dataset_registry = {}","title":"_dataset_registry"},{"location":"md/data/dataset_format/#data.dataset_format.InstanceRegistry._registry","text":"_registry : dict = None","title":"_registry"},{"location":"md/data/dataset_format/#data.dataset_format.InstanceRegistry.__init__","text":"__init__ () -> None","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format.InstanceRegistry.__init_subclass__","text":"__init_subclass__ ( ** kwargs ) -> None","title":"__init_subclass__()"},{"location":"md/data/dataset_format/#data.dataset_format.InstanceRegistry.__new__","text":"__new__ ( * args , ** kwargs )","title":"__new__()"},{"location":"md/data/dataset_format/#data.dataset_format.InstanceRegistry._init_identity_paramenter","text":"_init_identity_paramenter ()","title":"_init_identity_paramenter()"},{"location":"md/data/dataset_format/#data.dataset_format.InstanceRegistry.gen_identity_string","text":"gen_identity_string ( * args , ** kwargs )","title":"gen_identity_string()"},{"location":"md/data/dataset_format/#data.dataset_format.InstanceRegistry.identity_string","text":"identity_string ()","title":"identity_string()"},{"location":"md/data/dataset_format/#data.dataset_format.InstanceRegistry.parse_identity_string","text":"parse_identity_string ( identity_string )","title":"parse_identity_string()"},{"location":"md/data/dataset_format/#data.dataset_format.IntArrayDictElement","text":"Bases: Elements [ DSNT , dict [ int , ndarray ]]","title":"IntArrayDictElement"},{"location":"md/data/dataset_format/#data.dataset_format.IntArrayDictElement.array_fmt","text":"array_fmt = array_fmt if array_fmt else ' %.4f '","title":"array_fmt"},{"location":"md/data/dataset_format/#data.dataset_format.IntArrayDictElement.array_shape","text":"array_shape : tuple [ int ] = array_shape","title":"array_shape"},{"location":"md/data/dataset_format/#data.dataset_format.IntArrayDictElement.__init__","text":"__init__ ( dataset_node : DSNT , sub_dir : str , array_shape : tuple [ int ], array_fmt : str = '' , register = True , name = '' , filllen = 6 , fillchar = '0' ) -> None","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format.IntArrayDictElement._from_dict","text":"_from_dict ( dict_ : dict [ int , np . ndarray ]) dict_: dict[int, np.ndarray]","title":"_from_dict()"},{"location":"md/data/dataset_format/#data.dataset_format.IntArrayDictElement._read_format","text":"_read_format ( array : np . ndarray , ** kwargs )","title":"_read_format()"},{"location":"md/data/dataset_format/#data.dataset_format.IntArrayDictElement._read_func","text":"_read_func ( path , ** kwargs )","title":"_read_func()"},{"location":"md/data/dataset_format/#data.dataset_format.IntArrayDictElement._to_dict","text":"_to_dict ( array : np . ndarray ) -> dict [ int , np . ndarray ] array: np.ndarray [N, 5]","title":"_to_dict()"},{"location":"md/data/dataset_format/#data.dataset_format.IntArrayDictElement._write_format","text":"_write_format ( array : np . ndarray , ** kwargs )","title":"_write_format()"},{"location":"md/data/dataset_format/#data.dataset_format.IntArrayDictElement._write_func","text":"_write_func ( path , intarraydict : dict [ int , np . ndarray ], ** kwargs )","title":"_write_func()"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict","text":"Bases: _DataCluster [ DSNT , VDCT , 'JsonDict'] , dict","title":"JsonDict"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict--dict-for-base-json","text":"it is a subclass of dict, so it can be used as a dict returns None if accessing an key that does not exist","title":"dict for base json"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict--attr","text":"see _DataCluster","title":"attr"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict--method","text":"see _DataCluster * clear: clear all data of the dict and clear the json file","title":"method"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict.SAVE_AFTER_CLOSE","text":"SAVE_AFTER_CLOSE = 1","title":"SAVE_AFTER_CLOSE"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict.SAVE_IMMIDIATELY","text":"SAVE_IMMIDIATELY = 0","title":"SAVE_IMMIDIATELY"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict.SAVE_STREAMLY","text":"SAVE_STREAMLY = 2","title":"SAVE_STREAMLY"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict.save_mode","text":"save_mode","title":"save_mode"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict.write_streamly","text":"write_streamly","title":"write_streamly"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict._Placeholder","text":"","title":"_Placeholder"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict._Placeholder.__init__","text":"__init__ () -> None","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict.__init__","text":"__init__ ( dataset_node : DSNT , sub_dir , register = True , name = '' , * args , ** kwargs )","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict.__iter__","text":"__iter__ () -> Iterator","title":"__iter__()"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict.__len__","text":"__len__ () -> int","title":"__len__()"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict._clear","text":"_clear ( * args , ** kwargs )","title":"_clear()"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict._copyto","text":"_copyto ( dst : str , * args , ** kwargs )","title":"_copyto()"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict._init_attr","text":"_init_attr ( * args , ** kwargs )","title":"_init_attr()"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict._make_continuous","text":"_make_continuous ( * args , ** kwargs )","title":"_make_continuous()"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict._merge_one","text":"_merge_one ( src : JsonDict , k , * args , ** kwargs )","title":"_merge_one()"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict._read","text":"_read ( data_i , ** kwargs )","title":"_read()"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict._remove","text":"_remove ( data_i , * args , ** kwargs )","title":"_remove()"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict._stop_writing","text":"_stop_writing () rewrite the method of WriteController","title":"_stop_writing()"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict._write","text":"_write ( data_i , value , ** kwargs )","title":"_write()"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict.items","text":"items ()","title":"items()"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict.keys","text":"keys ()","title":"keys()"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict.reload","text":"reload ( value = {})","title":"reload()"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict.save","text":"save ()","title":"save()"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict.sort","text":"sort ( * args , ** kwargs ) sort by keys","title":"sort()"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict.start_writing","text":"start_writing ( overwrite_allowed = False ) rewrite the method of WriteController","title":"start_writing()"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict.stop_writing","text":"stop_writing () rewrite the method of WriteController","title":"stop_writing()"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict.update","text":"update ( _m : Union [ dict , Iterable [ tuple ]] = None , ** kwargs )","title":"update()"},{"location":"md/data/dataset_format/#data.dataset_format.JsonDict.values","text":"values ()","title":"values()"},{"location":"md/data/dataset_format/#data.dataset_format.LinemodFormat","text":"Bases: PostureDatasetFormat","title":"LinemodFormat"},{"location":"md/data/dataset_format/#data.dataset_format.LinemodFormat.DEPTH_DIR","text":"DEPTH_DIR = 'depth'","title":"DEPTH_DIR"},{"location":"md/data/dataset_format/#data.dataset_format.LinemodFormat.GT_CAM_FILE","text":"GT_CAM_FILE = 'scene_camera.json'","title":"GT_CAM_FILE"},{"location":"md/data/dataset_format/#data.dataset_format.LinemodFormat.GT_FILE","text":"GT_FILE = 'scene_gt.json'","title":"GT_FILE"},{"location":"md/data/dataset_format/#data.dataset_format.LinemodFormat.GT_INFO_FILE","text":"GT_INFO_FILE = 'scene_gt_info.json'","title":"GT_INFO_FILE"},{"location":"md/data/dataset_format/#data.dataset_format.LinemodFormat.KW_CAM_DS","text":"KW_CAM_DS = 'depth_scale'","title":"KW_CAM_DS"},{"location":"md/data/dataset_format/#data.dataset_format.LinemodFormat.KW_CAM_K","text":"KW_CAM_K = 'cam_K'","title":"KW_CAM_K"},{"location":"md/data/dataset_format/#data.dataset_format.LinemodFormat.KW_CAM_VL","text":"KW_CAM_VL = 'view_level'","title":"KW_CAM_VL"},{"location":"md/data/dataset_format/#data.dataset_format.LinemodFormat.KW_GT_ID","text":"KW_GT_ID = 'obj_id'","title":"KW_GT_ID"},{"location":"md/data/dataset_format/#data.dataset_format.LinemodFormat.KW_GT_INFO_BBOX_OBJ","text":"KW_GT_INFO_BBOX_OBJ = 'bbox_obj'","title":"KW_GT_INFO_BBOX_OBJ"},{"location":"md/data/dataset_format/#data.dataset_format.LinemodFormat.KW_GT_INFO_BBOX_VIS","text":"KW_GT_INFO_BBOX_VIS = 'bbox_visib'","title":"KW_GT_INFO_BBOX_VIS"},{"location":"md/data/dataset_format/#data.dataset_format.LinemodFormat.KW_GT_INFO_PX_COUNT_ALL","text":"KW_GT_INFO_PX_COUNT_ALL = 'px_count_all'","title":"KW_GT_INFO_PX_COUNT_ALL"},{"location":"md/data/dataset_format/#data.dataset_format.LinemodFormat.KW_GT_INFO_PX_COUNT_VIS","text":"KW_GT_INFO_PX_COUNT_VIS = 'px_count_visib'","title":"KW_GT_INFO_PX_COUNT_VIS"},{"location":"md/data/dataset_format/#data.dataset_format.LinemodFormat.KW_GT_INFO_PX_COUNT_VLD","text":"KW_GT_INFO_PX_COUNT_VLD = 'px_count_valid'","title":"KW_GT_INFO_PX_COUNT_VLD"},{"location":"md/data/dataset_format/#data.dataset_format.LinemodFormat.KW_GT_INFO_VISIB_FRACT","text":"KW_GT_INFO_VISIB_FRACT = 'visib_fract'","title":"KW_GT_INFO_VISIB_FRACT"},{"location":"md/data/dataset_format/#data.dataset_format.LinemodFormat.KW_GT_R","text":"KW_GT_R = 'cam_R_m2c'","title":"KW_GT_R"},{"location":"md/data/dataset_format/#data.dataset_format.LinemodFormat.KW_GT_t","text":"KW_GT_t = 'cam_t_m2c'","title":"KW_GT_t"},{"location":"md/data/dataset_format/#data.dataset_format.LinemodFormat.MASK_DIR","text":"MASK_DIR = 'mask'","title":"MASK_DIR"},{"location":"md/data/dataset_format/#data.dataset_format.LinemodFormat.RGB_DIR","text":"RGB_DIR = 'rgb'","title":"RGB_DIR"},{"location":"md/data/dataset_format/#data.dataset_format.LinemodFormat._MasksElements","text":"Bases: Elements ['LinemodFormat', dict [ int , ndarray ]]","title":"_MasksElements"},{"location":"md/data/dataset_format/#data.dataset_format.LinemodFormat._MasksElements._read","text":"_read ( data_i , ** kwargs ) -> dict [ int , np . ndarray ]","title":"_read()"},{"location":"md/data/dataset_format/#data.dataset_format.LinemodFormat._MasksElements._write","text":"_write ( data_i , value : dict [ int , ndarray ], subdir = '' , appname = '' , ** kwargs )","title":"_write()"},{"location":"md/data/dataset_format/#data.dataset_format.LinemodFormat._MasksElements.id_format","text":"id_format ( class_id )","title":"id_format()"},{"location":"md/data/dataset_format/#data.dataset_format.LinemodFormat._init_clusters","text":"_init_clusters ()","title":"_init_clusters()"},{"location":"md/data/dataset_format/#data.dataset_format.LinemodFormat._write_elements","text":"_write_elements ( data_i : int , viewmeta : ViewMeta , subdir = '' , appname = '' )","title":"_write_elements()"},{"location":"md/data/dataset_format/#data.dataset_format.LinemodFormat._write_jsondict","text":"_write_jsondict ( data_i : int , viewmeta : ViewMeta )","title":"_write_jsondict()"},{"location":"md/data/dataset_format/#data.dataset_format.LinemodFormat.read_one","text":"read_one ( data_i , ** kwargs )","title":"read_one()"},{"location":"md/data/dataset_format/#data.dataset_format.Mix_VocFormat","text":"Bases: VocFormat","title":"Mix_VocFormat"},{"location":"md/data/dataset_format/#data.dataset_format.Mix_VocFormat.BASIS_SUBSETS","text":"BASIS_SUBSETS = [ 'basic' , 'augment' ]","title":"BASIS_SUBSETS"},{"location":"md/data/dataset_format/#data.dataset_format.Mix_VocFormat.DEFAULT_SPLIT_TYPE","text":"DEFAULT_SPLIT_TYPE = [ 'default' , 'posture' , 'reality' , 'basis' ]","title":"DEFAULT_SPLIT_TYPE"},{"location":"md/data/dataset_format/#data.dataset_format.Mix_VocFormat.IMGAE_DIR","text":"IMGAE_DIR = 'images'","title":"IMGAE_DIR"},{"location":"md/data/dataset_format/#data.dataset_format.Mix_VocFormat.MODE_DETECTION","text":"MODE_DETECTION = 0","title":"MODE_DETECTION"},{"location":"md/data/dataset_format/#data.dataset_format.Mix_VocFormat.MODE_POSTURE","text":"MODE_POSTURE = 1","title":"MODE_POSTURE"},{"location":"md/data/dataset_format/#data.dataset_format.Mix_VocFormat.REALITY_SUBSETS","text":"REALITY_SUBSETS = [ 'real' , 'sim' ]","title":"REALITY_SUBSETS"},{"location":"md/data/dataset_format/#data.dataset_format.Mix_VocFormat.basis_spliter","text":"basis_spliter","title":"basis_spliter"},{"location":"md/data/dataset_format/#data.dataset_format.Mix_VocFormat.default_spliter","text":"default_spliter","title":"default_spliter"},{"location":"md/data/dataset_format/#data.dataset_format.Mix_VocFormat.posture_spliter","text":"posture_spliter","title":"posture_spliter"},{"location":"md/data/dataset_format/#data.dataset_format.Mix_VocFormat.posture_train_idx_list","text":"posture_train_idx_list","title":"posture_train_idx_list"},{"location":"md/data/dataset_format/#data.dataset_format.Mix_VocFormat.posture_val_idx_list","text":"posture_val_idx_list","title":"posture_val_idx_list"},{"location":"md/data/dataset_format/#data.dataset_format.Mix_VocFormat.reality_spliter","text":"reality_spliter","title":"reality_spliter"},{"location":"md/data/dataset_format/#data.dataset_format.Mix_VocFormat.spliter_name","text":"spliter_name = self . DEFAULT_SPLIT_TYPE [ 1 ]","title":"spliter_name"},{"location":"md/data/dataset_format/#data.dataset_format.Mix_VocFormat.__init__","text":"__init__ ( directory , split_rate = 0.75 , parent = None ) -> None","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format.Mix_VocFormat._init_clusters","text":"_init_clusters ()","title":"_init_clusters()"},{"location":"md/data/dataset_format/#data.dataset_format.Mix_VocFormat.gen_posture_log","text":"gen_posture_log ( ratio = 0.15 , source : list [ int ] = None ) Only take ratio of the real data as the verification set","title":"gen_posture_log()"},{"location":"md/data/dataset_format/#data.dataset_format.Mix_VocFormat.record_data_type","text":"record_data_type ( data_i , is_real , is_basic )","title":"record_data_type()"},{"location":"md/data/dataset_format/#data.dataset_format.PostureDatasetFormat","text":"Bases: DatasetFormat [ _DataCluster , ViewMeta ]","title":"PostureDatasetFormat"},{"location":"md/data/dataset_format/#data.dataset_format.PostureDatasetFormat._init_clusters","text":"_init_clusters ()","title":"_init_clusters()"},{"location":"md/data/dataset_format/#data.dataset_format.PostureDatasetFormat._write_elements","text":"_write_elements ( data_i : int , viewmeta : ViewMeta , subdir = '' , appname = '' )","title":"_write_elements()"},{"location":"md/data/dataset_format/#data.dataset_format.PostureDatasetFormat.calc_by_base","text":"calc_by_base ( mesh_dict : dict [ int , MeshMeta ], overwitre = False )","title":"calc_by_base()"},{"location":"md/data/dataset_format/#data.dataset_format.PostureDatasetFormat.calc_by_base--brief","text":"calculate data by base data, see ViewMeta.calc_by_base","title":"brief"},{"location":"md/data/dataset_format/#data.dataset_format.PostureDatasetFormat.read_one","text":"read_one ( data_i , ** kwargs )","title":"read_one()"},{"location":"md/data/dataset_format/#data.dataset_format.SingleFile","text":"Bases: Generic [ VDCT ]","title":"SingleFile"},{"location":"md/data/dataset_format/#data.dataset_format.SingleFile.cluster","text":"cluster : FileCluster = None","title":"cluster"},{"location":"md/data/dataset_format/#data.dataset_format.SingleFile.exist","text":"exist","title":"exist"},{"location":"md/data/dataset_format/#data.dataset_format.SingleFile.path","text":"path","title":"path"},{"location":"md/data/dataset_format/#data.dataset_format.SingleFile.read_func","text":"read_func : Callable = read_func","title":"read_func"},{"location":"md/data/dataset_format/#data.dataset_format.SingleFile.sub_path","text":"sub_path = sub_path","title":"sub_path"},{"location":"md/data/dataset_format/#data.dataset_format.SingleFile.write_func","text":"write_func : Callable = write_func","title":"write_func"},{"location":"md/data/dataset_format/#data.dataset_format.SingleFile.__init__","text":"__init__ ( sub_path : str , read_func : Callable , write_func : Callable ) -> None","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format.SingleFile.new_json_singlefile","text":"new_json_singlefile ( sub_path : str )","title":"new_json_singlefile()"},{"location":"md/data/dataset_format/#data.dataset_format.SingleFile.new_npy_singlefile","text":"new_npy_singlefile ( sub_path : str )","title":"new_npy_singlefile()"},{"location":"md/data/dataset_format/#data.dataset_format.SingleFile.new_pickle_singlefile","text":"new_pickle_singlefile ( sub_path : str )","title":"new_pickle_singlefile()"},{"location":"md/data/dataset_format/#data.dataset_format.SingleFile.new_txt_singlefile","text":"new_txt_singlefile ( sub_path : str )","title":"new_txt_singlefile()"},{"location":"md/data/dataset_format/#data.dataset_format.SingleFile.read","text":"read () -> VDCT","title":"read()"},{"location":"md/data/dataset_format/#data.dataset_format.SingleFile.set_cluster","text":"set_cluster ( cluster : FileCluster )","title":"set_cluster()"},{"location":"md/data/dataset_format/#data.dataset_format.SingleFile.write","text":"write ( data )","title":"write()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter","text":"Bases: FileCluster ['SpliterGroup', list [ int ]]","title":"Spliter"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.SPLIT_FILE","text":"SPLIT_FILE = 'split.json'","title":"SPLIT_FILE"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.SPLIT_FOR_DATATYPE","text":"SPLIT_FOR_DATATYPE = 1","title":"SPLIT_FOR_DATATYPE"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.SPLIT_FOR_FILE","text":"SPLIT_FOR_FILE = '__split_for.txt'","title":"SPLIT_FOR_FILE"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.SPLIT_FOR_TRAINING","text":"SPLIT_FOR_TRAINING = 0","title":"SPLIT_FOR_TRAINING"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.SPLIT_MODE_BASE","text":"SPLIT_MODE_BASE = 'base'","title":"SPLIT_MODE_BASE"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.active_split","text":"active_split","title":"active_split"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.data","text":"data","title":"data"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.default_subsets","text":"default_subsets","title":"default_subsets"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.exclusive","text":"exclusive","title":"exclusive"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.split_file","text":"split_file = SingleFile [ dict [ str , dict [ str , list [ int ]]]]( self . SPLIT_FILE , partial ( JsonIO . load_json , cvt_list_to_array = False ), partial ( JsonIO . dump_json , regard_list_as_array = True ))","title":"split_file"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.split_for","text":"split_for = self . split_for_file . read ()","title":"split_for"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.split_for_file","text":"split_for_file = SingleFile [ tuple [ int , list [ str ]]]( self . SPLIT_FOR_FILE , self . load_split_for_info_func , self . save_split_for_info_func )","title":"split_for_file"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.split_mode","text":"split_mode","title":"split_mode"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.split_mode_list","text":"split_mode_list","title":"split_mode_list"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.split_table","text":"split_table = self . SpliterTable ( self )","title":"split_table"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.spliter_name","text":"spliter_name","title":"spliter_name"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.subset_fileobjs_dict","text":"subset_fileobjs_dict : dict [ str , SingleFile [ list [ int ]]]","title":"subset_fileobjs_dict"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.subsets","text":"subsets","title":"subsets"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.total_num","text":"total_num","title":"total_num"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.SpliterTable","text":"Bases: Table [ str , str , list [ int ]]","title":"SpliterTable"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.SpliterTable.spliter","text":"spliter = spliter","title":"spliter"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.SpliterTable.__init__","text":"__init__ ( spliter : Spliter )","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.SpliterTable.__str__","text":"__str__ () -> str","title":"__str__()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.SpliterTable.gen_default_value","text":"gen_default_value () -> list [ int ]","title":"gen_default_value()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.SpliterTable.get_base_filter","text":"get_base_filter ()","title":"get_base_filter()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.SpliterTable.qurey","text":"qurey ( data_i : int , return_key : bool = False )","title":"qurey()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.__getitem__","text":"__getitem__ ( key )","title":"__getitem__()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.__init__","text":"__init__ ( dataset_node : SpliterGroup , sub_dir : str , split_for = None , default_subsets : list = [], register = True , name = '' ) -> None","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.add_split_mode","text":"add_split_mode ( mode : str , exist_ok : bool = False )","title":"add_split_mode()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.clear_idx","text":"clear_idx ()","title":"clear_idx()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.gen_split","text":"gen_split ( data_num : Union [ int , Iterable ], split_rate : Union [ float , Iterable [ float ], dict [ str , float ]], split_num : int )","title":"gen_split()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.get_idx_list","text":"get_idx_list ( subset : Union [ str , int ], split_mode = None ) -> list [ int ]","title":"get_idx_list()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.get_one_subset","text":"get_one_subset ( data_i )","title":"get_one_subset()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.get_split","text":"get_split ( split_mode )","title":"get_split()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.load","text":"load ()","title":"load()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.load_split_for_info_func","text":"load_split_for_info_func ( path : str )","title":"load_split_for_info_func()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.loadsplittxt_func","text":"loadsplittxt_func ( path : str )","title":"loadsplittxt_func()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.print","text":"print ()","title":"print()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.process_split_rate","text":"process_split_rate ( split_rate : Union [ float , Iterable [ float ], dict [ str , float ]], split_num : Union [ int , list [ str ]])","title":"process_split_rate()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.read_idx_list","text":"read_idx_list ( subset : Union [ str , int ], split_mode = None ) -> tuple [ int ]","title":"read_idx_list()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.remove_one","text":"remove_one ( idx )","title":"remove_one()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.remove_split_mode","text":"remove_split_mode ( mode : str , not_exist_ok : bool = False )","title":"remove_split_mode()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.save","text":"save ()","title":"save()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.save_split_for_info_func","text":"save_split_for_info_func ( path : str , value : int )","title":"save_split_for_info_func()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.set_default_subsets","text":"set_default_subsets ( value : Union [ str , Iterable [ str ]])","title":"set_default_subsets()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.set_exclusive","text":"set_exclusive ( value : bool )","title":"set_exclusive()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.set_one","text":"set_one ( data_i , subset , split_mode = None , sort = False )","title":"set_one()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.set_one_by_rate","text":"set_one_by_rate ( data_i , split_rate , split_mode = None )","title":"set_one_by_rate()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.set_split_mode","text":"set_split_mode ( split_mode : int )","title":"set_split_mode()"},{"location":"md/data/dataset_format/#data.dataset_format.Spliter.sort_all","text":"sort_all ()","title":"sort_all()"},{"location":"md/data/dataset_format/#data.dataset_format.SpliterGroup","text":"Bases: DatasetNode [ Spliter , VDST ]","title":"SpliterGroup"},{"location":"md/data/dataset_format/#data.dataset_format.SpliterGroup.DEFAULT_SPLIT_TYPE","text":"DEFAULT_SPLIT_TYPE = [ 'default' ]","title":"DEFAULT_SPLIT_TYPE"},{"location":"md/data/dataset_format/#data.dataset_format.SpliterGroup.cluster_map","text":"cluster_map : _ClusterMap [ Spliter ] = self . cluster_map","title":"cluster_map"},{"location":"md/data/dataset_format/#data.dataset_format.SpliterGroup.cur_spliter_name","text":"cur_spliter_name","title":"cur_spliter_name"},{"location":"md/data/dataset_format/#data.dataset_format.SpliterGroup.cur_training_spliter","text":"cur_training_spliter","title":"cur_training_spliter"},{"location":"md/data/dataset_format/#data.dataset_format.SpliterGroup.split_subdir","text":"split_subdir","title":"split_subdir"},{"location":"md/data/dataset_format/#data.dataset_format.SpliterGroup.spliter_name_list","text":"spliter_name_list","title":"spliter_name_list"},{"location":"md/data/dataset_format/#data.dataset_format.SpliterGroup.__getitem__","text":"__getitem__ ( key )","title":"__getitem__()"},{"location":"md/data/dataset_format/#data.dataset_format.SpliterGroup.__init__","text":"__init__ ( directory , spliter_name_list : list , parent = None ) -> None","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format.SpliterGroup._init_clusters","text":"_init_clusters ()","title":"_init_clusters()"},{"location":"md/data/dataset_format/#data.dataset_format.SpliterGroup.query_datatype_set","text":"query_datatype_set ( data_i : int ) -> dict [ str , Table [ str , str , bool ]]","title":"query_datatype_set()"},{"location":"md/data/dataset_format/#data.dataset_format.SpliterGroup.query_set","text":"query_set ( data_i : int , split_for : int = None ) -> dict [ str , Table [ str , str , bool ]]","title":"query_set()"},{"location":"md/data/dataset_format/#data.dataset_format.SpliterGroup.query_training_set","text":"query_training_set ( data_i ) -> dict [ str , Table [ str , str , bool ]]","title":"query_training_set()"},{"location":"md/data/dataset_format/#data.dataset_format.SpliterGroup.read_one","text":"read_one ( data_i , ** kwargs ) -> VDST","title":"read_one()"},{"location":"md/data/dataset_format/#data.dataset_format.SpliterGroup.record_set","text":"record_set ( data_i : int , set_ : dict [ str , Table [ str , str , bool ]])","title":"record_set()"},{"location":"md/data/dataset_format/#data.dataset_format.SpliterGroup.remove_one","text":"remove_one ( idx )","title":"remove_one()"},{"location":"md/data/dataset_format/#data.dataset_format.SpliterGroup.save","text":"save ()","title":"save()"},{"location":"md/data/dataset_format/#data.dataset_format.SpliterGroup.set_cur_spliter_name","text":"set_cur_spliter_name ( spliter_name : str )","title":"set_cur_spliter_name()"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat","text":"Bases: PostureDatasetFormat","title":"VocFormat"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat.IMGAE_DIR","text":"IMGAE_DIR = 'images'","title":"IMGAE_DIR"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat.cxcywhLabelElement","text":"Bases: IntArrayDictElement","title":"cxcywhLabelElement"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat.cxcywhLabelElement.default_image_size","text":"default_image_size = None","title":"default_image_size"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat.cxcywhLabelElement.skip","text":"skip = False","title":"skip"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat.cxcywhLabelElement._read","text":"Bases: _read","title":"_read"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat.cxcywhLabelElement._read.cluster","text":"cluster : VocFormat . cxcywhLabelElement = cluster","title":"cluster"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat.cxcywhLabelElement._read.__call__","text":"__call__ ( data_i , * args , force = False , image_size = None , ** kwargs : Any )","title":"__call__()"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat.cxcywhLabelElement._read.__init__","text":"__init__ ( cluster ) -> None","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat.cxcywhLabelElement._read._call","text":"_call ( data_i , * , image_size = None , ** kwargs : Any )","title":"_call()"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat.cxcywhLabelElement._write","text":"Bases: _write","title":"_write"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat.cxcywhLabelElement._write.cluster","text":"cluster : VocFormat . cxcywhLabelElement = cluster","title":"cluster"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat.cxcywhLabelElement._write.__call__","text":"__call__ ( data_i , labels_dict : dict [ int , np . ndarray ], subdir = '' , * args , force = False , image_size = None , ** kwargs )","title":"__call__()"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat.cxcywhLabelElement._write.__init__","text":"__init__ ( cluster ) -> None","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat.cxcywhLabelElement._write._call","text":"_call ( data_i , labels_dict : dict [ int , np . ndarray ], subdir = '' , * , image_size = None , ** kwargs )","title":"_call()"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat.cxcywhLabelElement.__init__","text":"__init__ ( dataset_node : Any , sub_dir : str , array_fmt : str = '' , register = True , name = '' , filllen = 6 , fillchar = '0' ) -> None","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat.cxcywhLabelElement._read_format","text":"_read_format ( labels : np . ndarray , image_size = None )","title":"_read_format()"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat.cxcywhLabelElement._reset_trigger","text":"_reset_trigger ()","title":"_reset_trigger()"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat.cxcywhLabelElement._write_format","text":"_write_format ( labels : np . ndarray , image_size = None )","title":"_write_format()"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat.cxcywhLabelElement.skip_once","text":"skip_once ()","title":"skip_once()"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat.__init__","text":"__init__ ( directory , split_rate = 0.25 , parent = None ) -> None","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat._init_clusters","text":"_init_clusters ()","title":"_init_clusters()"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat._normedcxcywh_2_x1y1x2y2","text":"_normedcxcywh_2_x1y1x2y2 ( bbox_2d , img_size ) bbox_2d: np.ndarray [..., (cx, cy, w, h)] img_size: (w, h)","title":"_normedcxcywh_2_x1y1x2y2()"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat._write_elements","text":"_write_elements ( data_i : int , viewmeta : ViewMeta , subdir = '' , appname = '' )","title":"_write_elements()"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat._x1y1x2y2_2_normedcxcywh","text":"_x1y1x2y2_2_normedcxcywh ( bbox_2d , img_size ) bbox_2d: np.ndarray [..., (x1, x2, y1, y2)] img_size: (w, h)","title":"_x1y1x2y2_2_normedcxcywh()"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat.decide_default_set","text":"decide_default_set ( data_i )","title":"decide_default_set()"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat.get_default_set","text":"get_default_set ( data_i )","title":"get_default_set()"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat.read_one","text":"read_one ( data_i , ** kwargs ) -> ViewMeta","title":"read_one()"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat.save_elements_data_info_map","text":"save_elements_data_info_map ()","title":"save_elements_data_info_map()"},{"location":"md/data/dataset_format/#data.dataset_format.VocFormat.synchronize_default_split","text":"synchronize_default_split ()","title":"synchronize_default_split()"},{"location":"md/data/dataset_format/#data.dataset_format.WriteController","text":"Bases: ABC control the write operation. the subclass of WriteController must implement : * start_writing * stop_writing","title":"WriteController"},{"location":"md/data/dataset_format/#data.dataset_format.WriteController.LOG_APPEND","text":"LOG_APPEND = 0","title":"LOG_APPEND"},{"location":"md/data/dataset_format/#data.dataset_format.WriteController.LOG_CHANGE","text":"LOG_CHANGE = 2","title":"LOG_CHANGE"},{"location":"md/data/dataset_format/#data.dataset_format.WriteController.LOG_KN","text":"LOG_KN = [ LOG_APPEND , LOG_REMOVE , LOG_CHANGE , LOG_MOVE , LOG_OPERATION ]","title":"LOG_KN"},{"location":"md/data/dataset_format/#data.dataset_format.WriteController.LOG_MOVE","text":"LOG_MOVE = 3","title":"LOG_MOVE"},{"location":"md/data/dataset_format/#data.dataset_format.WriteController.LOG_OPERATION","text":"LOG_OPERATION = 4","title":"LOG_OPERATION"},{"location":"md/data/dataset_format/#data.dataset_format.WriteController.LOG_READ","text":"LOG_READ = - 1","title":"LOG_READ"},{"location":"md/data/dataset_format/#data.dataset_format.WriteController.LOG_REMOVE","text":"LOG_REMOVE = 1","title":"LOG_REMOVE"},{"location":"md/data/dataset_format/#data.dataset_format.WriteController.WRITING_MARK","text":"WRITING_MARK = '.writing'","title":"WRITING_MARK"},{"location":"md/data/dataset_format/#data.dataset_format.WriteController.is_writing","text":"is_writing = False","title":"is_writing"},{"location":"md/data/dataset_format/#data.dataset_format.WriteController.writer","text":"writer","title":"writer"},{"location":"md/data/dataset_format/#data.dataset_format.WriteController.__init__","text":"__init__ () -> None","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format.WriteController.get_writing_mark_file","text":"get_writing_mark_file () -> str","title":"get_writing_mark_file()"},{"location":"md/data/dataset_format/#data.dataset_format.WriteController.load_from_mark_file","text":"load_from_mark_file ()","title":"load_from_mark_file()"},{"location":"md/data/dataset_format/#data.dataset_format.WriteController.log_to_mark_file","text":"log_to_mark_file ( log_type , data_i , value = None )","title":"log_to_mark_file()"},{"location":"md/data/dataset_format/#data.dataset_format.WriteController.mark_exist","text":"mark_exist ()","title":"mark_exist()"},{"location":"md/data/dataset_format/#data.dataset_format.WriteController.remove_mark","text":"remove_mark ()","title":"remove_mark()"},{"location":"md/data/dataset_format/#data.dataset_format.WriteController.start_writing","text":"start_writing ( overwrite_allowed = False )","title":"start_writing()"},{"location":"md/data/dataset_format/#data.dataset_format.WriteController.stop_writing","text":"stop_writing ()","title":"stop_writing()"},{"location":"md/data/dataset_format/#data.dataset_format._ClusterMap","text":"Bases: dict [ str , DCT ]","title":"_ClusterMap"},{"location":"md/data/dataset_format/#data.dataset_format._ClusterMap.dataset_node","text":"dataset_node = dataset_node","title":"dataset_node"},{"location":"md/data/dataset_format/#data.dataset_format._ClusterMap.__init__","text":"__init__ ( dataset_node : DatasetNode , * args , ** kwargs ) -> None","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format._ClusterMap.__setitem__","text":"__setitem__ ( __key : Any , __value : Any ) -> None","title":"__setitem__()"},{"location":"md/data/dataset_format/#data.dataset_format._ClusterMap._search_func","text":"_search_func ( indetity_string : str )","title":"_search_func()"},{"location":"md/data/dataset_format/#data.dataset_format._ClusterMap.add_cluster","text":"add_cluster ( cluster : DCT )","title":"add_cluster()"},{"location":"md/data/dataset_format/#data.dataset_format._ClusterMap.get_keywords","text":"get_keywords ()","title":"get_keywords()"},{"location":"md/data/dataset_format/#data.dataset_format._ClusterMap.remove_cluster","text":"remove_cluster ( cluster : DCT )","title":"remove_cluster()"},{"location":"md/data/dataset_format/#data.dataset_format._ClusterMap.search","text":"search ( __key : Any , return_index = False )","title":"search()"},{"location":"md/data/dataset_format/#data.dataset_format._ClusterMap.setdefault","text":"setdefault ( __key : Any , __default : Any = ... ) -> Any","title":"setdefault()"},{"location":"md/data/dataset_format/#data.dataset_format._ClusterMap.update","text":"update ( __m , ** kwargs : Any ) -> None","title":"update()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster","text":"Bases: WriteController , InstanceRegistry , ABC , Generic [ DSNT , VDCT , DCT ] This is a private class representing a data cluster used for managing datasets with a specific format.","title":"_DataCluster"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster--attr","text":"self.dataset_node: DatasetNode self.closed: bool, Control the shielding of reading and writing, if it is true, the instance will not write, and the read will get None register: bool, whether to register to dataset_node _unfinished: bool, whether the data is unfinished _closed: bool, Indicates whether the cluster is closed or open. _readonly: bool, Indicates whether the cluster is read-only or write-enabled. changes_unsaved: bool, Indicates if any changes have been made to the cluster. directory: str, Directory path for the cluster.","title":"attr"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster--property","text":"overwrite_allowed: bool, Control the shielding of writing, cluster_data_num: int, the number of data in the cluster cluster_data_i_upper: int, the upper of the iterator, it is the max index of the iterator + 1 changed_since_opening: bool, Indicates whether the cluster has been modified since last opening.","title":"property"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster--method","text":"","title":"method"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster--abstract-method","text":"len : return the number of data in the cluster keys: return the keys of the cluster values: return the values of the cluster items: return the items of the cluster(key and value) _read: read data from the cluster _write: write data to the cluster _clear: clear all data of the cluster _copyto: copy the cluster to dst _merge: merge the cluster to self, the cluster must has the same type as self","title":"abstract method:"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster--recommend-to-implement","text":"_init_attr: initialize additional attributes specified by subclasses. _update_cluster_inc: update the incremental modification of the cluster after writing _update_cluster_all: update the state of the cluster after writing getitem : return the value of the key setitem : set the value of the key _open: operation when open the cluster _close: operation when close the cluster _start_writing: operation when start writing _stop_writing: operation when stop writing check_key: check if the key is valid","title":"recommend to implement:"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster--not-need-to-implement","text":"iter : return the iterator of the cluster open: open the cluster for operation. close: close the cluster, preventing further operations. is_close: check if the cluster is closed. set_readonly: set the cluster as read-only or write-enabled. set_writable: set the cluster as writable or read-only. set_overwrite_allowed: set the cluster as writable or read-only. is_readonly: check if the cluster is read-only. is_writeable: check if the cluster is writable. is_overwrite_allowed: check if the cluster is writable. _read_decorator: decorator function to handle reading operations when the cluster is closed. _write_decorator: decorator function to handle writing operations when the cluster is closed or read-only. clear: clear any data in the cluster. Subclasses may implement _clear. read: read data from the cluster. Subclasses must implement _read. write: write data to the cluster. Subclasses must implement _write. copyto: copy the cluster to dst merge: merge the cluster to self, the cluster must has the same type as self start_writing: start writing stop_writing: stop writing repr : return the representation of the cluster register_to_format: register the cluster to dataset_node","title":"not need to implement:"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._DCT","text":"_DCT = TypeVar ( '_DCT' , bound = '_DataCluster' )","title":"_DCT"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._VDCT","text":"_VDCT = TypeVar ( '_VDCT' )","title":"_VDCT"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._changed","text":"_changed = False","title":"_changed"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._data_i_upper","text":"_data_i_upper = 0","title":"_data_i_upper"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._error_to_load","text":"_error_to_load = False","title":"_error_to_load"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._unfinished","text":"_unfinished = self . mark_exist ()","title":"_unfinished"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._unfinished_operation","text":"_unfinished_operation = self . dataset_node . _unfinished_operation","title":"_unfinished_operation"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.changed_since_opening","text":"changed_since_opening Indicates whether the cluster has been modified since last opening.","title":"changed_since_opening"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.cluster_data_i_upper","text":"cluster_data_i_upper","title":"cluster_data_i_upper"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.cluster_data_num","text":"cluster_data_num","title":"cluster_data_num"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.continuous","text":"continuous","title":"continuous"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.dataset_node","text":"dataset_node : DSNT = dataset_node","title":"dataset_node"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.directory","text":"directory = os . path . normpath ( os . path . join ( self . dataset_node . directory , self . sub_dir ))","title":"directory"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.name","text":"name = name","title":"name"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.overwrite_allowed","text":"overwrite_allowed Property that returns whether the cluster format allows write operations.","title":"overwrite_allowed"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.register","text":"register = register","title":"register"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.sub_dir","text":"sub_dir = os . path . normpath ( sub_dir )","title":"sub_dir"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._Force","text":"","title":"_Force"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._Force.force","text":"force = force","title":"force"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._Force.obj","text":"obj : _DataCluster = obj","title":"obj"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._Force.orig_closed","text":"orig_closed = None","title":"orig_closed"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._Force.orig_overwrite_allowed","text":"orig_overwrite_allowed = None","title":"orig_overwrite_allowed"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._Force.orig_readonly","text":"orig_readonly = None","title":"orig_readonly"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._Force.writing","text":"writing = writing","title":"writing"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._Force.__enter__","text":"__enter__ ()","title":"__enter__()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._Force.__exit__","text":"__exit__ ( exc_type , exc_value , traceback )","title":"__exit__()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._Force.__init__","text":"__init__ ( obj , force = False , writing = False ) -> None","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._load_in","text":"Bases: _WriteMeta [ _DCT , _VDCT ]","title":"_load_in"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._load_in.IO_TYPE","text":"IO_TYPE = WriteController . LOG_APPEND","title":"IO_TYPE"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._load_in.__call__","text":"__call__ ( src , dst , * args , force = False , ** kwargs ) -> Any","title":"__call__()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._load_in.check_value","text":"check_value ( dst , ** kwargs ) -> bool","title":"check_value()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._load_in.is_overwriting","text":"is_overwriting ( src , dst , ** kwargs )","title":"is_overwriting()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._move","text":"Bases: _WriteMeta [ _DCT , _VDCT ]","title":"_move"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._move.IO_TYPE","text":"IO_TYPE = WriteController . LOG_MOVE","title":"IO_TYPE"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._move.__call__","text":"__call__ ( src , dst , * args , force = False , ** kwargs ) -> Any","title":"__call__()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._move.check_key","text":"check_key ( key , ** kwargs ) -> bool","title":"check_key()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._move.check_value","text":"check_value ( value , ** kwargs ) -> bool","title":"check_value()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._move.is_overwriting","text":"is_overwriting ( data_i , value , ** kwargs )","title":"is_overwriting()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._read","text":"Bases: _ReadMeta [ _DCT , _VDCT ]","title":"_read"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._read.check_key","text":"check_key ( key , ** kwargs ) -> bool","title":"check_key()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._remove","text":"Bases: _WriteMeta [ _DCT , _VDCT ]","title":"_remove"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._remove.IO_TYPE","text":"IO_TYPE = WriteController . LOG_REMOVE","title":"IO_TYPE"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._remove.__call__","text":"__call__ ( key , * args , force = False , ** kwargs ) -> Any","title":"__call__()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._remove.check_key","text":"check_key ( key , ** kwargs ) -> bool","title":"check_key()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._remove.is_overwriting","text":"is_overwriting ( data_i , value , ** kwargs )","title":"is_overwriting()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._write","text":"Bases: _WriteMeta [ _DCT , _VDCT ]","title":"_write"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._write.IO_TYPE","text":"IO_TYPE = WriteController . LOG_APPEND","title":"IO_TYPE"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._write.is_overwriting","text":"is_overwriting ( data_i , value , ** kwargs )","title":"is_overwriting()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.__getitem__","text":"__getitem__ ( data_i : Union [ int , slice ])","title":"__getitem__()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.__init__","text":"__init__ ( dataset_node : DSNT , sub_dir : str , register = True , name = '' , * args , ** kwargs ) -> None Initialize the data cluster with the provided dataset_node, sub_dir, and registration flag.","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.__iter__","text":"__iter__ () -> Iterable [ VDCT ]","title":"__iter__()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.__len__","text":"__len__ () Returns the number of data in the cluster.","title":"__len__()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.__repr__","text":"__repr__ ()","title":"__repr__()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.__setitem__","text":"__setitem__ ( data_i , value : VDCT )","title":"__setitem__()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._close","text":"_close ()","title":"_close()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._init_attr","text":"_init_attr ( * args , ** kwargs ) Method to initialize additional attributes specified by subclasses.","title":"_init_attr()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._init_identity_paramenter","text":"_init_identity_paramenter ( dataset_node : DSNT , sub_dir : str , register = True , name = '' , * args , ** kwargs )","title":"_init_identity_paramenter()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._open","text":"_open () Method to open the cluster for operation.","title":"_open()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._read_decorator","text":"_read_decorator ( iometa : _ReadMeta )","title":"_read_decorator()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._read_decorator--brief","text":"Decorator function to handle reading operations when the cluster is closed. if the cluster is closed, the decorated function will not be executed and return None.","title":"brief"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._read_decorator--parameter","text":"func: Callable, the decorated function","title":"parameter"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._start_writing","text":"_start_writing ()","title":"_start_writing()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._stop_writing","text":"_stop_writing ()","title":"_stop_writing()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._update_cluster_all","text":"_update_cluster_all ( ** kwargs )","title":"_update_cluster_all()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._update_cluster_inc","text":"_update_cluster_inc ( iometa : _IOMeta , data_i , value , ** kwargs ) update the state of the cluster after writing","title":"_update_cluster_inc()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._write_decorator","text":"_write_decorator ( iometa : _WriteMeta )","title":"_write_decorator()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._write_decorator--brief","text":"Decorator function to handle writing operations when the cluster is closed or read-only. if the cluster is closed, the decorated function will not be executed and return None. if the cluster is read-only and the decorated function is a writing operation, the decorated function will not be executed and return None.","title":"brief"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster._write_decorator--parameter","text":"func: Callable, the decorated function","title":"parameter"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.check_key","text":"check_key ( key ) -> bool","title":"check_key()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.choose_unfinished_operation","text":"choose_unfinished_operation ( obj ) skip clear the unfinished data try to rollback the unfinished data exit\"))","title":"choose_unfinished_operation()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.clear","text":"clear ( * , force = False , ignore_warning = False ) Method to clear any data in the cluster. Subclasses may implement this method. * it is dargerous","title":"clear()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.close","text":"close () Method to close the cluster, preventing further operations.","title":"close()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.copyto","text":"copyto ( dst : str , * args , ** kwargs )","title":"copyto()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.gen_identity_string","text":"gen_identity_string ( dataset_node : DatasetNode , sub_dir , name , * args , ** kwargs )","title":"gen_identity_string()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.get_file_path","text":"get_file_path ( data_i , ** kwargs )","title":"get_file_path()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.get_writing_mark_file","text":"get_writing_mark_file ()","title":"get_writing_mark_file()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.identity_string","text":"identity_string ()","title":"identity_string()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.is_closed","text":"is_closed ( with_warning = False ) Method to check if the cluster is closed.","title":"is_closed()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.is_opened","text":"is_opened ()","title":"is_opened()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.is_overwrite_allowed","text":"is_overwrite_allowed ()","title":"is_overwrite_allowed()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.is_readonly","text":"is_readonly ( with_warning = False ) Method to check if the cluster is read-only.","title":"is_readonly()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.is_writable","text":"is_writable ()","title":"is_writable()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.items","text":"items () -> Iterable [ tuple [ Any , VDCT ]]","title":"items()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.key_identity_string","text":"key_identity_string ()","title":"key_identity_string()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.keys","text":"keys () -> Iterable [ Any ]","title":"keys()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.make_continuous","text":"make_continuous ( * args , ** kwargs )","title":"make_continuous()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.merge_from","text":"merge_from ( src : _DataCluster , * args , ** kwargs )","title":"merge_from()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.open","text":"open ()","title":"open()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.parse_identity_string","text":"parse_identity_string ( identity_string )","title":"parse_identity_string()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.process_unfinished","text":"process_unfinished ()","title":"process_unfinished()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.register_to_dataset","text":"register_to_dataset ()","title":"register_to_dataset()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.set_overwrite_allowed","text":"set_overwrite_allowed ( overwrite_allowed = True ) Method to set the cluster as writable or read-only.","title":"set_overwrite_allowed()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.set_readonly","text":"set_readonly ( readonly = True ) Method to set the cluster as read-only or write-enabled.","title":"set_readonly()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.set_writable","text":"set_writable ( writable = True ) Method to set the cluster as writable or read-only.","title":"set_writable()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.start_writing","text":"start_writing ( overwrite_allowed = False ) rewrite the method of WriteController","title":"start_writing()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.stop_writing","text":"stop_writing () rewrite the method of WriteController","title":"stop_writing()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.unregister_from_dataset","text":"unregister_from_dataset ()","title":"unregister_from_dataset()"},{"location":"md/data/dataset_format/#data.dataset_format._DataCluster.values","text":"values () -> Iterable [ VDCT ]","title":"values()"},{"location":"md/data/dataset_format/#data.dataset_format._IOMeta","text":"Bases: Generic [ DCT , VDCT ] the position parameter of 'record', '_call' , ' call ' must be the same","title":"_IOMeta"},{"location":"md/data/dataset_format/#data.dataset_format._IOMeta.IO_TYPE","text":"IO_TYPE = WriteController . LOG_READ","title":"IO_TYPE"},{"location":"md/data/dataset_format/#data.dataset_format._IOMeta._kwargs","text":"_kwargs = {}","title":"_kwargs"},{"location":"md/data/dataset_format/#data.dataset_format._IOMeta.cluster","text":"cluster : DCT = cluster","title":"cluster"},{"location":"md/data/dataset_format/#data.dataset_format._IOMeta.warning_info","text":"warning_info : str = 'no description'","title":"warning_info"},{"location":"md/data/dataset_format/#data.dataset_format._IOMeta.__init__","text":"__init__ ( cluster : DCT ) -> None","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format._IOMeta.check_key","text":"check_key ( key , ** kwargs ) -> bool","title":"check_key()"},{"location":"md/data/dataset_format/#data.dataset_format._IOMeta.check_value","text":"check_value ( value , ** kwargs ) -> bool","title":"check_value()"},{"location":"md/data/dataset_format/#data.dataset_format._IOMeta.record","text":"record ( ** kwargs )","title":"record()"},{"location":"md/data/dataset_format/#data.dataset_format._LinemodFormat_sub1","text":"Bases: LinemodFormat","title":"_LinemodFormat_sub1"},{"location":"md/data/dataset_format/#data.dataset_format._LinemodFormat_sub1.rgb_elements","text":"rgb_elements = Elements ( self , 'rgb' , read_func = cv2 . imread , write_func = cv2 . imwrite , suffix = '.jpg' )","title":"rgb_elements"},{"location":"md/data/dataset_format/#data.dataset_format._LinemodFormat_sub1._MasksElements","text":"Bases: _MasksElements","title":"_MasksElements"},{"location":"md/data/dataset_format/#data.dataset_format._LinemodFormat_sub1._MasksElements._read","text":"_read ( data_i , ** kwargs ) -> dict [ int , ndarray ]","title":"_read()"},{"location":"md/data/dataset_format/#data.dataset_format._LinemodFormat_sub1._MasksElements._write","text":"_write ( data_i , value : dict [ int , ndarray ], subdir = '' , appname = '' , ** kwargs )","title":"_write()"},{"location":"md/data/dataset_format/#data.dataset_format._LinemodFormat_sub1.__init__","text":"__init__ ( directory , clear = False ) -> None","title":"__init__()"},{"location":"md/data/dataset_format/#data.dataset_format._LinemodFormat_sub1.read_one","text":"read_one ( data_i , ** kwargs )","title":"read_one()"},{"location":"md/data/dataset_format/#data.dataset_format._ReadMeta","text":"Bases: _IOMeta [ DCT , VDCT ] , ABC","title":"_ReadMeta"},{"location":"md/data/dataset_format/#data.dataset_format._ReadMeta.__call__","text":"__call__ ( key , * args , force = False , ** kwargs ) -> VDCT","title":"__call__()"},{"location":"md/data/dataset_format/#data.dataset_format._ReadMeta._call","text":"_call ( key , ** kwargs : Any ) -> VDCT","title":"_call()"},{"location":"md/data/dataset_format/#data.dataset_format._ReadMeta.record","text":"record ( key , * args , ** kwargs )","title":"record()"},{"location":"md/data/dataset_format/#data.dataset_format._WriteMeta","text":"Bases: _IOMeta [ DCT , VDCT ] , ABC","title":"_WriteMeta"},{"location":"md/data/dataset_format/#data.dataset_format._WriteMeta--abstractmethod","text":"_call: the function to call when write is_overwriting: check if the data is overwriting","title":"abstractmethod"},{"location":"md/data/dataset_format/#data.dataset_format._WriteMeta--recommend-to-implement","text":"check_key: check if the key is valid check_value: check if the value is valid","title":"recommend to implement"},{"location":"md/data/dataset_format/#data.dataset_format._WriteMeta.__call__","text":"__call__ ( key , value , * args , force = False , ** kwargs ) -> Any","title":"__call__()"},{"location":"md/data/dataset_format/#data.dataset_format._WriteMeta._call","text":"_call ( key , value , ** kwargs : Any )","title":"_call()"},{"location":"md/data/dataset_format/#data.dataset_format._WriteMeta.is_overwriting","text":"is_overwriting ( key , value , ** kwargs )","title":"is_overwriting()"},{"location":"md/data/dataset_format/#data.dataset_format._WriteMeta.record","text":"record ( key , value , ** kwargs )","title":"record()"},{"location":"md/data/dataset_format/#data.dataset_format._cvt_old_element_map","text":"_cvt_old_element_map ( dataset_node : DatasetNode , sub_dir : str , suffix : str )","title":"_cvt_old_element_map()"},{"location":"md/data/dataset_format/#data.dataset_format.as_dict","text":"as_dict ( ids , objs )","title":"as_dict()"},{"location":"md/data/dataset_format/#data.dataset_format.dataset_test","text":"dataset_test ( ds : DatasetNode , dst_ds : DatasetNode )","title":"dataset_test()"},{"location":"md/data/dataset_format/#data.dataset_format.deserialize_object","text":"deserialize_object ( serialized_file_path )","title":"deserialize_object()"},{"location":"md/data/dataset_format/#data.dataset_format.get_mainname","text":"get_mainname ( path )","title":"get_mainname()"},{"location":"md/data/dataset_format/#data.dataset_format.loadtxt_func","text":"loadtxt_func ( shape : tuple [ int ])","title":"loadtxt_func()"},{"location":"md/data/dataset_format/#data.dataset_format.remove_duplicates","text":"remove_duplicates ( input_list )","title":"remove_duplicates()"},{"location":"md/data/dataset_format/#data.dataset_format.savetxt_func","text":"savetxt_func ( fmt =... )","title":"savetxt_func()"},{"location":"md/data/dataset_format/#data.dataset_format.serialize_object","text":"serialize_object ( file_path , obj : dict )","title":"serialize_object()"},{"location":"md/data/dataset_format/#data.dataset_format.zip_dict","text":"zip_dict ( ids : list [ int ], item : Union [ Iterable , None , Any ], func = lambda : x )","title":"zip_dict()"},{"location":"md/data/mesh_manager/","text":"mesh_manager MeshManager _instance class-attribute instance-attribute _instance = None class_num property class_num landmark_info_path instance-attribute landmark_info_path = os . path . join ( self . root , 'landmarks.json' ) model_bbox_3d instance-attribute model_bbox_3d = {} model_diameter instance-attribute model_diameter = {} model_dirs instance-attribute model_dirs : dict [ int , str ] = {} model_ldmk_3d instance-attribute model_ldmk_3d = {} model_meshes instance-attribute model_meshes = {} model_names instance-attribute model_names : dict [ int , str ] = model_names model_symmetries instance-attribute model_symmetries = {} models_info_path instance-attribute models_info_path = os . path . join ( self . root , 'models_info.json' ) root instance-attribute root = root __init__ __init__ ( root , model_names : dict [ int , str ] = {}, load_all = False , modify_class_id_pairs : list [ tuple [ int ]] = []) -> None __new__ __new__ ( * arg , ** kw ) export_meta export_meta ( class_id : int ) farthest_point_sample staticmethod farthest_point_sample ( point_cloud , npoint ) Input: point_cloud: pointcloud data, [N, 3] npoint: number of samples Return: centroids: sampled pointcloud index, [B, npoint] get_bbox_3d get_bbox_3d ( class_id : int ) get_ldmk_3d get_ldmk_3d ( class_id : int ) get_meta_dict get_meta_dict () get_model_diameter get_model_diameter ( class_id : int ) get_model_mesh get_model_mesh ( class_id : int ) -> np . ndarray get_model_name get_model_name ( class_id : int ) -> str get_model_normal get_model_normal ( class_id : int ) -> np . ndarray get_model_pcd get_model_pcd ( class_id : int ) -> np . ndarray get_model_symmetries get_model_symmetries ( class_id : int ) load_landmarks load_landmarks ( landmark_info_path : str ) load_model load_model ( model_id : int ) load_models_info load_models_info ( models_info_path : str ) 1 _ 7 /| /| Z 3 _ 5 | |__Y | 0 _ |_6 / |/ |/ X 2 _____4 modify_class_id modify_class_id ( modify_class_id_pairs ) MeshMeta bbox_3d instance-attribute bbox_3d : np . ndarray = bbox_3d class_id instance-attribute class_id = class_id diameter instance-attribute diameter : float = diameter ldmk_3d instance-attribute ldmk_3d : np . ndarray = ldmk_3d mesh instance-attribute mesh = mesh name instance-attribute name = name normals_array property normals_array points_array property points_array symmetries instance-attribute symmetries : dict = symmetries tris_array property tris_array __init__ __init__ ( mesh , bbox_3d : np . ndarray = None , symmetries : dict = None , diameter : float = None , ldmk_3d : np . ndarray = None , name = '' , class_id =- 1 ) -> None __repr__ __repr__ () -> str transform transform ( posture : Union [ Posture , np . ndarray ], copy = True ) Voxelized entity_cube instance-attribute entity_cube = entity_cube . astype ( np . uint8 ) entity_indices instance-attribute entity_indices = np . array ( np . where ( self . entity_cube )) . T entity_query instance-attribute entity_query = np . full ( self . entity_cube . shape , - 1 , np . int64 ) orig_geometry instance-attribute orig_geometry = orig_geometry restore_mat instance-attribute restore_mat = restore_mat shape property shape surf_indices instance-attribute surf_indices = np . array ( np . where ( self . surf_cube )) . T surf_normals instance-attribute surf_normals = self . calc_surf_normal () surf_points instance-attribute surf_points = self . restore_mat [: 3 , : 3 ] . dot ( self . surf_indices . T ) . T + self . restore_mat [: 3 , 3 ] surf_query instance-attribute surf_query = np . full ( self . surf_cube . shape , - 1 , np . int64 ) __init__ __init__ ( entity_cube : np . ndarray , restore_mat : np . ndarray , orig_geometry = None ) -> None _get_restore_mat staticmethod _get_restore_mat ( origin : np . ndarray , voxel_size : float ) _process_raw_voxel_grid staticmethod _process_raw_voxel_grid ( raw_voxel_grid : o3d . geometry . VoxelGrid ) raw_voxel_grid: o3d.geometry.VoxelGrid auto_voxel_size staticmethod auto_voxel_size ( geometry ) -> float calc_surf_normal calc_surf_normal () fill_3d staticmethod fill_3d ( voxel_array : np . ndarray ) \u6cbf\u4e0d\u540c\u65b9\u5411\u7d2f\u52a0\uff0c\u7d2f\u52a0\u503c\u4e3a\u5947\u6570\u7684\u662f\u5185\u90e8 from_mesh staticmethod from_mesh ( o3d_mesh , voxel_size = None ) from_pcd staticmethod from_pcd ( o3d_pcd , voxel_size = None ) query_surf_normal query_surf_normal ( indices ) query_surf_points query_surf_points ( indices ) split_entity_cube split_entity_cube ( cube : np . ndarray ) get_bbox_connections get_bbox_connections ( bbox_3d_proj : np . ndarray ) 1 _ 7 /| /| Z 3 _ 5 | |__Y | 0 _ |_6 / |/ |/ X 2 _____4 params bbox_3d_proj: [..., B, (x,y)] return lines: [..., ((x1,x2), (y1,y2)), 12]","title":"mesh_manager"},{"location":"md/data/mesh_manager/#mesh_manager","text":"","title":"mesh_manager"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager","text":"","title":"MeshManager"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager._instance","text":"_instance = None","title":"_instance"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.class_num","text":"class_num","title":"class_num"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.landmark_info_path","text":"landmark_info_path = os . path . join ( self . root , 'landmarks.json' )","title":"landmark_info_path"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.model_bbox_3d","text":"model_bbox_3d = {}","title":"model_bbox_3d"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.model_diameter","text":"model_diameter = {}","title":"model_diameter"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.model_dirs","text":"model_dirs : dict [ int , str ] = {}","title":"model_dirs"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.model_ldmk_3d","text":"model_ldmk_3d = {}","title":"model_ldmk_3d"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.model_meshes","text":"model_meshes = {}","title":"model_meshes"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.model_names","text":"model_names : dict [ int , str ] = model_names","title":"model_names"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.model_symmetries","text":"model_symmetries = {}","title":"model_symmetries"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.models_info_path","text":"models_info_path = os . path . join ( self . root , 'models_info.json' )","title":"models_info_path"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.root","text":"root = root","title":"root"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.__init__","text":"__init__ ( root , model_names : dict [ int , str ] = {}, load_all = False , modify_class_id_pairs : list [ tuple [ int ]] = []) -> None","title":"__init__()"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.__new__","text":"__new__ ( * arg , ** kw )","title":"__new__()"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.export_meta","text":"export_meta ( class_id : int )","title":"export_meta()"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.farthest_point_sample","text":"farthest_point_sample ( point_cloud , npoint ) Input: point_cloud: pointcloud data, [N, 3] npoint: number of samples Return: centroids: sampled pointcloud index, [B, npoint]","title":"farthest_point_sample()"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.get_bbox_3d","text":"get_bbox_3d ( class_id : int )","title":"get_bbox_3d()"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.get_ldmk_3d","text":"get_ldmk_3d ( class_id : int )","title":"get_ldmk_3d()"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.get_meta_dict","text":"get_meta_dict ()","title":"get_meta_dict()"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.get_model_diameter","text":"get_model_diameter ( class_id : int )","title":"get_model_diameter()"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.get_model_mesh","text":"get_model_mesh ( class_id : int ) -> np . ndarray","title":"get_model_mesh()"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.get_model_name","text":"get_model_name ( class_id : int ) -> str","title":"get_model_name()"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.get_model_normal","text":"get_model_normal ( class_id : int ) -> np . ndarray","title":"get_model_normal()"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.get_model_pcd","text":"get_model_pcd ( class_id : int ) -> np . ndarray","title":"get_model_pcd()"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.get_model_symmetries","text":"get_model_symmetries ( class_id : int )","title":"get_model_symmetries()"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.load_landmarks","text":"load_landmarks ( landmark_info_path : str )","title":"load_landmarks()"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.load_model","text":"load_model ( model_id : int )","title":"load_model()"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.load_models_info","text":"load_models_info ( models_info_path : str ) 1 _ 7 /| /| Z 3 _ 5 | |__Y | 0 _ |_6 / |/ |/ X 2 _____4","title":"load_models_info()"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshManager.modify_class_id","text":"modify_class_id ( modify_class_id_pairs )","title":"modify_class_id()"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshMeta","text":"","title":"MeshMeta"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshMeta.bbox_3d","text":"bbox_3d : np . ndarray = bbox_3d","title":"bbox_3d"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshMeta.class_id","text":"class_id = class_id","title":"class_id"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshMeta.diameter","text":"diameter : float = diameter","title":"diameter"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshMeta.ldmk_3d","text":"ldmk_3d : np . ndarray = ldmk_3d","title":"ldmk_3d"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshMeta.mesh","text":"mesh = mesh","title":"mesh"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshMeta.name","text":"name = name","title":"name"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshMeta.normals_array","text":"normals_array","title":"normals_array"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshMeta.points_array","text":"points_array","title":"points_array"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshMeta.symmetries","text":"symmetries : dict = symmetries","title":"symmetries"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshMeta.tris_array","text":"tris_array","title":"tris_array"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshMeta.__init__","text":"__init__ ( mesh , bbox_3d : np . ndarray = None , symmetries : dict = None , diameter : float = None , ldmk_3d : np . ndarray = None , name = '' , class_id =- 1 ) -> None","title":"__init__()"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshMeta.__repr__","text":"__repr__ () -> str","title":"__repr__()"},{"location":"md/data/mesh_manager/#data.mesh_manager.MeshMeta.transform","text":"transform ( posture : Union [ Posture , np . ndarray ], copy = True )","title":"transform()"},{"location":"md/data/mesh_manager/#data.mesh_manager.Voxelized","text":"","title":"Voxelized"},{"location":"md/data/mesh_manager/#data.mesh_manager.Voxelized.entity_cube","text":"entity_cube = entity_cube . astype ( np . uint8 )","title":"entity_cube"},{"location":"md/data/mesh_manager/#data.mesh_manager.Voxelized.entity_indices","text":"entity_indices = np . array ( np . where ( self . entity_cube )) . T","title":"entity_indices"},{"location":"md/data/mesh_manager/#data.mesh_manager.Voxelized.entity_query","text":"entity_query = np . full ( self . entity_cube . shape , - 1 , np . int64 )","title":"entity_query"},{"location":"md/data/mesh_manager/#data.mesh_manager.Voxelized.orig_geometry","text":"orig_geometry = orig_geometry","title":"orig_geometry"},{"location":"md/data/mesh_manager/#data.mesh_manager.Voxelized.restore_mat","text":"restore_mat = restore_mat","title":"restore_mat"},{"location":"md/data/mesh_manager/#data.mesh_manager.Voxelized.shape","text":"shape","title":"shape"},{"location":"md/data/mesh_manager/#data.mesh_manager.Voxelized.surf_indices","text":"surf_indices = np . array ( np . where ( self . surf_cube )) . T","title":"surf_indices"},{"location":"md/data/mesh_manager/#data.mesh_manager.Voxelized.surf_normals","text":"surf_normals = self . calc_surf_normal ()","title":"surf_normals"},{"location":"md/data/mesh_manager/#data.mesh_manager.Voxelized.surf_points","text":"surf_points = self . restore_mat [: 3 , : 3 ] . dot ( self . surf_indices . T ) . T + self . restore_mat [: 3 , 3 ]","title":"surf_points"},{"location":"md/data/mesh_manager/#data.mesh_manager.Voxelized.surf_query","text":"surf_query = np . full ( self . surf_cube . shape , - 1 , np . int64 )","title":"surf_query"},{"location":"md/data/mesh_manager/#data.mesh_manager.Voxelized.__init__","text":"__init__ ( entity_cube : np . ndarray , restore_mat : np . ndarray , orig_geometry = None ) -> None","title":"__init__()"},{"location":"md/data/mesh_manager/#data.mesh_manager.Voxelized._get_restore_mat","text":"_get_restore_mat ( origin : np . ndarray , voxel_size : float )","title":"_get_restore_mat()"},{"location":"md/data/mesh_manager/#data.mesh_manager.Voxelized._process_raw_voxel_grid","text":"_process_raw_voxel_grid ( raw_voxel_grid : o3d . geometry . VoxelGrid ) raw_voxel_grid: o3d.geometry.VoxelGrid","title":"_process_raw_voxel_grid()"},{"location":"md/data/mesh_manager/#data.mesh_manager.Voxelized.auto_voxel_size","text":"auto_voxel_size ( geometry ) -> float","title":"auto_voxel_size()"},{"location":"md/data/mesh_manager/#data.mesh_manager.Voxelized.calc_surf_normal","text":"calc_surf_normal ()","title":"calc_surf_normal()"},{"location":"md/data/mesh_manager/#data.mesh_manager.Voxelized.fill_3d","text":"fill_3d ( voxel_array : np . ndarray ) \u6cbf\u4e0d\u540c\u65b9\u5411\u7d2f\u52a0\uff0c\u7d2f\u52a0\u503c\u4e3a\u5947\u6570\u7684\u662f\u5185\u90e8","title":"fill_3d()"},{"location":"md/data/mesh_manager/#data.mesh_manager.Voxelized.from_mesh","text":"from_mesh ( o3d_mesh , voxel_size = None )","title":"from_mesh()"},{"location":"md/data/mesh_manager/#data.mesh_manager.Voxelized.from_pcd","text":"from_pcd ( o3d_pcd , voxel_size = None )","title":"from_pcd()"},{"location":"md/data/mesh_manager/#data.mesh_manager.Voxelized.query_surf_normal","text":"query_surf_normal ( indices )","title":"query_surf_normal()"},{"location":"md/data/mesh_manager/#data.mesh_manager.Voxelized.query_surf_points","text":"query_surf_points ( indices )","title":"query_surf_points()"},{"location":"md/data/mesh_manager/#data.mesh_manager.Voxelized.split_entity_cube","text":"split_entity_cube ( cube : np . ndarray )","title":"split_entity_cube()"},{"location":"md/data/mesh_manager/#data.mesh_manager.get_bbox_connections","text":"get_bbox_connections ( bbox_3d_proj : np . ndarray ) 1 _ 7 /| /| Z 3 _ 5 | |__Y | 0 _ |_6 / |/ |/ X 2 _____4","title":"get_bbox_connections()"},{"location":"md/data/mesh_manager/#data.mesh_manager.get_bbox_connections--params","text":"bbox_3d_proj: [..., B, (x,y)]","title":"params"},{"location":"md/data/mesh_manager/#data.mesh_manager.get_bbox_connections--return","text":"lines: [..., ((x1,x2), (y1,y2)), 12]","title":"return"},{"location":"md/data/spliter/","text":"spliter SFH module-attribute SFH = TypeVar ( 'SFH' , bound = 'SpliterFilesHandle' ) SP module-attribute SP = TypeVar ( 'SP' , bound = 'Spliter' ) SPG module-attribute SPG = TypeVar ( 'SPG' , bound = 'SpliterGroup' ) VDMT module-attribute VDMT = TypeVar ( 'VDMT' ) spliter(DisunifiedFilesHandle) .json \u7ef4\u62a4\u4e00\u4e2atable, \u884c\uff1aelem_i, \u5217\uff1asub_set, \u503c\uff1abool \u884c\u3001\u5217\u589e\u5220\uff0c\u5143\u7d20\u8bfb\u53d6\uff1b\u8bbe\u7f6eidx\u6240\u5728\u7684subset\uff1b\u662f\u5426\u72ec\u5360 splitergroup(Cluster) \u7ef4\u62a4\u591a\u4e2aspliter, \u6bcf\u4e2aspliter\u662f\u4e00\u4e2a split_mode Spliter Bases: DisunifiedFileCluster [ SpliterFilesHandle , SP , SPG , Table [ int , str , bool ]] , Generic [ SP , SPG ] ALWAYS_ALLOW_WRITE class-attribute instance-attribute ALWAYS_ALLOW_WRITE = True DEFAULT_SUB_SET class-attribute instance-attribute DEFAULT_SUB_SET = [ KW_TRAIN , KW_VAL ] FILESHANDLE_TYPE class-attribute instance-attribute FILESHANDLE_TYPE = SpliterFilesHandle KW_TRAIN class-attribute instance-attribute KW_TRAIN = 'train' KW_VAL class-attribute instance-attribute KW_VAL = 'val' SPLIT_FILE class-attribute instance-attribute SPLIT_FILE = 'split.json' _ELEM_BY_CACHE class-attribute instance-attribute _ELEM_BY_CACHE = True _IS_ELEM class-attribute instance-attribute _IS_ELEM = True _next_valid_elem_i instance-attribute _next_valid_elem_i = 0 _undefined_idx instance-attribute _undefined_idx = [] elem_idx property elem_idx exclusive property writable exclusive split_fileshandle instance-attribute split_fileshandle : SpliterFilesHandle = self . FILESHANDLE_TYPE . from_name ( self , self . SPLIT_FILE ) split_table property split_table split_table_data property split_table_data subsets property subsets _modify_elem_key Bases: _modify_key ['Spliter', dict [ int , Any ], DictLikeHandle ] OPER_ELEM class-attribute instance-attribute OPER_ELEM = True split_table property split_table : Table [ int , str , bool ] is_overwriting is_overwriting ( dst : int ) operate_elem operate_elem ( src , dst , values : dict , ** other_paras ) _read_elem Bases: _read ['Spliter', dict [ int , Any ], DictLikeHandle ] OPER_ELEM class-attribute instance-attribute OPER_ELEM = True split_table property split_table : Table [ int , str , bool ] operate_elem operate_elem ( src , dst , value , ** other_paras ) _remove_elem Bases: _remove ['Spliter', dict [ int , Any ], DictLikeHandle ] OPER_ELEM class-attribute instance-attribute OPER_ELEM = True is_overwriting is_overwriting ( dst : int ) operate_elem operate_elem ( src , dst , value , ** other_paras ) _write_elem Bases: _write ['Spliter', dict [ int , Any ], DictLikeHandle ] OPER_ELEM class-attribute instance-attribute OPER_ELEM = True split_table property split_table : Table [ int , str , bool ] is_overwriting is_overwriting ( dst : int ) operate_elem operate_elem ( src , dst , values : dict [ str , Any ], ** other_paras ) __init__ __init__ ( dataset_node : Union [ str , DatasetNode ], mapping_name : str , * args , subsets = None , ** kwargs ) -> None __str__ __str__ () -> str _decide_subset staticmethod _decide_subset ( rlts : list [ list ], split_rate : tuple [ float ]) _set_fileshandle _set_fileshandle ( data_i , fh : DictLikeHandle ) add_elem_idx add_elem_idx ( elem_i : int ) add_subset add_subset ( subset : str ) clear_subset clear_subset () elem_keys elem_keys () from_txt classmethod from_txt ( txt_name_list : list [ str ]) gen_split staticmethod gen_split ( idx_array , split_rate , split_num ) get_idx_dict get_idx_dict () get_idx_list get_idx_list ( subset : Union [ str , int ]) get_nums get_nums () init_io_metas init_io_metas () merge_elem_from merge_elem_from ( src_data_map : Spliter , * , force = False ) modify_elem_key modify_elem_key ( src : int , dst : int , * , force = False , ** other_paras ) -> dict one_defined one_defined ( elem_i : int ) process_split_rate staticmethod process_split_rate ( split_rate : Union [ float , Iterable [ float ], dict [ str , float ]], split_num : Union [ int , list [ str ]]) qurey_one qurey_one ( elem_i : int , subset : str ) qurey_one_elem qurey_one_elem ( elem_i : int ) qurey_one_subset qurey_one_subset ( subset : str ) read_elem read_elem ( src : Union [ int , Iterable [ int ]], * , force = False , ** other_paras ) -> Union [ dict [ str , bool ], None ] remove_elem remove_elem ( dst : int , remove_both = False , * , force = False , ** other_paras ) -> dict remove_elem_idx remove_elem_idx ( elem_i : int ) remove_subset remove_subset ( subset : str ) save_as_txt save_as_txt ( mask_mode = True ) set_all_by_rate set_all_by_rate ( split_rate ) set_one set_one ( elem_i : int , subset : str , value : bool ) set_one_by_rate set_one_by_rate ( elem_i , split_rate ) set_one_elem set_one_elem ( elem_i , subsets : dict [ str , bool ]) set_one_subset set_one_subset ( subset : str , elems : Union [ dict [ int , bool ], tuple [ int , ... ]]) sort_elem sort_elem () stop_writing_hook stop_writing_hook () write_elem write_elem ( dst : int , value : Union [ Any , dict [ int , Any ]], * , force = False , ** other_paras ) -> dict SpliterFilesHandle Bases: DisunifiedFilesHandle [ SP , Table [ int , str , bool ]] DEFAULT_READ_FUNC class-attribute instance-attribute DEFAULT_READ_FUNC = Table . from_json DEFAULT_VALUE_INIT_FUNC class-attribute instance-attribute DEFAULT_VALUE_INIT_FUNC = partial ( Table , row_name_type = int , col_name_type = str , default_value_type = bool ) DEFAULT_VALUE_TYPE class-attribute instance-attribute DEFAULT_VALUE_TYPE = Table DEFAULT_WRITE_FUNC class-attribute instance-attribute DEFAULT_WRITE_FUNC = Table . to_json LOAD_CACHE_ON_INIT class-attribute instance-attribute LOAD_CACHE_ON_INIT = True SpliterGroup Bases: DatasetNode [ Spliter , SPG , Table [ int , str , bool ]] , Generic [ SP , SPG ] DEFAULT_SPLIT_MODE class-attribute instance-attribute DEFAULT_SPLIT_MODE = [ 'default' ] active_spliter property active_spliter split_mode property writable split_mode train_idx_list property train_idx_list val_idx_list property val_idx_list __init__ __init__ ( top_directory , mapping_name , * , flag_name = '' , split_paras = None ) -> None add_elem add_elem ( elem_i : int ) copy_elem copy_elem ( src : int , dst : int ) init_clusters_hook init_clusters_hook () init_dataset_attr_hook init_dataset_attr_hook () move_elem move_elem ( src : int , dst : int ) remove_elem remove_elem ( elem_i : int ) stop_writing_hook stop_writing_hook () update_clusters update_clusters ( log_type , src , dst , value , cluster )","title":"spliter"},{"location":"md/data/spliter/#spliter","text":"","title":"spliter"},{"location":"md/data/spliter/#data.spliter.SFH","text":"SFH = TypeVar ( 'SFH' , bound = 'SpliterFilesHandle' )","title":"SFH"},{"location":"md/data/spliter/#data.spliter.SP","text":"SP = TypeVar ( 'SP' , bound = 'Spliter' )","title":"SP"},{"location":"md/data/spliter/#data.spliter.SPG","text":"SPG = TypeVar ( 'SPG' , bound = 'SpliterGroup' )","title":"SPG"},{"location":"md/data/spliter/#data.spliter.VDMT","text":"VDMT = TypeVar ( 'VDMT' ) spliter(DisunifiedFilesHandle) .json \u7ef4\u62a4\u4e00\u4e2atable, \u884c\uff1aelem_i, \u5217\uff1asub_set, \u503c\uff1abool \u884c\u3001\u5217\u589e\u5220\uff0c\u5143\u7d20\u8bfb\u53d6\uff1b\u8bbe\u7f6eidx\u6240\u5728\u7684subset\uff1b\u662f\u5426\u72ec\u5360 splitergroup(Cluster) \u7ef4\u62a4\u591a\u4e2aspliter, \u6bcf\u4e2aspliter\u662f\u4e00\u4e2a split_mode","title":"VDMT"},{"location":"md/data/spliter/#data.spliter.Spliter","text":"Bases: DisunifiedFileCluster [ SpliterFilesHandle , SP , SPG , Table [ int , str , bool ]] , Generic [ SP , SPG ]","title":"Spliter"},{"location":"md/data/spliter/#data.spliter.Spliter.ALWAYS_ALLOW_WRITE","text":"ALWAYS_ALLOW_WRITE = True","title":"ALWAYS_ALLOW_WRITE"},{"location":"md/data/spliter/#data.spliter.Spliter.DEFAULT_SUB_SET","text":"DEFAULT_SUB_SET = [ KW_TRAIN , KW_VAL ]","title":"DEFAULT_SUB_SET"},{"location":"md/data/spliter/#data.spliter.Spliter.FILESHANDLE_TYPE","text":"FILESHANDLE_TYPE = SpliterFilesHandle","title":"FILESHANDLE_TYPE"},{"location":"md/data/spliter/#data.spliter.Spliter.KW_TRAIN","text":"KW_TRAIN = 'train'","title":"KW_TRAIN"},{"location":"md/data/spliter/#data.spliter.Spliter.KW_VAL","text":"KW_VAL = 'val'","title":"KW_VAL"},{"location":"md/data/spliter/#data.spliter.Spliter.SPLIT_FILE","text":"SPLIT_FILE = 'split.json'","title":"SPLIT_FILE"},{"location":"md/data/spliter/#data.spliter.Spliter._ELEM_BY_CACHE","text":"_ELEM_BY_CACHE = True","title":"_ELEM_BY_CACHE"},{"location":"md/data/spliter/#data.spliter.Spliter._IS_ELEM","text":"_IS_ELEM = True","title":"_IS_ELEM"},{"location":"md/data/spliter/#data.spliter.Spliter._next_valid_elem_i","text":"_next_valid_elem_i = 0","title":"_next_valid_elem_i"},{"location":"md/data/spliter/#data.spliter.Spliter._undefined_idx","text":"_undefined_idx = []","title":"_undefined_idx"},{"location":"md/data/spliter/#data.spliter.Spliter.elem_idx","text":"elem_idx","title":"elem_idx"},{"location":"md/data/spliter/#data.spliter.Spliter.exclusive","text":"exclusive","title":"exclusive"},{"location":"md/data/spliter/#data.spliter.Spliter.split_fileshandle","text":"split_fileshandle : SpliterFilesHandle = self . FILESHANDLE_TYPE . from_name ( self , self . SPLIT_FILE )","title":"split_fileshandle"},{"location":"md/data/spliter/#data.spliter.Spliter.split_table","text":"split_table","title":"split_table"},{"location":"md/data/spliter/#data.spliter.Spliter.split_table_data","text":"split_table_data","title":"split_table_data"},{"location":"md/data/spliter/#data.spliter.Spliter.subsets","text":"subsets","title":"subsets"},{"location":"md/data/spliter/#data.spliter.Spliter._modify_elem_key","text":"Bases: _modify_key ['Spliter', dict [ int , Any ], DictLikeHandle ]","title":"_modify_elem_key"},{"location":"md/data/spliter/#data.spliter.Spliter._modify_elem_key.OPER_ELEM","text":"OPER_ELEM = True","title":"OPER_ELEM"},{"location":"md/data/spliter/#data.spliter.Spliter._modify_elem_key.split_table","text":"split_table : Table [ int , str , bool ]","title":"split_table"},{"location":"md/data/spliter/#data.spliter.Spliter._modify_elem_key.is_overwriting","text":"is_overwriting ( dst : int )","title":"is_overwriting()"},{"location":"md/data/spliter/#data.spliter.Spliter._modify_elem_key.operate_elem","text":"operate_elem ( src , dst , values : dict , ** other_paras )","title":"operate_elem()"},{"location":"md/data/spliter/#data.spliter.Spliter._read_elem","text":"Bases: _read ['Spliter', dict [ int , Any ], DictLikeHandle ]","title":"_read_elem"},{"location":"md/data/spliter/#data.spliter.Spliter._read_elem.OPER_ELEM","text":"OPER_ELEM = True","title":"OPER_ELEM"},{"location":"md/data/spliter/#data.spliter.Spliter._read_elem.split_table","text":"split_table : Table [ int , str , bool ]","title":"split_table"},{"location":"md/data/spliter/#data.spliter.Spliter._read_elem.operate_elem","text":"operate_elem ( src , dst , value , ** other_paras )","title":"operate_elem()"},{"location":"md/data/spliter/#data.spliter.Spliter._remove_elem","text":"Bases: _remove ['Spliter', dict [ int , Any ], DictLikeHandle ]","title":"_remove_elem"},{"location":"md/data/spliter/#data.spliter.Spliter._remove_elem.OPER_ELEM","text":"OPER_ELEM = True","title":"OPER_ELEM"},{"location":"md/data/spliter/#data.spliter.Spliter._remove_elem.is_overwriting","text":"is_overwriting ( dst : int )","title":"is_overwriting()"},{"location":"md/data/spliter/#data.spliter.Spliter._remove_elem.operate_elem","text":"operate_elem ( src , dst , value , ** other_paras )","title":"operate_elem()"},{"location":"md/data/spliter/#data.spliter.Spliter._write_elem","text":"Bases: _write ['Spliter', dict [ int , Any ], DictLikeHandle ]","title":"_write_elem"},{"location":"md/data/spliter/#data.spliter.Spliter._write_elem.OPER_ELEM","text":"OPER_ELEM = True","title":"OPER_ELEM"},{"location":"md/data/spliter/#data.spliter.Spliter._write_elem.split_table","text":"split_table : Table [ int , str , bool ]","title":"split_table"},{"location":"md/data/spliter/#data.spliter.Spliter._write_elem.is_overwriting","text":"is_overwriting ( dst : int )","title":"is_overwriting()"},{"location":"md/data/spliter/#data.spliter.Spliter._write_elem.operate_elem","text":"operate_elem ( src , dst , values : dict [ str , Any ], ** other_paras )","title":"operate_elem()"},{"location":"md/data/spliter/#data.spliter.Spliter.__init__","text":"__init__ ( dataset_node : Union [ str , DatasetNode ], mapping_name : str , * args , subsets = None , ** kwargs ) -> None","title":"__init__()"},{"location":"md/data/spliter/#data.spliter.Spliter.__str__","text":"__str__ () -> str","title":"__str__()"},{"location":"md/data/spliter/#data.spliter.Spliter._decide_subset","text":"_decide_subset ( rlts : list [ list ], split_rate : tuple [ float ])","title":"_decide_subset()"},{"location":"md/data/spliter/#data.spliter.Spliter._set_fileshandle","text":"_set_fileshandle ( data_i , fh : DictLikeHandle )","title":"_set_fileshandle()"},{"location":"md/data/spliter/#data.spliter.Spliter.add_elem_idx","text":"add_elem_idx ( elem_i : int )","title":"add_elem_idx()"},{"location":"md/data/spliter/#data.spliter.Spliter.add_subset","text":"add_subset ( subset : str )","title":"add_subset()"},{"location":"md/data/spliter/#data.spliter.Spliter.clear_subset","text":"clear_subset ()","title":"clear_subset()"},{"location":"md/data/spliter/#data.spliter.Spliter.elem_keys","text":"elem_keys ()","title":"elem_keys()"},{"location":"md/data/spliter/#data.spliter.Spliter.from_txt","text":"from_txt ( txt_name_list : list [ str ])","title":"from_txt()"},{"location":"md/data/spliter/#data.spliter.Spliter.gen_split","text":"gen_split ( idx_array , split_rate , split_num )","title":"gen_split()"},{"location":"md/data/spliter/#data.spliter.Spliter.get_idx_dict","text":"get_idx_dict ()","title":"get_idx_dict()"},{"location":"md/data/spliter/#data.spliter.Spliter.get_idx_list","text":"get_idx_list ( subset : Union [ str , int ])","title":"get_idx_list()"},{"location":"md/data/spliter/#data.spliter.Spliter.get_nums","text":"get_nums ()","title":"get_nums()"},{"location":"md/data/spliter/#data.spliter.Spliter.init_io_metas","text":"init_io_metas ()","title":"init_io_metas()"},{"location":"md/data/spliter/#data.spliter.Spliter.merge_elem_from","text":"merge_elem_from ( src_data_map : Spliter , * , force = False )","title":"merge_elem_from()"},{"location":"md/data/spliter/#data.spliter.Spliter.modify_elem_key","text":"modify_elem_key ( src : int , dst : int , * , force = False , ** other_paras ) -> dict","title":"modify_elem_key()"},{"location":"md/data/spliter/#data.spliter.Spliter.one_defined","text":"one_defined ( elem_i : int )","title":"one_defined()"},{"location":"md/data/spliter/#data.spliter.Spliter.process_split_rate","text":"process_split_rate ( split_rate : Union [ float , Iterable [ float ], dict [ str , float ]], split_num : Union [ int , list [ str ]])","title":"process_split_rate()"},{"location":"md/data/spliter/#data.spliter.Spliter.qurey_one","text":"qurey_one ( elem_i : int , subset : str )","title":"qurey_one()"},{"location":"md/data/spliter/#data.spliter.Spliter.qurey_one_elem","text":"qurey_one_elem ( elem_i : int )","title":"qurey_one_elem()"},{"location":"md/data/spliter/#data.spliter.Spliter.qurey_one_subset","text":"qurey_one_subset ( subset : str )","title":"qurey_one_subset()"},{"location":"md/data/spliter/#data.spliter.Spliter.read_elem","text":"read_elem ( src : Union [ int , Iterable [ int ]], * , force = False , ** other_paras ) -> Union [ dict [ str , bool ], None ]","title":"read_elem()"},{"location":"md/data/spliter/#data.spliter.Spliter.remove_elem","text":"remove_elem ( dst : int , remove_both = False , * , force = False , ** other_paras ) -> dict","title":"remove_elem()"},{"location":"md/data/spliter/#data.spliter.Spliter.remove_elem_idx","text":"remove_elem_idx ( elem_i : int )","title":"remove_elem_idx()"},{"location":"md/data/spliter/#data.spliter.Spliter.remove_subset","text":"remove_subset ( subset : str )","title":"remove_subset()"},{"location":"md/data/spliter/#data.spliter.Spliter.save_as_txt","text":"save_as_txt ( mask_mode = True )","title":"save_as_txt()"},{"location":"md/data/spliter/#data.spliter.Spliter.set_all_by_rate","text":"set_all_by_rate ( split_rate )","title":"set_all_by_rate()"},{"location":"md/data/spliter/#data.spliter.Spliter.set_one","text":"set_one ( elem_i : int , subset : str , value : bool )","title":"set_one()"},{"location":"md/data/spliter/#data.spliter.Spliter.set_one_by_rate","text":"set_one_by_rate ( elem_i , split_rate )","title":"set_one_by_rate()"},{"location":"md/data/spliter/#data.spliter.Spliter.set_one_elem","text":"set_one_elem ( elem_i , subsets : dict [ str , bool ])","title":"set_one_elem()"},{"location":"md/data/spliter/#data.spliter.Spliter.set_one_subset","text":"set_one_subset ( subset : str , elems : Union [ dict [ int , bool ], tuple [ int , ... ]])","title":"set_one_subset()"},{"location":"md/data/spliter/#data.spliter.Spliter.sort_elem","text":"sort_elem ()","title":"sort_elem()"},{"location":"md/data/spliter/#data.spliter.Spliter.stop_writing_hook","text":"stop_writing_hook ()","title":"stop_writing_hook()"},{"location":"md/data/spliter/#data.spliter.Spliter.write_elem","text":"write_elem ( dst : int , value : Union [ Any , dict [ int , Any ]], * , force = False , ** other_paras ) -> dict","title":"write_elem()"},{"location":"md/data/spliter/#data.spliter.SpliterFilesHandle","text":"Bases: DisunifiedFilesHandle [ SP , Table [ int , str , bool ]]","title":"SpliterFilesHandle"},{"location":"md/data/spliter/#data.spliter.SpliterFilesHandle.DEFAULT_READ_FUNC","text":"DEFAULT_READ_FUNC = Table . from_json","title":"DEFAULT_READ_FUNC"},{"location":"md/data/spliter/#data.spliter.SpliterFilesHandle.DEFAULT_VALUE_INIT_FUNC","text":"DEFAULT_VALUE_INIT_FUNC = partial ( Table , row_name_type = int , col_name_type = str , default_value_type = bool )","title":"DEFAULT_VALUE_INIT_FUNC"},{"location":"md/data/spliter/#data.spliter.SpliterFilesHandle.DEFAULT_VALUE_TYPE","text":"DEFAULT_VALUE_TYPE = Table","title":"DEFAULT_VALUE_TYPE"},{"location":"md/data/spliter/#data.spliter.SpliterFilesHandle.DEFAULT_WRITE_FUNC","text":"DEFAULT_WRITE_FUNC = Table . to_json","title":"DEFAULT_WRITE_FUNC"},{"location":"md/data/spliter/#data.spliter.SpliterFilesHandle.LOAD_CACHE_ON_INIT","text":"LOAD_CACHE_ON_INIT = True","title":"LOAD_CACHE_ON_INIT"},{"location":"md/data/spliter/#data.spliter.SpliterGroup","text":"Bases: DatasetNode [ Spliter , SPG , Table [ int , str , bool ]] , Generic [ SP , SPG ]","title":"SpliterGroup"},{"location":"md/data/spliter/#data.spliter.SpliterGroup.DEFAULT_SPLIT_MODE","text":"DEFAULT_SPLIT_MODE = [ 'default' ]","title":"DEFAULT_SPLIT_MODE"},{"location":"md/data/spliter/#data.spliter.SpliterGroup.active_spliter","text":"active_spliter","title":"active_spliter"},{"location":"md/data/spliter/#data.spliter.SpliterGroup.split_mode","text":"split_mode","title":"split_mode"},{"location":"md/data/spliter/#data.spliter.SpliterGroup.train_idx_list","text":"train_idx_list","title":"train_idx_list"},{"location":"md/data/spliter/#data.spliter.SpliterGroup.val_idx_list","text":"val_idx_list","title":"val_idx_list"},{"location":"md/data/spliter/#data.spliter.SpliterGroup.__init__","text":"__init__ ( top_directory , mapping_name , * , flag_name = '' , split_paras = None ) -> None","title":"__init__()"},{"location":"md/data/spliter/#data.spliter.SpliterGroup.add_elem","text":"add_elem ( elem_i : int )","title":"add_elem()"},{"location":"md/data/spliter/#data.spliter.SpliterGroup.copy_elem","text":"copy_elem ( src : int , dst : int )","title":"copy_elem()"},{"location":"md/data/spliter/#data.spliter.SpliterGroup.init_clusters_hook","text":"init_clusters_hook ()","title":"init_clusters_hook()"},{"location":"md/data/spliter/#data.spliter.SpliterGroup.init_dataset_attr_hook","text":"init_dataset_attr_hook ()","title":"init_dataset_attr_hook()"},{"location":"md/data/spliter/#data.spliter.SpliterGroup.move_elem","text":"move_elem ( src : int , dst : int )","title":"move_elem()"},{"location":"md/data/spliter/#data.spliter.SpliterGroup.remove_elem","text":"remove_elem ( elem_i : int )","title":"remove_elem()"},{"location":"md/data/spliter/#data.spliter.SpliterGroup.stop_writing_hook","text":"stop_writing_hook ()","title":"stop_writing_hook()"},{"location":"md/data/spliter/#data.spliter.SpliterGroup.update_clusters","text":"update_clusters ( log_type , src , dst , value , cluster )","title":"update_clusters()"},{"location":"md/data/viewmeta/","text":"viewmeta AugmentPipeline meta instance-attribute meta = meta new_obj instance-attribute new_obj = None obj property obj __init__ __init__ ( meta : ViewMeta ) -> None _change_brightness _change_brightness ( delta_value , direction ) _change_saturation _change_saturation ( delta_value ) _crop _crop ( crop_rect : ndarray ) _rotate _rotate ( M : ndarray ) change_brightness change_brightness ( delta_value : float , direction : tuple [ float ] = ( 0 , 0 )) change_saturation change_saturation ( delta_value : float ) crop crop ( crop_rect : ndarray ) -> Union [ cv2 . Mat , None ] crop_rect: [N, [y1, x1, y2, x2]] int get_ap_of_meta get_ap_of_meta ( class_ ) -> Union [ AugmentPipeline , None ] rotate rotate ( M : ndarray ) ViewMeta \u4e00\u4e2a\u89c6\u89d2\u4e0b\u7684\u6240\u6709\u6570\u636e\u7684\u5143 BBOX_3DS class-attribute instance-attribute BBOX_3DS = PARA_NAMES [ 6 ] COLOR class-attribute instance-attribute COLOR = PARA_NAMES [ 0 ] DEPTH class-attribute instance-attribute DEPTH = PARA_NAMES [ 1 ] DEPTH_SCALE class-attribute instance-attribute DEPTH_SCALE = PARA_NAMES [ 5 ] EXTR_VECS class-attribute instance-attribute EXTR_VECS = PARA_NAMES [ 3 ] IGNORE_WARNING class-attribute instance-attribute IGNORE_WARNING = False INTR class-attribute instance-attribute INTR = PARA_NAMES [ 4 ] LABELS class-attribute instance-attribute LABELS = PARA_NAMES [ 9 ] LANDMARKS class-attribute instance-attribute LANDMARKS = PARA_NAMES [ 7 ] MASKS class-attribute instance-attribute MASKS = PARA_NAMES [ 2 ] PARA_NAMES class-attribute instance-attribute PARA_NAMES = [ 'color' , 'depth' , 'masks' , 'extr_vecs' , 'intr' , 'depth_scale' , 'bbox_3d' , 'landmarks' , 'visib_fracts' , 'labels' ] VISIB_FRACTS class-attribute instance-attribute VISIB_FRACTS = PARA_NAMES [ 8 ] _agmts_type instance-attribute _agmts_type : dict [ str , type ] = { ViewMeta . PARA_NAMES [ 0 ]: ViewMeta . ColorAP , ViewMeta . PARA_NAMES [ 1 ]: ViewMeta . DepthAP , ViewMeta . PARA_NAMES [ 2 ]: ViewMeta . MasksAP , ViewMeta . PARA_NAMES [ 3 ]: ViewMeta . ExtrVecAP , ViewMeta . PARA_NAMES [ 4 ]: ViewMeta . IntrAP , ViewMeta . PARA_NAMES [ 5 ]: ViewMeta . DepthScaleAP , ViewMeta . PARA_NAMES [ 6 ]: ViewMeta . Bbox3dAP , ViewMeta . PARA_NAMES [ 7 ]: ViewMeta . LandmarksAP , ViewMeta . PARA_NAMES [ 8 ]: ViewMeta . VisibFractsAP , ViewMeta . PARA_NAMES [ 9 ]: ViewMeta . LabelsAP } _format_func instance-attribute _format_func : dict [ str , Callable ] = { ViewMeta . PARA_NAMES [ 0 ]: None , ViewMeta . PARA_NAMES [ 1 ]: None , ViewMeta . PARA_NAMES [ 2 ]: None , ViewMeta . PARA_NAMES [ 3 ]: lambda : self . __reshape_array_in_dict ( x , ( 2 , 3 )), ViewMeta . PARA_NAMES [ 4 ]: lambda : np . reshape ( x , ( 3 , 3 )), ViewMeta . PARA_NAMES [ 5 ]: lambda : float ( x ), ViewMeta . PARA_NAMES [ 6 ]: lambda : self . __reshape_array_in_dict ( x , ( - 1 , 2 )), ViewMeta . PARA_NAMES [ 7 ]: lambda : self . __reshape_array_in_dict ( x , ( - 1 , 2 )), ViewMeta . PARA_NAMES [ 8 ]: None , ViewMeta . PARA_NAMES [ 9 ]: None } agmts instance-attribute agmts : dict [ str , AugmentPipeline ] = {} bbox_2d property bbox_2d : dict [ int , np . ndarray ] (x1, y1, x2, y2) bbox_3d instance-attribute bbox_3d : dict [ int , ndarray ] = self . set_element ( ViewMeta . PARA_NAMES [ 6 ], bbox_3d ) color instance-attribute color : np . ndarray = self . set_element ( ViewMeta . PARA_NAMES [ 0 ], color ) depth instance-attribute depth : np . ndarray = self . set_element ( ViewMeta . PARA_NAMES [ 1 ], depth ) depth_scale instance-attribute depth_scale : float = self . set_element ( ViewMeta . PARA_NAMES [ 5 ], depth_scale ) elements property elements extr_vecs instance-attribute extr_vecs : dict [ int , ndarray ] = self . set_element ( ViewMeta . PARA_NAMES [ 3 ], extr_vecs ) ids instance-attribute ids = [] intr instance-attribute intr : ndarray = self . set_element ( ViewMeta . PARA_NAMES [ 4 ], intr ) labels instance-attribute labels : dict [ int , ndarray ] = self . set_element ( ViewMeta . PARA_NAMES [ 9 ], labels ) landmarks instance-attribute landmarks : dict [ int , ndarray ] = self . set_element ( ViewMeta . PARA_NAMES [ 7 ], landmarks ) masks instance-attribute masks : dict [ int , ndarray ] = self . set_element ( ViewMeta . PARA_NAMES [ 2 ], masks ) visib_fracts instance-attribute visib_fracts : dict [ int , float ] = self . set_element ( ViewMeta . PARA_NAMES [ 8 ], visib_fracts ) Bbox3dAP Bases: AugmentPipeline obj property obj __init__ __init__ ( meta : ViewMeta ) -> None _rotate _rotate ( M : cv2 . Mat ) ColorAP Bases: AugmentPipeline Color image augment pipline obj property obj __init__ __init__ ( meta : ViewMeta ) -> None _change_brightness _change_brightness ( delta_value , direction ) _change_saturation _change_saturation ( delta_value ) _crop _crop ( crop_rect : np . ndarray ) _rotate _rotate ( M : ndarray ) DepthAP Bases: AugmentPipeline obj property obj __init__ __init__ ( meta : ViewMeta ) -> None _crop _crop ( crop_rect : np . ndarray ) _rotate _rotate ( M : ndarray ) DepthScaleAP Bases: AugmentPipeline obj property obj __init__ __init__ ( meta : ViewMeta ) -> None ExtrVecAP Bases: AugmentPipeline obj property obj __init__ __init__ ( meta : ViewMeta ) -> None _rotate _rotate ( M : ndarray ) IntrAP Bases: AugmentPipeline obj property obj __init__ __init__ ( meta : ViewMeta ) -> None LabelsAP Bases: AugmentPipeline new_masks_callback instance-attribute new_masks_callback = lambda : self . get_ap_of_meta ( self . meta . MasksAP ) . new_obj obj property obj __init__ __init__ ( meta : ViewMeta ) -> None _crop _crop ( crop_rect : ndarray ) _rotate _rotate ( M : cv2 . Mat ) LandmarksAP Bases: AugmentPipeline obj property obj __init__ __init__ ( meta : ViewMeta ) -> None _rotate _rotate ( M : cv2 . Mat ) MasksAP Bases: AugmentPipeline obj property obj __init__ __init__ ( meta : ViewMeta ) -> None _crop _crop ( crop_rect : np . ndarray ) _rotate _rotate ( M : ndarray ) VisibFractsAP Bases: AugmentPipeline new_masks_callback instance-attribute new_masks_callback = lambda : self . get_ap_of_meta ( self . meta . MasksAP ) . new_obj obj property obj old_masks_callback instance-attribute old_masks_callback = lambda : self . get_ap_of_meta ( self . meta . MasksAP ) . obj __init__ __init__ ( meta : ViewMeta ) -> None _crop _crop ( crop_rect : ndarray ) _rotate _rotate ( crop_rect : ndarray ) calc_new_visib_fracts calc_new_visib_fracts ( old_masks : dict [ str , np . ndarray ], new_masks : dict [ str , np . ndarray ]) __init__ __init__ ( color : np . ndarray , depth : np . ndarray , masks : dict [ int , np . ndarray ], extr_vecs : dict [ int , ndarray ], intr : ndarray , depth_scale : float , bbox_3d : dict [ int , ndarray ], landmarks : dict [ int , ndarray ], visib_fracts : dict [ int , float ], labels : dict [ int , np . ndarray ] = None ) -> None color: np.ndarray, depth: np.ndarray, masks: dict[int, np.ndarray], extr_gt: list[dict[int, list]], \u5916\u53c2 camera: dict, \u76f8\u673a\u53c2\u6570 visib_fracts: dict[int, float], \u7269\u4f53\u53ef\u89c1\u6027 bbox: dict[int, ndarray:[B, (x,y)]], keypoints: dict[int, ndarray:[N, (x,y)]], trans_vector:dict[int, list] \u5916\u53c2 __setattr__ __setattr__ ( __name , __value ) _init_agmts _init_agmts () as_dict as_dict () \u8f6c\u6362\u4e3adict calc_bbox2d_from_mask staticmethod calc_bbox2d_from_mask ( mask_dict : dict [ int , np . ndarray ]) calc_by_base calc_by_base ( mesh_dict : dict [ int , MeshMeta ], cover = False ) change_brightness change_brightness ( delta_value , direction = ( 0 , 0 )) brief \u4fee\u6539\u4eae\u5ea6 Parameters: delta_value \u2013 direction \u2013 return FieldData change_saturation change_saturation ( delta_value ) \u4fee\u6539\u9971\u548c\u5ea6 crop crop ( crop_rect : np . ndarray ) \u88c1\u526a\uff0c\u53bb\u9664\u90e8\u5206\u53d8\u4e3a\u5168\u9ed1\uff0c\u4e0d\u6539\u53d8\u5b9e\u9645\u56fe\u50cf\u5927\u5c0f\uff08\u8003\u8651\u5230\u88c1\u526a+\u7f29\u653e\u4f1a\u5bfc\u81f4\u5185\u53c2\u4e0d\u4e00\u81f4\uff0c\u5f71\u54cd\u5173\u952e\u70b9\u4f4d\u7f6e\u9884\u6d4b\uff09 crop_rect: [N, [y1, x1, y2, x2]] filter_unvisible filter_unvisible () from_base_data staticmethod from_base_data ( color : np . ndarray , depth : np . ndarray , extr_vecs : dict [ int , ndarray ], intr : np . ndarray , depth_scale : float , mesh_dict : dict [ int , MeshMeta ]) gaussian_noise gaussian_noise () \u9ad8\u65af\u566a\u58f0 modify_class_id modify_class_id ( modify_class_id_pairs : list [ tuple [ int ]]) plot plot () \u663e\u793a use plt.show() after this method to show rotate rotate ( angle : float ) brief \u65cb\u8f6c Parameters: angle ( float ) \u2013 return Description of the return set_element set_element ( name : str , value ) ViewMetaMaskContour Bases: ViewMeta LabelsAP Bases: AugmentPipeline new_masks_callback instance-attribute new_masks_callback = lambda : self . get_ap_of_meta ( self . meta . MasksAP ) . new_obj obj property obj __init__ __init__ ( meta : ViewMeta ) -> None _crop _crop ( crop_rect : ndarray ) _rotate _rotate ( M : cv2 . Mat ) MasksAP Bases: AugmentPipeline obj property obj __init__ __init__ ( meta : ViewMeta ) -> None _rotate _rotate ( M : ndarray ) VisibFractsAP Bases: AugmentPipeline new_masks_callback instance-attribute new_masks_callback = lambda : self . get_ap_of_meta ( self . meta . MasksAP ) . new_obj obj property obj old_masks_callback instance-attribute old_masks_callback = lambda : self . get_ap_of_meta ( self . meta . MasksAP ) . obj __init__ __init__ ( meta : ViewMeta ) -> None __init__ __init__ ( color : ndarray , depth : ndarray , masks : dict [ int , ndarray ], extr_vecs : dict [ int , ndarray ], intr : ndarray , depth_scale : float , bbox_3d : dict [ int , ndarray ], landmarks : dict [ int , ndarray ], visib_fracts : dict [ int , float ], labels : dict [ int , ndarray ] = None ) -> None calc_bbox2d_from_mask staticmethod calc_bbox2d_from_mask ( mask_dict : dict [ int , ndarray ]) calc_bbox2d_from_mask_contour calc_bbox2d_from_mask_contour ( mask_dict : dict [ int , np . ndarray ]) calc_bbox2d_from_mask_dict calc_bbox2d_from_mask_dict ( mask_dict : dict [ int , np . ndarray ]) copy_by_rect copy_by_rect ( crop_rect , org : np . ndarray ) ignore_viewmeta_warning ignore_viewmeta_warning ( func ) query_key_by_value query_key_by_value ( orig_dict : dict ) rot_xy_list_2dpoints rot_xy_list_2dpoints ( M , points_2d : np . ndarray ) -> list [ float ] points_2d [N, (x,y)] rotate_image rotate_image ( M , image : np . ndarray )","title":"viewmeta"},{"location":"md/data/viewmeta/#viewmeta","text":"","title":"viewmeta"},{"location":"md/data/viewmeta/#data.viewmeta.AugmentPipeline","text":"","title":"AugmentPipeline"},{"location":"md/data/viewmeta/#data.viewmeta.AugmentPipeline.meta","text":"meta = meta","title":"meta"},{"location":"md/data/viewmeta/#data.viewmeta.AugmentPipeline.new_obj","text":"new_obj = None","title":"new_obj"},{"location":"md/data/viewmeta/#data.viewmeta.AugmentPipeline.obj","text":"obj","title":"obj"},{"location":"md/data/viewmeta/#data.viewmeta.AugmentPipeline.__init__","text":"__init__ ( meta : ViewMeta ) -> None","title":"__init__()"},{"location":"md/data/viewmeta/#data.viewmeta.AugmentPipeline._change_brightness","text":"_change_brightness ( delta_value , direction )","title":"_change_brightness()"},{"location":"md/data/viewmeta/#data.viewmeta.AugmentPipeline._change_saturation","text":"_change_saturation ( delta_value )","title":"_change_saturation()"},{"location":"md/data/viewmeta/#data.viewmeta.AugmentPipeline._crop","text":"_crop ( crop_rect : ndarray )","title":"_crop()"},{"location":"md/data/viewmeta/#data.viewmeta.AugmentPipeline._rotate","text":"_rotate ( M : ndarray )","title":"_rotate()"},{"location":"md/data/viewmeta/#data.viewmeta.AugmentPipeline.change_brightness","text":"change_brightness ( delta_value : float , direction : tuple [ float ] = ( 0 , 0 ))","title":"change_brightness()"},{"location":"md/data/viewmeta/#data.viewmeta.AugmentPipeline.change_saturation","text":"change_saturation ( delta_value : float )","title":"change_saturation()"},{"location":"md/data/viewmeta/#data.viewmeta.AugmentPipeline.crop","text":"crop ( crop_rect : ndarray ) -> Union [ cv2 . Mat , None ] crop_rect: [N, [y1, x1, y2, x2]] int","title":"crop()"},{"location":"md/data/viewmeta/#data.viewmeta.AugmentPipeline.get_ap_of_meta","text":"get_ap_of_meta ( class_ ) -> Union [ AugmentPipeline , None ]","title":"get_ap_of_meta()"},{"location":"md/data/viewmeta/#data.viewmeta.AugmentPipeline.rotate","text":"rotate ( M : ndarray )","title":"rotate()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta","text":"\u4e00\u4e2a\u89c6\u89d2\u4e0b\u7684\u6240\u6709\u6570\u636e\u7684\u5143","title":"ViewMeta"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.BBOX_3DS","text":"BBOX_3DS = PARA_NAMES [ 6 ]","title":"BBOX_3DS"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.COLOR","text":"COLOR = PARA_NAMES [ 0 ]","title":"COLOR"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.DEPTH","text":"DEPTH = PARA_NAMES [ 1 ]","title":"DEPTH"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.DEPTH_SCALE","text":"DEPTH_SCALE = PARA_NAMES [ 5 ]","title":"DEPTH_SCALE"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.EXTR_VECS","text":"EXTR_VECS = PARA_NAMES [ 3 ]","title":"EXTR_VECS"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.IGNORE_WARNING","text":"IGNORE_WARNING = False","title":"IGNORE_WARNING"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.INTR","text":"INTR = PARA_NAMES [ 4 ]","title":"INTR"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.LABELS","text":"LABELS = PARA_NAMES [ 9 ]","title":"LABELS"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.LANDMARKS","text":"LANDMARKS = PARA_NAMES [ 7 ]","title":"LANDMARKS"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.MASKS","text":"MASKS = PARA_NAMES [ 2 ]","title":"MASKS"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.PARA_NAMES","text":"PARA_NAMES = [ 'color' , 'depth' , 'masks' , 'extr_vecs' , 'intr' , 'depth_scale' , 'bbox_3d' , 'landmarks' , 'visib_fracts' , 'labels' ]","title":"PARA_NAMES"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.VISIB_FRACTS","text":"VISIB_FRACTS = PARA_NAMES [ 8 ]","title":"VISIB_FRACTS"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta._agmts_type","text":"_agmts_type : dict [ str , type ] = { ViewMeta . PARA_NAMES [ 0 ]: ViewMeta . ColorAP , ViewMeta . PARA_NAMES [ 1 ]: ViewMeta . DepthAP , ViewMeta . PARA_NAMES [ 2 ]: ViewMeta . MasksAP , ViewMeta . PARA_NAMES [ 3 ]: ViewMeta . ExtrVecAP , ViewMeta . PARA_NAMES [ 4 ]: ViewMeta . IntrAP , ViewMeta . PARA_NAMES [ 5 ]: ViewMeta . DepthScaleAP , ViewMeta . PARA_NAMES [ 6 ]: ViewMeta . Bbox3dAP , ViewMeta . PARA_NAMES [ 7 ]: ViewMeta . LandmarksAP , ViewMeta . PARA_NAMES [ 8 ]: ViewMeta . VisibFractsAP , ViewMeta . PARA_NAMES [ 9 ]: ViewMeta . LabelsAP }","title":"_agmts_type"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta._format_func","text":"_format_func : dict [ str , Callable ] = { ViewMeta . PARA_NAMES [ 0 ]: None , ViewMeta . PARA_NAMES [ 1 ]: None , ViewMeta . PARA_NAMES [ 2 ]: None , ViewMeta . PARA_NAMES [ 3 ]: lambda : self . __reshape_array_in_dict ( x , ( 2 , 3 )), ViewMeta . PARA_NAMES [ 4 ]: lambda : np . reshape ( x , ( 3 , 3 )), ViewMeta . PARA_NAMES [ 5 ]: lambda : float ( x ), ViewMeta . PARA_NAMES [ 6 ]: lambda : self . __reshape_array_in_dict ( x , ( - 1 , 2 )), ViewMeta . PARA_NAMES [ 7 ]: lambda : self . __reshape_array_in_dict ( x , ( - 1 , 2 )), ViewMeta . PARA_NAMES [ 8 ]: None , ViewMeta . PARA_NAMES [ 9 ]: None }","title":"_format_func"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.agmts","text":"agmts : dict [ str , AugmentPipeline ] = {}","title":"agmts"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.bbox_2d","text":"bbox_2d : dict [ int , np . ndarray ] (x1, y1, x2, y2)","title":"bbox_2d"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.bbox_3d","text":"bbox_3d : dict [ int , ndarray ] = self . set_element ( ViewMeta . PARA_NAMES [ 6 ], bbox_3d )","title":"bbox_3d"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.color","text":"color : np . ndarray = self . set_element ( ViewMeta . PARA_NAMES [ 0 ], color )","title":"color"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.depth","text":"depth : np . ndarray = self . set_element ( ViewMeta . PARA_NAMES [ 1 ], depth )","title":"depth"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.depth_scale","text":"depth_scale : float = self . set_element ( ViewMeta . PARA_NAMES [ 5 ], depth_scale )","title":"depth_scale"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.elements","text":"elements","title":"elements"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.extr_vecs","text":"extr_vecs : dict [ int , ndarray ] = self . set_element ( ViewMeta . PARA_NAMES [ 3 ], extr_vecs )","title":"extr_vecs"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.ids","text":"ids = []","title":"ids"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.intr","text":"intr : ndarray = self . set_element ( ViewMeta . PARA_NAMES [ 4 ], intr )","title":"intr"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.labels","text":"labels : dict [ int , ndarray ] = self . set_element ( ViewMeta . PARA_NAMES [ 9 ], labels )","title":"labels"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.landmarks","text":"landmarks : dict [ int , ndarray ] = self . set_element ( ViewMeta . PARA_NAMES [ 7 ], landmarks )","title":"landmarks"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.masks","text":"masks : dict [ int , ndarray ] = self . set_element ( ViewMeta . PARA_NAMES [ 2 ], masks )","title":"masks"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.visib_fracts","text":"visib_fracts : dict [ int , float ] = self . set_element ( ViewMeta . PARA_NAMES [ 8 ], visib_fracts )","title":"visib_fracts"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.Bbox3dAP","text":"Bases: AugmentPipeline","title":"Bbox3dAP"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.Bbox3dAP.obj","text":"obj","title":"obj"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.Bbox3dAP.__init__","text":"__init__ ( meta : ViewMeta ) -> None","title":"__init__()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.Bbox3dAP._rotate","text":"_rotate ( M : cv2 . Mat )","title":"_rotate()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.ColorAP","text":"Bases: AugmentPipeline Color image augment pipline","title":"ColorAP"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.ColorAP.obj","text":"obj","title":"obj"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.ColorAP.__init__","text":"__init__ ( meta : ViewMeta ) -> None","title":"__init__()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.ColorAP._change_brightness","text":"_change_brightness ( delta_value , direction )","title":"_change_brightness()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.ColorAP._change_saturation","text":"_change_saturation ( delta_value )","title":"_change_saturation()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.ColorAP._crop","text":"_crop ( crop_rect : np . ndarray )","title":"_crop()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.ColorAP._rotate","text":"_rotate ( M : ndarray )","title":"_rotate()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.DepthAP","text":"Bases: AugmentPipeline","title":"DepthAP"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.DepthAP.obj","text":"obj","title":"obj"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.DepthAP.__init__","text":"__init__ ( meta : ViewMeta ) -> None","title":"__init__()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.DepthAP._crop","text":"_crop ( crop_rect : np . ndarray )","title":"_crop()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.DepthAP._rotate","text":"_rotate ( M : ndarray )","title":"_rotate()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.DepthScaleAP","text":"Bases: AugmentPipeline","title":"DepthScaleAP"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.DepthScaleAP.obj","text":"obj","title":"obj"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.DepthScaleAP.__init__","text":"__init__ ( meta : ViewMeta ) -> None","title":"__init__()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.ExtrVecAP","text":"Bases: AugmentPipeline","title":"ExtrVecAP"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.ExtrVecAP.obj","text":"obj","title":"obj"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.ExtrVecAP.__init__","text":"__init__ ( meta : ViewMeta ) -> None","title":"__init__()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.ExtrVecAP._rotate","text":"_rotate ( M : ndarray )","title":"_rotate()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.IntrAP","text":"Bases: AugmentPipeline","title":"IntrAP"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.IntrAP.obj","text":"obj","title":"obj"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.IntrAP.__init__","text":"__init__ ( meta : ViewMeta ) -> None","title":"__init__()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.LabelsAP","text":"Bases: AugmentPipeline","title":"LabelsAP"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.LabelsAP.new_masks_callback","text":"new_masks_callback = lambda : self . get_ap_of_meta ( self . meta . MasksAP ) . new_obj","title":"new_masks_callback"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.LabelsAP.obj","text":"obj","title":"obj"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.LabelsAP.__init__","text":"__init__ ( meta : ViewMeta ) -> None","title":"__init__()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.LabelsAP._crop","text":"_crop ( crop_rect : ndarray )","title":"_crop()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.LabelsAP._rotate","text":"_rotate ( M : cv2 . Mat )","title":"_rotate()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.LandmarksAP","text":"Bases: AugmentPipeline","title":"LandmarksAP"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.LandmarksAP.obj","text":"obj","title":"obj"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.LandmarksAP.__init__","text":"__init__ ( meta : ViewMeta ) -> None","title":"__init__()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.LandmarksAP._rotate","text":"_rotate ( M : cv2 . Mat )","title":"_rotate()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.MasksAP","text":"Bases: AugmentPipeline","title":"MasksAP"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.MasksAP.obj","text":"obj","title":"obj"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.MasksAP.__init__","text":"__init__ ( meta : ViewMeta ) -> None","title":"__init__()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.MasksAP._crop","text":"_crop ( crop_rect : np . ndarray )","title":"_crop()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.MasksAP._rotate","text":"_rotate ( M : ndarray )","title":"_rotate()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.VisibFractsAP","text":"Bases: AugmentPipeline","title":"VisibFractsAP"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.VisibFractsAP.new_masks_callback","text":"new_masks_callback = lambda : self . get_ap_of_meta ( self . meta . MasksAP ) . new_obj","title":"new_masks_callback"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.VisibFractsAP.obj","text":"obj","title":"obj"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.VisibFractsAP.old_masks_callback","text":"old_masks_callback = lambda : self . get_ap_of_meta ( self . meta . MasksAP ) . obj","title":"old_masks_callback"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.VisibFractsAP.__init__","text":"__init__ ( meta : ViewMeta ) -> None","title":"__init__()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.VisibFractsAP._crop","text":"_crop ( crop_rect : ndarray )","title":"_crop()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.VisibFractsAP._rotate","text":"_rotate ( crop_rect : ndarray )","title":"_rotate()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.VisibFractsAP.calc_new_visib_fracts","text":"calc_new_visib_fracts ( old_masks : dict [ str , np . ndarray ], new_masks : dict [ str , np . ndarray ])","title":"calc_new_visib_fracts()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.__init__","text":"__init__ ( color : np . ndarray , depth : np . ndarray , masks : dict [ int , np . ndarray ], extr_vecs : dict [ int , ndarray ], intr : ndarray , depth_scale : float , bbox_3d : dict [ int , ndarray ], landmarks : dict [ int , ndarray ], visib_fracts : dict [ int , float ], labels : dict [ int , np . ndarray ] = None ) -> None color: np.ndarray, depth: np.ndarray, masks: dict[int, np.ndarray], extr_gt: list[dict[int, list]], \u5916\u53c2 camera: dict, \u76f8\u673a\u53c2\u6570 visib_fracts: dict[int, float], \u7269\u4f53\u53ef\u89c1\u6027 bbox: dict[int, ndarray:[B, (x,y)]], keypoints: dict[int, ndarray:[N, (x,y)]], trans_vector:dict[int, list] \u5916\u53c2","title":"__init__()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.__setattr__","text":"__setattr__ ( __name , __value )","title":"__setattr__()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta._init_agmts","text":"_init_agmts ()","title":"_init_agmts()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.as_dict","text":"as_dict () \u8f6c\u6362\u4e3adict","title":"as_dict()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.calc_bbox2d_from_mask","text":"calc_bbox2d_from_mask ( mask_dict : dict [ int , np . ndarray ])","title":"calc_bbox2d_from_mask()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.calc_by_base","text":"calc_by_base ( mesh_dict : dict [ int , MeshMeta ], cover = False )","title":"calc_by_base()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.change_brightness","text":"change_brightness ( delta_value , direction = ( 0 , 0 ))","title":"change_brightness()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.change_brightness--brief","text":"\u4fee\u6539\u4eae\u5ea6 Parameters: delta_value \u2013 direction \u2013","title":"brief"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.change_brightness--return","text":"FieldData","title":"return"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.change_saturation","text":"change_saturation ( delta_value ) \u4fee\u6539\u9971\u548c\u5ea6","title":"change_saturation()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.crop","text":"crop ( crop_rect : np . ndarray ) \u88c1\u526a\uff0c\u53bb\u9664\u90e8\u5206\u53d8\u4e3a\u5168\u9ed1\uff0c\u4e0d\u6539\u53d8\u5b9e\u9645\u56fe\u50cf\u5927\u5c0f\uff08\u8003\u8651\u5230\u88c1\u526a+\u7f29\u653e\u4f1a\u5bfc\u81f4\u5185\u53c2\u4e0d\u4e00\u81f4\uff0c\u5f71\u54cd\u5173\u952e\u70b9\u4f4d\u7f6e\u9884\u6d4b\uff09 crop_rect: [N, [y1, x1, y2, x2]]","title":"crop()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.filter_unvisible","text":"filter_unvisible ()","title":"filter_unvisible()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.from_base_data","text":"from_base_data ( color : np . ndarray , depth : np . ndarray , extr_vecs : dict [ int , ndarray ], intr : np . ndarray , depth_scale : float , mesh_dict : dict [ int , MeshMeta ])","title":"from_base_data()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.gaussian_noise","text":"gaussian_noise () \u9ad8\u65af\u566a\u58f0","title":"gaussian_noise()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.modify_class_id","text":"modify_class_id ( modify_class_id_pairs : list [ tuple [ int ]])","title":"modify_class_id()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.plot","text":"plot () \u663e\u793a use plt.show() after this method to show","title":"plot()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.rotate","text":"rotate ( angle : float )","title":"rotate()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.rotate--brief","text":"\u65cb\u8f6c Parameters: angle ( float ) \u2013","title":"brief"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.rotate--return","text":"Description of the return","title":"return"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMeta.set_element","text":"set_element ( name : str , value )","title":"set_element()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMetaMaskContour","text":"Bases: ViewMeta","title":"ViewMetaMaskContour"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMetaMaskContour.LabelsAP","text":"Bases: AugmentPipeline","title":"LabelsAP"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMetaMaskContour.LabelsAP.new_masks_callback","text":"new_masks_callback = lambda : self . get_ap_of_meta ( self . meta . MasksAP ) . new_obj","title":"new_masks_callback"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMetaMaskContour.LabelsAP.obj","text":"obj","title":"obj"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMetaMaskContour.LabelsAP.__init__","text":"__init__ ( meta : ViewMeta ) -> None","title":"__init__()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMetaMaskContour.LabelsAP._crop","text":"_crop ( crop_rect : ndarray )","title":"_crop()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMetaMaskContour.LabelsAP._rotate","text":"_rotate ( M : cv2 . Mat )","title":"_rotate()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMetaMaskContour.MasksAP","text":"Bases: AugmentPipeline","title":"MasksAP"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMetaMaskContour.MasksAP.obj","text":"obj","title":"obj"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMetaMaskContour.MasksAP.__init__","text":"__init__ ( meta : ViewMeta ) -> None","title":"__init__()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMetaMaskContour.MasksAP._rotate","text":"_rotate ( M : ndarray )","title":"_rotate()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMetaMaskContour.VisibFractsAP","text":"Bases: AugmentPipeline","title":"VisibFractsAP"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMetaMaskContour.VisibFractsAP.new_masks_callback","text":"new_masks_callback = lambda : self . get_ap_of_meta ( self . meta . MasksAP ) . new_obj","title":"new_masks_callback"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMetaMaskContour.VisibFractsAP.obj","text":"obj","title":"obj"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMetaMaskContour.VisibFractsAP.old_masks_callback","text":"old_masks_callback = lambda : self . get_ap_of_meta ( self . meta . MasksAP ) . obj","title":"old_masks_callback"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMetaMaskContour.VisibFractsAP.__init__","text":"__init__ ( meta : ViewMeta ) -> None","title":"__init__()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMetaMaskContour.__init__","text":"__init__ ( color : ndarray , depth : ndarray , masks : dict [ int , ndarray ], extr_vecs : dict [ int , ndarray ], intr : ndarray , depth_scale : float , bbox_3d : dict [ int , ndarray ], landmarks : dict [ int , ndarray ], visib_fracts : dict [ int , float ], labels : dict [ int , ndarray ] = None ) -> None","title":"__init__()"},{"location":"md/data/viewmeta/#data.viewmeta.ViewMetaMaskContour.calc_bbox2d_from_mask","text":"calc_bbox2d_from_mask ( mask_dict : dict [ int , ndarray ])","title":"calc_bbox2d_from_mask()"},{"location":"md/data/viewmeta/#data.viewmeta.calc_bbox2d_from_mask_contour","text":"calc_bbox2d_from_mask_contour ( mask_dict : dict [ int , np . ndarray ])","title":"calc_bbox2d_from_mask_contour()"},{"location":"md/data/viewmeta/#data.viewmeta.calc_bbox2d_from_mask_dict","text":"calc_bbox2d_from_mask_dict ( mask_dict : dict [ int , np . ndarray ])","title":"calc_bbox2d_from_mask_dict()"},{"location":"md/data/viewmeta/#data.viewmeta.copy_by_rect","text":"copy_by_rect ( crop_rect , org : np . ndarray )","title":"copy_by_rect()"},{"location":"md/data/viewmeta/#data.viewmeta.ignore_viewmeta_warning","text":"ignore_viewmeta_warning ( func )","title":"ignore_viewmeta_warning()"},{"location":"md/data/viewmeta/#data.viewmeta.query_key_by_value","text":"query_key_by_value ( orig_dict : dict )","title":"query_key_by_value()"},{"location":"md/data/viewmeta/#data.viewmeta.rot_xy_list_2dpoints","text":"rot_xy_list_2dpoints ( M , points_2d : np . ndarray ) -> list [ float ] points_2d [N, (x,y)]","title":"rot_xy_list_2dpoints()"},{"location":"md/data/viewmeta/#data.viewmeta.rotate_image","text":"rotate_image ( M , image : np . ndarray )","title":"rotate_image()"}]}